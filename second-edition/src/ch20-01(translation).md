# https://rinthel.github.io/rust-lang-book-ko/ch20-01-single-threaded.html#listening-to-the-tcp-connection

## 싱글스레드 기반 웹 서버 만들기

싱글 스레드 기반의 웹 서버가 작동하는것을 알아보는것 부터 시작하겠습니다. 시작하기 전에, 웹서버를 구성하는 프로토콜들에 대해 빠르게 훑어보죠, 
프로토콜들에 대한 자세한 설명은 이 책의 범주를 넘어가지만, 간단한 설명은 여러분에게 도움이 될 것입니다.

웹서버의 두 주요 프로토콜은 HTTP(Hyper Transfer Protocol)과 TCP(Transmission Control Protocol)입니다. 이 두 프로토콜은 요청-응답 프로토콜입니다. 요청-응답은 클라이언트가 요청을 생성하면, 서버는 요청을 받고 클라이언트에게 응답하는 과정을 뜻합니다. 요청과 응답의 내용은 각 프로토콜에 의해 정의됩니다.

TCP는 저레벨 프로토콜로, 한 서버에서 다른 서버로 정보를 요청할때 사용하지만, 해당 정보가 무엇인지는 특정하지 않습니다. HTTP는 TCP 상위에서 만들어졌으며, 요청과 응답의 내용을 정의하고 있습니다. HTTP가 TCP 이외의 프로토콜을 사용하는것은 기술적으론 불가능하지 않지만, 일반적으로 HTTP통신은 TCP프로토콜 위에서 이루어집니다. 이번 장에선 TCP를 이용한 바이트통신과 HTTP를 이용한 요청과 응답을 실습해 볼 것입니다.


## TCP 연결에 대한 처리

우리가 만들 웹 서버는 TCP 연결 요청에 대한 처리를 해야하기 떄문에, TCP 연결 요청을 수신하는 것 부터 작업하도록 하겠습니다. 이 작업은 표준 라이브러리의 ``std::net`` 모듈을 이용해 진행할 수 있습니다. 하던대로 새 프로젝트를 만들어 봅시다.

``` bash
$ cargo new hello --bin
     Created binary (application) `hello` project
$ cd hello
```

이제 20-1번 예제의 _src/main.rs_ 코드를 입력합시다. 이 코드는 ``127.0.0.1:7878``주소로 TCP 연결 요청에 대해 수신 대기할 것입니다. 만약 요청이 들어온다면, ``Connection established!``가 출력될 것입니다.

파일명: src/main.rs

``` rust
use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("Connection established!");
    }
}
```

예제 20-1: 수신 스트림 대기와 수신시 메시지 출력

우린 ``TcpListener``를 사용하여 ``127.0.0.1:7878``주소로 TCP연결을 수신할 수 있습니다. 이 주소의 `:` 앞부분은 자신 컴퓨터의 IP주소를 뜻합니다. (이건 모든 컴퓨터에서 동일하며, 저자의 컴퓨터에서만 해당하는 내용이 아닙니다.)
그리고 ``7878``은 포트를 뜻합니다. 여기서 이 포트를 사용한 이유는 두가지입니다. HTTP는 일반적으로 이 포트에서 요청되며, 7878은 "rust"를 전화기에서 입력했을때의 숫자이기 떄문입니다. 

Note 80포트를 이용한 연결은 관리자 권한이 필요합니다. 비 관리자는 1024 이상의 포트번호만 사용 가능합니다.

위 코드에서 ``bind``함수는 ``new``함수처럼 동작하며 ``TcpListner``의 새 객체를 반환합니다. 이 함수가 ``bind``라는 이름을 가진 이유는 네트워크 관련에서 포트를 수신대기하는 과정을 "포트를 binding한다" 라고 부르기 떄문입니다.

``bind``함수는 바인딩의 성공여부를 표시하는 ``Result<T, E>``를 반환합니다 예를들어, 우리가 만약 80포트를 관리자가 아닌 상태에서  연결하려고 시도할 경우나 같은 포트를 사용하는 프로그램을 여러개 실행할 경우에 바인딩은 실패하게 됩니다. 왜냐하면 우리는 학습을 목적으로 기초 서버를 작성하고 있으며, 이러한 에러들을 걱정할 필요가 없기 때문입니다. 대신에, 우리는 ``unwrap``을 이용해 에러가 생길 경우 프로그램을 멈출것입니다.

``TcpListener``의 ``incoming``메소드는 스트림의 차례에 대한 반복자를 반환합니다. (보다 정확히는, 여러 스트림의 종류 중 ``TcpStream``입니다).
각각의 _stream_ 은 클라이언트와 서버간의 열려있는 연결을 의미합니다. _connection_ 은 클라이언트가 서버와 연결하고, 서버가 응답을 생성하고, 서버가 연결을 끊는 일련의 전체적인 요청과 응답과정을 뜻합니다. 이와같이, ``TcpStream``은 클라이언트가 보낸 정보를 읽어들이고, 우리의 응답을 스트림에 작성할 수 있게 해줍니다. 전체적으로, 이 ``for``반복문은 각각의 연결을 처리하고 우리에게 일련의 스트림들을 제공합니다.

현재, 우리는 어떠한 오류가 있을경우 ``unwrap``을 호출하여 프로그램을 종료시키는 방식으로 스트림을 처리합니다. 만약 오류가 없을경우, 프로그램은 메시지를 출력합니다. 우린 다음 항목에서 오류가 없을 경우에 대한 기능을 더 추가할 것입니다. 우리가 ``incoming``메소드를 통해서 에러를 받을때의 이유는, 클라이언트가 서버로 연결할때 우리가 실제적인 연결을 반복하는것이 아닌, 연결 시도를 반복하기 때문입니다. 연결은 몇가지 이유로 실패할 수 있는데, 대다수의 경우 운영체제의 특성 때문입니다. 예를들어, 대부분의 운영체제는 동시에 열어놓을 수 있는 연결 개수에 제한을 가지고 있는데, 제한 이상으로 연결을 시도할 경우 이미 열려있는 연결이 닫힐때까지 오류를 발생시킵니다.

한번 이 코드를 실행해 봅시다. ``cargo run``을 터미널에 입력하고, 브라우저에서 ``127.0.0.1:7878``로 접속해봅시다. 브라우저는 "연결 재시도"와 같은 에러를 보여줄 것입니다. 이 이유는 현재의 서버는 어떠한 데이터도 전송하지 않기 때문입니다. 하지만 터미널을 보면, 브라우저가 서버에 접속할때 출력된 메시지들을 볼 수 있습니다!

``` bash
     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
```

종종, 브라우저로 한번 요청했을때 여러 메시지가 출력되는걸 보실겁니다. 이유는 브라우저가 페이지뿐만 아니라 다른 여러 리소스를 요청하기 때문입니다. 대표적으로 브라우저 탭에 표시되는 아이콘인 ``favicon.ico``가 있습니다.

또한 서버가 어떠한 데이터도 보내주지 않기 때문에 브라우저가 여러번 연결을 시도했기 때문일 수도 있습니다. ``stream``이 영역를 벗어날 경우와 반복이 끝날때, ``drop``이 실행되는것처럼 연결이 끊어집니다. 브라우저는 서버와의 연결 문제가 일시적일 수도 있기 때문에 끊어진 연결을 재시도하기도 합니다. 여기서 중요한건 우리가 성공적으로 TCP연결을 처리했다는 것입니다.

이전 버전의 코드가 실행되는 프로그램을 종료할때는 ``ctrl-c``를 누르고, 여러분이 만든 새 버전의 코드를 실행하기 위해 ``cargo run``명령어를 입력하는것을 기억하세요

## 요청 데이터 읽기

브라우저로부터의 요청을 읽는 기능을 구현해봅시다! 부담갖지 말고 '연결하기', '연결을 이용해보기' 로 나눠서 진행해봅시다. 연결을 처리하기 위해 새 함수를 만들어 봅시다. 여기선 ``handle_connection``이라는 함수를 새로 만들었습니다. TCP 스트림에서 데이터를 읽고 출력해보며 브라우저가 보낸 데이터를 직접 확인해봅시다. 코드를 예제 20-2와 같이 변경합니다.

파일명: src/main.rs

``` rust
use std::io::prelude::*;
use std::net::TcpStream;
use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&mut buffer).unwrap();

    println!("Request: {}", String::from_utf8_lossy(&buffer[..]));
}
```

예제 20-2: ``TcpStream``으로부터 데이터를 읽고 출력

우린 ``std::io::prelude``를 가져와 스트림으로부터 읽고 쓰는것에 대해 확실한 특성?. ``main``함수 내부의 ``for``반복문 안에서는, 연결에 성공했다는 메시지를 출력하는 대신, 새로 만든 ``handle_connection``함수를 ``stream``을 전달하여 호출합니다.

``handle_connection``함수에선, ``stream``매개변수를 동적으로 만들어 줬습니다. 이유는 ``TcpStream``객체가 내부에서 어떤 데이터가 우리에게 반환되는지 추적하기 떄문입니다. 우리가 요청하는것에 따라 더 많은 데이터를 읽거나, 다음 요청때까지 데이터를 저장할 수 있습니다. 이와 같이 내부의 상태가 변경될 수 있기에 ``mut``이 되어야 합니다. 보통 "읽기"는 변화와 관련이 없다고 생각하지만 이 경우 ``mut``키워드가 필요합니다.

다음으로, 우린 실제로 스트림으로부터 데이터를 읽어볼 것입니다. 이는 두가지 과정으로 나뉘는데: 먼저, 