## `Rc<T>`, 참조 카운팅 스마트 포인터

대부분의 경우에서, 소유권은 명확합니다: 여러분은 어떤 변수가 주어진 값을
소유하는지 정확히 압니다. 그러나, 하나의 값이 여러 개의 소유자를 갖을 수도
있는 경우가 있습니다. 예를 들면, 그래프 데이터 구조에서, 여러 에지가
동일한 노드를 가리킬 수도 있고, 그 노드는 개념적으로 해당 노드를 가리키는
모든 에지들에 의해 소유됩니다. 노드는 어떠한 에지도 이를 가리키지 않을
때까지는 메모리 정리가 되어서는 안됩니다.

복수 소유권을 가능하게 하기 위해서, 러스트는 `Rc<T>`라 불리우는 타입을 가지고
있습니다. 이 이름은 *참조 카운팅 (reference counting)* 의 약자인데, 이는
어떤 값이 계속 사용되는지 혹은 그렇지 않은지를 알기 위해 해당 값에 대한 참조자의
갯수를 계속 추적하는 것입니다. 만일 값에 대한 참조자가 0개라면, 그 값은 어떠한
참조자도 무효화하지 않고 메모리 정리될 수 있습니다.

`Rc<T>`를 거실의 TV로 상상해보세요. 만일 한 사람이 TV를 보러 들어온다면,
TV를 킵니다. 다른 사람들은 거실로 들어와서 TV를 볼 수 있습니다. 마지막 사람이
거실을 나선다면, TV는 더 이상 사용되지 않으므로 이를 끕니다. 만일 다른 사람들이
여전히 TV를 보고 있는 중에 누군가가 이를 끈다면, 남은 TV 시청자들로부터 엄청난
소란이 있을 것입니다!

우리 프로그램의 여러 부분에서 읽을 데이터를 힙에 할당하고 싶고, 어떤 부분이
그 데이터를 마지막에 이용하게 될지 컴파일 타임에는 알 수 없는 경우 `Rc<T>`
타입을 사용합니다. 만일 어떤 부분이 마지막으로 사용하는지 알 수 있다면,
우리는 그냥 그 해당 부분을 데이터의 소유자로 만들면 되고, 컴파일 타임에 집행되는
보통의 소유권 규칙이 효과를 발생시킬 것입니다.

`Rc<T>`가 오직 단일 스레드 시나리오 상에서만 사용 가능하다는 점을 주의하세요.
16장에서 동시성 (cuncurrency) 을 논의할 때, 다중 스레드 프로그램에서는
어떻게 참조 카운팅을 하는지 다루겠습니다.

### `Rc<T>`를 사용하여 데이터 공유하기

Listing 15-5의 cons list 예제로 돌아가 봅시다. 우리는 `Box<T>`를 이용해서
이것을 정의했던 것을 상기하세요. 이번에는 세 번째 리스트의 소유권을 둘 다 공유하는
두 개의 리스트를 만들 것인데, 이는 개념적으로 Figure 15-3과 유사하게 보일 것입니다:

<img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" />

<span class="caption">Figure 15-3: 세 번째 리스트 `a`의 소유권을 공유하는
두 리스트 `b`와 `c`</span>

우리는 5와 10을 담은 리스트 `a`를 만들 것입니다. 그런 다음 두 개의 리스트를 더
만들 것입니다: 3으로 시작하는 `b`와 4로 시작하는 `c`입니다. 그리고나서 `b`와 `c`
리스트 둘 모두 5와 10을 담고 있는 첫번째 `a` 리스트로 계속되게 할 것입니다.
바꿔 말하면, 두 리스트 모두 5와 10을 담은 첫 리스트를 공유하게 될 것입니다.


Listing 15-17에서 보시는 것처럼, 우리가 `Box<T>`를 가지고 정의한 `List`를
이용하여 이 시나리오를 구현하는 시도는 작동하지 않을 것입니다:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
```

<span class="caption">Listing 15-17: `Box<T>`를 이용한 두 리스트가 세 번째
리스트의 소유권을 공유하는 시도는 허용되지 않음을 보이는 예</span>

이 코드를 컴파일하면, 다음과 같은 에러를 얻습니다:

```text
error[E0382]: use of moved value: `a`
  --> src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not implement
   the `Copy` trait
```

`Cons` variant는 이것이 가지고 있는 데이터를 소유하므로, 우리가 `b`리스트를 만들때,
`a`는 `b` 안으로 이동되고 `b`는 `a`를 소유합니다. 그 뒤, `c`를 생성할 때 `a`를
다시 이용하는 시도를 할 경우, 이는 `a`가 이동되었으므로 허용되지 않습니다.

우리는 `Cons`가 대신 참조자를 갖도록 정의를 변경할 수도 있지만, 그러면
라이프타임 파라미터를 명시해야 할 것입니다. 라이프타임 파라미터를 명시함으로써,
리스트 내의 모든 요소들이 최소한 전체 리스트만큼 오래 살아있도록 명시될 것입니다.
빌림 검사기는 예를 들면 `let a = Cons(10, &Nil);`을 컴파일되도록 하지
않게 할텐데, 이는 일시적인 `Nil` 값은 `a`가 그에 대한 참조자를 갖을 수도 있는
시점 이전에 버려질 것이기 때문입니다.

대신, 우리는 Listing 15-18과 같이 `Box<T>`의 자리에 `Rc<T>`를 이용하여
`List`의 정의를 바꿀 것입니다. 각각의 `Cons` variant는 이제 어떤 값과
`List`를 가리키는 `Rc<T>`를 갖게 될 것입니다. `b`를 만들때는 `a`의
소유권을 얻는 대신, `a`를 가지고 있는 `Rc<List>`를 클론할 것인데, 이는
참조자의 갯수를 하나에서 둘로 증가시키고 `a`와 `b`가 `Rc<List>` 안에
있는 값을 공유하게 해줍니다. 우리는 또한 `c`를 만들때도 `a`를 클론할
것인데, 이는 참조자의 갯수를 둘에서 셋으로 늘립니다. 우리가 `Rc::clone`을
호출하는 매번마다, 해당 `Rc<List>`가 가지고 있는 데이터에 대한 참조 카운트는
증가할 것이고, 그 데이터는 참조자가 0개가 되지 않으면 메모리 정리되지 않을
것입니다:

<span class="filename">Filename: src/main.rs</span>

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
```

<span class="caption">Listing 15-18: `Rc<T>`를 이용하는 `List`
정의</span>

We need to add a `use` statement to bring `Rc<T>` into scope because it’s not
in the prelude. In `main`, we create the list holding 5 and 10 and store it in
a new `Rc<List>` in `a`. Then when we create `b` and `c`, we call the
`Rc::clone` function and pass a reference to the `Rc<List>` in `a` as an
argument.

We could have called `a.clone()` rather than `Rc::clone(&a)`, but Rust’s
convention is to use `Rc::clone` in this case. The implementation of
`Rc::clone` doesn’t make a deep copy of all the data like most types’
implementations of `clone` do. The call to `Rc::clone` only increments the
reference count, which doesn’t take much time. Deep copies of data can take a
lot of time. By using `Rc::clone` for reference counting, we can visually
distinguish between the deep copy kinds of clones and the kinds of clones that
increase the reference count. When looking for performance problems in the
code, we only need to consider the deep copy clones and can disregard calls to
`Rc::clone`.

### Cloning an `Rc<T>` Increases the Reference Count

Let’s change our working example in Listing 15-18 so we can see the reference
counts changing as we create and drop references to the `Rc<List>` in `a`.

In Listing 15-19, we’ll change `main` so it has an inner scope around list `c`;
then we can see how the reference count changes when `c` goes out of scope. At
each point in the program where the reference count changes, we’ll print the
reference count, which we can get by calling the `Rc::strong_count` function.
This function is named `strong_count` rather than `count` because the `Rc<T>`
type also has a `weak_count`; we’ll see what `weak_count` is used for in the
“Preventing Reference Cycles” section.

<span class="filename">Filename: src/main.rs</span>

```rust
# enum List {
#     Cons(i32, Rc<List>),
#     Nil,
# }
#
# use List::{Cons, Nil};
# use std::rc::Rc;
#
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
```

<span class="caption">Listing 15-19: Printing the reference count</span>

This code prints the following:

```text
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
```

We can see that the `Rc<List>` in `a` has an initial reference count of one;
then each time we call `clone`, the count goes up by one. When `c` goes out of
scope, the count goes down by one. We don’t have to call a function to decrease
the reference count like we have to call `Rc::clone` to increase the reference
count: the implementation of the `Drop` trait decreases the reference count
automatically when an `Rc<T>` value goes out of scope.

What we can’t see in this example is that when `b` and then `a` go out of scope
at the end of `main`, the count is then 0, and the `Rc<List>` is cleaned up
completely at that point. Using `Rc<T>` allows a single value to have
multiple owners, and the count ensures that the value remains valid as long as
any of the owners still exist.

Via immutable references, `Rc<T>` allows us to share data between multiple
parts of our program for reading only. If `Rc<T>` allowed us to have multiple
mutable references too, we might violate one of the borrowing rules discussed
in Chapter 4: multiple mutable borrows to the same place can cause data races
and inconsistencies. But being able to mutate data is very useful! In the next
section, we’ll discuss the interior mutability pattern and the `RefCell<T>`
type that we can use in conjunction with an `Rc<T>` to work with this
immutability restriction.
