<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>스트링 - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <style>
            .page-wrapper.has-warning > .nav-chapters {
              /* add height for warning content & margin */
              top: 120px;
            }

            p.warning {
                background-color: rgb(242, 222, 222);
                border-bottom-color: rgb(238, 211, 215);
                border-bottom-left-radius: 4px;
                border-bottom-right-radius: 4px;
                border-bottom-style: solid;
                border-bottom-width: 0.666667px;
                border-image-outset: 0 0 0 0;
                border-image-repeat: stretch stretch;
                border-image-slice: 100% 100% 100% 100%;
                border-image-source: none;
                border-image-width: 1 1 1 1;
                border-left-color: rgb(238, 211, 215);
                border-left-style: solid;
                border-left-width: 0.666667px;
                border-right-color: rgb(238, 211, 215);
                border-right-style: solid;
                border-right-width: 0.666667px;
                border-top-color: rgb(238, 211, 215);
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                border-top-style: solid;
                border-top-width: 0.666667px;
                color: rgb(185, 74, 72);
                margin-bottom: 0px;
                margin-left: 0px;
                margin-right: 0px;
                margin-top: 30px;
                padding-bottom: 8px;
                padding-left: 14px;
                padding-right: 35px;
                padding-top: 8px;
            }
            p.warning strong {
                color: rgb(185, 74, 72)
            }
            p.warning a {
                color: rgb(0, 136, 204)
            }
        </style>

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="ch01-00-introduction.html"><strong>1.</strong> Introduction</a></li><li><ul class="section"><li><a href="ch01-01-installation.html"><strong>1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong>1.2.</strong> Hello, World!</a></li></ul></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong>2.</strong> 추리 게임 튜토리얼</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong>3.</strong> 보편적인 프로그래밍 개념</a></li><li><ul class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong>3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong>3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong>3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong>3.5.</strong> Control Flow</a></li></ul></li><li><a href="ch04-00-understanding-ownership.html"><strong>4.</strong> 소유권 이해하기</a></li><li><ul class="section"><li><a href="ch04-01-what-is-ownership.html"><strong>4.1.</strong> 소유권이 뭔가요?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong>4.2.</strong> 참조자와 빌림</a></li><li><a href="ch04-03-slices.html"><strong>4.3.</strong> 슬라이스</a></li></ul></li><li><a href="ch05-00-structs.html"><strong>5.</strong> 연관된 데이터들을 구조체로 다루기</a></li><li><ul class="section"><li><a href="ch05-01-defining-structs.html"><strong>5.1.</strong> 구조체를 정의하고 생성하기</a></li><li><a href="ch05-02-example-structs.html"><strong>5.2.</strong> An Example Program Using Structs</a></li><li><a href="ch05-03-method-syntax.html"><strong>5.3.</strong> Method Syntax</a></li></ul></li><li><a href="ch06-00-enums.html"><strong>6.</strong> 열거형과 패턴 매칭</a></li><li><ul class="section"><li><a href="ch06-01-defining-an-enum.html"><strong>6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong>6.2.</strong> The <code>match</code> Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong>6.3.</strong> Concise Control Flow with <code>if let</code></a></li></ul></li><li><a href="ch07-00-modules.html"><strong>7.</strong> 모듈</a></li><li><ul class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong>7.1.</strong> <code>mod</code>와 파일 시스템</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong>7.2.</strong> <code>pub</code>으로 가시성 제어하기</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong>7.3.</strong> <code>use</code>로 이름 가져오기</a></li></ul></li><li><a href="ch08-00-common-collections.html"><strong>8.</strong> 일반적인 컬렉션</a></li><li><ul class="section"><li><a href="ch08-01-vectors.html"><strong>8.1.</strong> 벡터</a></li><li><a href="ch08-02-strings.html" class="active"><strong>8.2.</strong> 스트링</a></li><li><a href="ch08-03-hash-maps.html"><strong>8.3.</strong> 해쉬맵</a></li></ul></li><li><a href="ch09-00-error-handling.html"><strong>9.</strong> 에러 처리</a></li><li><ul class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong>9.1.</strong> <code>panic!</code>과 함께하는 복구 불가능한 에러</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong>9.2.</strong> <code>Result</code>와 함께하는 복구 가능한 에러</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong>9.3.</strong> <code>panic!</code>이냐, <code>panic!</code>이 아니냐, 그것이 문제로다</a></li></ul></li><li><a href="ch10-00-generics.html"><strong>10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ul class="section"><li><a href="ch10-01-syntax.html"><strong>10.1.</strong> Generic Data Types</a></li><li><a href="ch10-02-traits.html"><strong>10.2.</strong> Traits: Defining Shared Behavior</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong>10.3.</strong> Validating References with Lifetimes</a></li></ul></li><li><a href="ch11-00-testing.html"><strong>11.</strong> Testing</a></li><li><ul class="section"><li><a href="ch11-01-writing-tests.html"><strong>11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong>11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong>11.3.</strong> Test Organization</a></li></ul></li><li><a href="ch12-00-an-io-project.html"><strong>12.</strong> An I/O Project</a></li><li><ul class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong>12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong>12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong>12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong>12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong>12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong>12.6.</strong> Writing to <code>stderr</code> instead of <code>stdout</code></a></li></ul></li><li><a href="ch13-00-functional-features.html"><strong>13.</strong> Functional Language Features in Rust</a></li><li><ul class="section"><li><a href="ch13-01-closures.html"><strong>13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong>13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong>13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong>13.4.</strong> Performance</a></li></ul></li><li><a href="ch14-00-more-about-cargo.html"><strong>14.</strong> More about Cargo and Crates.io</a></li><li><ul class="section"><li><a href="ch14-01-release-profiles.html"><strong>14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong>14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong>14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong>14.4.</strong> Installing Binaries from Crates.io with <code>cargo install</code></a></li><li><a href="ch14-05-extending-cargo.html"><strong>14.5.</strong> Extending Cargo with Custom Commands</a></li></ul></li><li><a href="ch15-00-smart-pointers.html"><strong>15.</strong> Smart Pointers</a></li><li><ul class="section"><li><a href="ch15-01-box.html"><strong>15.1.</strong> <code>Box&lt;T&gt;</code> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong>15.2.</strong> The <code>Deref</code> Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong>15.3.</strong> The <code>Drop</code> Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong>15.4.</strong> <code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong>15.5.</strong> <code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong>15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ul></li><li><a href="ch16-00-concurrency.html"><strong>16.</strong> Fearless Concurrency</a></li><li><ul class="section"><li><a href="ch16-01-threads.html"><strong>16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong>16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong>16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong>16.4.</strong> Extensible Concurrency: <code>Sync</code> and <code>Send</code></a></li></ul></li><li><a href="ch17-00-oop.html"><strong>17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ul class="section"><li><a href="ch17-01-what-is-oo.html"><strong>17.1.</strong> What Does Object-Oriented Mean?</a></li><li><a href="ch17-02-trait-objects.html"><strong>17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong>17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ul></li><li><a href="ch18-00-patterns.html"><strong>18.</strong> Patterns Match the Structure of Values</a></li><li><ul class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong>18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="ch18-02-refutability.html"><strong>18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong>18.3.</strong> All the Pattern Syntax</a></li></ul></li><li><a href="ch19-00-advanced-features.html"><strong>19.</strong> Advanced Features</a></li><li><ul class="section"><li><a href="ch19-01-unsafe-rust.html"><strong>19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong>19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong>19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html"><strong>19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong>19.5.</strong> Advanced Functions &amp; Closures</a></li></ul></li><li><a href="ch20-00-final-project-a-web-server.html"><strong>20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ul class="section"><li><a href="ch20-01-single-threaded.html"><strong>20.1.</strong> A Single Threaded Web Server</a></li><li><a href="ch20-02-slow-requests.html"><strong>20.2.</strong> How Slow Requests Affect Throughput</a></li><li><a href="ch20-03-designing-the-interface.html"><strong>20.3.</strong> Designing the Thread Pool Interface</a></li><li><a href="ch20-04-storing-threads.html"><strong>20.4.</strong> Creating the Thread Pool and Storing Threads</a></li><li><a href="ch20-05-sending-requests-via-channels.html"><strong>20.5.</strong> Sending Requests to Threads Via Channels</a></li><li><a href="ch20-06-graceful-shutdown-and-cleanup.html"><strong>20.6.</strong> Graceful Shutdown and Cleanup</a></li></ul></li><li><a href="appendix-00.html"><strong>21.</strong> Appendix</a></li><li><ul class="section"><li><a href="appendix-01-keywords.html"><strong>21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong>21.2.</strong> B - Operators</a></li><li><strong>21.3.</strong> C - Derivable Traits</li><li><strong>21.4.</strong> D - Nightly Rust</li><li><strong>21.5.</strong> E - Macros</li><li><strong>21.6.</strong> F - Translations</li><li><a href="appendix-07-newest-features.html"><strong>21.7.</strong> G - Newest Features</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper has-warning">

            <div class="page">
                <header><p class="warning">You are reading a <strong>draft</strong> of the next edition of TRPL. For more, go <a href="../index.html">here</a>.</p></header>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>


                <div id="content" class="content">
                    <a class="header" href="ch08-02-strings.html#스트링" id="스트링"><h2>스트링</h2></a>
<p>4장에서 스트링에 관한 이야기를 많이 했습니다만, 지금은 좀더 깊이 살펴보겠습니다. 스트링은 새로운
러스트인들이 흔히 막히는 부분입니다. 이는 세 가지의 조합으로 인한 것입니다: 가능한 에러를 꼭 노출하도록
하는 러스트의 성향, 많은 프로그래머의 예상보다 더 복잡한 데이터 구조인 스트링, 그리고 UTF-8입니다.
다른 언어들을 사용하다 왔을 때 이들의 조합이 러스트의 스트링을 어려운 것처럼 보이게 합니다.</p>
<p>스트링이 컬렉션 장에 있는 이유는 스트링이 바이트의 컬렉션 및 이 바이트들을 텍스트로 통역할때 유용한
기능을 제공하는 몇몇 메소드로 구현되어 있기 때문입니다. 이번 절에서는 생성, 갱신, 값 읽기와 같은
모든 컬렉션 타입이 가지고 있는, <code>String</code>에서의 연산에 대해 이야기 해보겠습니다. 또한 <code>String</code>을
다른 컬렉션들과 다르게 만드는 부분, 즉 사람과 컴퓨터가 <code>String</code> 데이터를 통역하는 방식의 차이로
인해 생기는 <code>String</code> 인덱싱의 복잡함을 논의해보겠습니다.</p>
<a class="header" href="ch08-02-strings.html#스트링이-뭔가요" id="스트링이-뭔가요"><h3>스트링이 뭔가요?</h3></a>
<p>이 부분을 깊이 파고들기 전에, 우리가 <em>스트링</em>이라는 용어로 정확히 무엇을 뜻하는 것인지 말해둘 필요가
있겠습니다. 러스트는 핵심 언어 기능 내부에 단 한가지 스트링 타입을 제공합니다: 바로 <code>str</code>인데,
이는 스트링 슬라이스며, 이것의 참조자 형태인 <code>&amp;str</code>을 많이 봤죠. 4장에서는 <em>스트링 슬라이스</em>에 대해
얘기했습니다: 이는 다른 어딘가에 저장된 UTF-8로 인코딩된 스트링 데이터의 참조자입니다. 예를 들어,
스트링 리터럴은 프로그램의 바이너리 출력물 내에 저장되어 있으며, 그러므로 스트링 슬라이스입니다.</p>
<p><code>String</code>이라고 부르는 타입은 핵심 언어 기능 내에 구현된 것이 아니고 러스트의 표준 라이브러리를
통해 제공되며, 커질 수 있고, 가변적이며, 소유권을 갖고 있고, UTF-8로 인코딩된 스트링 타입입니다.
러스트인들이 “스트링”에 대해 이야기할 때, 그들은 보통 <code>String</code>과 스트링 슬라이스 <code>&amp;str</code> 타입
둘 모두를 이야기한 것이지, 이들 중 하나를 뜻한 것은 아닙니다. 이번 절은 대부분 <code>String</code>에 관한
것이지만, 두 타입 모두 러스트 표준 라이브러리에서 매우 많이 사용됩니다. <code>String</code>과 스트링 슬라이스
모두 UTF-8로 인코딩되어 있습니다.</p>
<p>또한 러스트 표준 라이브러리는 <code>OsString</code>, <code>OsStr</code>, <code>CString</code>, 그리고 <code>CStr</code>과 같은 몇가지
다른 스트링 타입도 제공합니다. 심지어 어떤 라이브러리 크레이트들은 스트링 데이터를 저장하기 위해
더 많은 옵션을 제공할지도 모릅니다. <code>*String</code>/<code>*Str</code>이라는 작명과 유사하게, 이들은 종종 소유권이
있는 타입과 이를 빌린 변형 타입을 제공하는데, 이는 <code>String</code>/<code>&amp;str</code>과 비슷합니다. 이러한 스트링
타입들은, 예를 들면 다른 종류의 인코딩을 저장하거나 다른 방식으로 메모리에 저장될 수도 있습니다.
여기서는 이러한 다른 스트링 타입은 다루지 않겠습니다; 이것들을 어떻게 쓰고 어떤 경우에 적합한지에
애해 알고 싶다면 각각의 API 문서를 확인하시기 바랍니다.</p>
<a class="header" href="ch08-02-strings.html#새로운-스트링-생성하기" id="새로운-스트링-생성하기"><h3>새로운 스트링 생성하기</h3></a>
<p><code>Vec</code>에서 쓸 수 있는 많은 연산들이 <code>String</code>에서도 마찬가지로 똑같이 쓰일 수 있는데, <code>new</code> 함수를
이용하여 스트링을 생성하는 것으로 아래와 같이 시작해봅시다:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut s = String::new();

#}</code></pre></pre>
<p>이는 우리가 어떤 데이터를 담아둘 수 있는 <code>s</code>라는 빈 스트링을 만들어 줍니다.</p>
<p>종종 우리는 스트링에 담아두고 시작할 초기값을 가지고 있을 것입니다. 그런 경우, <code>to_string</code> 메소드를
이용하는데, 이는 <code>Display</code> 트레잇이 구현된 어떤 타입이든 사용 가능하며, 스트링 리터럴도 이 트레잇을
구현하고 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let data = &quot;initial contents&quot;;

let s = data.to_string();

// the method also works on a literal directly:
let s = &quot;initial contents&quot;.to_string();

#}</code></pre></pre>
<p>이는 <code>initial contents</code>를 담고 있는 스트링을 생성합니다.</p>
<p>또한 스트링 리터럴로부터 <code>String</code>을 생성하기 위해서 <code>String::from</code> 함수를 이용할 수도 있습니다.
이는 <code>to_string</code>을 사용하는 것과 동일합니다:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;initial contents&quot;);

#}</code></pre></pre>
<p>스트링이 너무나 많은 것들에 사용되기 때문에, 스트링을 위해 사용될 수 있는 다양한 제네릭 API들이 있으며,
옵션들도 여러가지입니다. 몇몇은 쓸모없는 것처럼 느껴질 수도 있지만, 다 사용할 곳이 있습니다! 지금의 경우,
<code>String::from</code>과 <code>.to_string</code>은 정확히 똑같은 일을 하며, 따라서 어떤 것을 사용하는가는
여러분의 스타일에 따라 달린 문제입니다.</p>
<p>스트링이 UTF-8로 인코딩되었음을 기억하세요. 즉, 우리는 인코딩된 어떤 데이터라도 포함시킬 수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let hello = &quot;السلام عليكم&quot;;
let hello = &quot;Dobrý den&quot;;
let hello = &quot;Hello&quot;;
let hello = &quot;שָׁלוֹם&quot;;
let hello = &quot;नमस्ते&quot;;
let hello = &quot;こんにちは&quot;;
let hello = &quot;안녕하세요&quot;;
let hello = &quot;你好&quot;;
let hello = &quot;Olá&quot;;
let hello = &quot;Здравствуйте&quot;;
let hello = &quot;Hola&quot;;

#}</code></pre></pre>
<a class="header" href="ch08-02-strings.html#스트링-갱신하기" id="스트링-갱신하기"><h3>스트링 갱신하기</h3></a>
<p><code>String</code>은 크기가 커질 수 있으며 이것이 담고 있는 내용물은 <code>Vec</code>의 내용물과 마찬가지로 더 많은
데이터를 집어넣음으로써 변경될 수 있습니다. 추가적으로, 편의를 위해 <code>String</code>은 <code>+</code> 연산자에
접합(concatenation) 연산을 구현하였습니다.</p>
<a class="header" href="ch08-02-strings.html#푸시를-이용하여-스트링-추가하기" id="푸시를-이용하여-스트링-추가하기"><h4>푸시를 이용하여 스트링 추가하기</h4></a>
<p>스트링 슬라이스를 추가하기 위해 <code>push_str</code> 메소드를 이용하여 <code>String</code>을 키울 수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);

#}</code></pre></pre>
<p><code>s</code>는 이 두 라인 뒤에 “foobar”를 담게 될 것입니다. <code>push_str</code> 메소드는 스트링 슬라이스를 파라미터로
갖는데 이는 파라미터의 소유권을 가져올 필요가 없기 때문입니다. 예를 들어, 아래와 같은 상황에서 <code>s1</code>에
<code>s2</code>의 내용물을 추가한 뒤 <code>s2</code>를 더 이상 쓸 수 없게된다면 당혹스러울 것입니다:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut s1 = String::from(&quot;foo&quot;);
let s2 = String::from(&quot;bar&quot;);
s1.push_str(&amp;s2);

#}</code></pre></pre>
<p><code>push</code> 메소드는 한 개의 글자를 파라미터로 받아서 <code>String</code>에 추가하도록 정의되어 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;lo&quot;);
s.push('l');

#}</code></pre></pre>
<p>이걸 실행한 뒤에 <code>s</code>는 “lol”을 담고 있을 것입니다.</p>
<a class="header" href="ch08-02-strings.html#-연산자나-format-매크로를-이용한-접합" id="-연산자나-format-매크로를-이용한-접합"><h4>+ 연산자나 <code>format!</code> 매크로를 이용한 접합</h4></a>
<p>종종 우리는 가지고 있는 두 개의 스트링을 합께 조합하고 싶어합니다. 한 가지 방법은 아래와 같이 <code>+</code> 연산자를
사용하는 것입니다:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // s1은 여기서 이동되어 더이상 쓸 수 없음을 유의하세요

#}</code></pre></pre>
<p>이 코드가 실행된 뒤에 스트링 <code>s3</code>는 <code>Hello, world!</code>를 담게 될 것입니다. <code>s1</code>이 더하기 연산
이후에 더이상 유효하지 않은 이유와 <code>s2</code>의 참조자가 사용되는 이유는 <code>+</code> 연산자를 사용했을 때 호출되는
함수의 시그니처와 맞춰야 하기 때문입니다 <code>+</code> 연산자는 <code>add</code> 메소드를 사용하는데, 이 메소드의
시그니처는 아래처럼 생겼습니다:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>이는 표준 라이브러리에 있는 정확한 시그니처는 아닙니다; 표준 라이브러리 내에서 <code>add</code>는 제네릭을 이용하여
정의되어 있습니다. 여기서는 제네릭에 구체 타입(concrete type)을 대입한 <code>add</code>의 시그니처를 보는
중인데, 이는 우리가 <code>String</code> 값으로 이 메소드를 호출했을때 생깁니다. 제네릭에 대한 내용은 10장에서
다룰 것입니다. 이 시그니처는 교묘한 <code>+</code> 연산자를 이해하는데 필요한 단서를 줍니다.</p>
<p>첫번째로, <code>s2</code>는 <code>&amp;</code>를 가지고 있는데, 이는 첫번째 스트링에 두번째 스트링의 <em>참조자</em>를 더하고 있음을
뜻합니다. 이것은 <code>add</code> 함수의 <code>s</code> 파라미터 때문입니다: 우리는 <code>String</code>에 <code>&amp;str</code>만 더할 수 있고,
두 <code>String</code>을 더하지는 못합니다. 하지만, 잠깐만요 - <code>&amp;s2</code>의 타입은 <code>&amp;String</code>이지, <code>add</code>의 두번째
파라미터에 명시한것처럼 <code>&amp;str</code>은 아니죠. 왜 이 예제가 컴파일될까요? <code>&amp;s2</code>를 <code>add</code> 호출에 사용할 수
있는 이유는 <code>&amp;String</code> 인자가 <code>&amp;str</code>로 <em>강제</em>될 수 있기 때문입니다 - <code>add</code> 함수가 호출되면,
러스트는 <em>역참조 강제(deref coercion)</em> 라 불리는 무언가를 사용하는데, 이는 <code>add</code> 함수내에서 사용되는 <code>&amp;s2</code>가
<code>&amp;s2[..]</code>로 비뀌는 것으로 생각할 수 있도록 해줍니다. 역참조 강제에 대한 것은 15장에서 다룰
것입니다. <code>add</code>가 파라미터의 소유권을 가져가지는 않으므로, <code>s2</code>는 이 연산 이후에도 여전히 유효한
<code>String</code>일 것입니다.</p>
<p>두번째로, 시그니처에서 <code>add</code>가 <code>self</code>의 소유권을 가져가는 것을 볼 수 있는데, 이는 <code>self</code>가
<code>&amp;</code>를 <em>안 가지고</em> 있기 때문입니다. 즉 위 예제에서 <code>s1</code>이 <code>add</code> 호출로 이동되어 이후에는 더 이상
유효하지 않을 것이라는 의미입니다. 따라서 <code>let s3 = s1 + &amp;s2;</code>가 마치 두 스트링을 복사하여
새로운 스트링을 만들 것처럼 보이는 반면, 실제로 이 구문은 <code>s1</code>의 소유권을 가져다가 <code>s2</code>의 내용물의
복사본을 추가한 다음, 결과물의 소유권을 반환합니다. 달리 말하면, 이 구문은 여러 복사본을 만드는 것처럼
보여도, 그렇지 않습니다: 이러한 구현은 복사보다 더 효율적입니다.</p>
<p>If we need to concatenate multiple strings, the behavior of <code>+</code> gets unwieldy:
만일 여러 스트링을 접하고자 한다면, <code>+</code>의 동작은 다루기 불편해 집니다.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;

#}</code></pre></pre>
<p><code>s</code>는 이 지점에서 “tic-tac-toe”가 될 것입니다. 모든 <code>+</code>와 <code>&quot;</code> 문자들과 함께 보면 어떤 결과가
나올지 알기 힘듭니다. 더 복잡한 스트링 조합을 위해서는 <code>format!</code> 매크로를 사용할 수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);

#}</code></pre></pre>
<p>이 코드 또한 <code>s</code>에 “tic-tac-toe”을 설정합니다. <code>format!</code> 매크로는 <code>println!</code>과 똑같은 방식으로
작동하지만, 스크린에 결과를 출력하는 대신 결과를 담은 <code>String</code>을 반환해줍니다. 이 버전이 훨씬 읽기
쉽고, 또한 어떠한 파라미터들의 소유권도 가져가지 않습니다.</p>
<a class="header" href="ch08-02-strings.html#스트링-내부의-인덱싱" id="스트링-내부의-인덱싱"><h3>스트링 내부의 인덱싱</h3></a>
<p>다른 많은 언어들에서, 인덱스를 이용한 참조를 통해 스트링 내부의 개별 문자들에 접근하는 것은 유효하고
범용적인 연산에 속합니다. 그러나 러스트에서는 인덱싱 문법을 이용하여 <code>String</code>의 부분에 접근하고자 하면
에러를 얻게 됩니다. 즉 아래와 같은 코드는:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let h = s1[0];
</code></pre>
<p>아래와 같은 에러를 출력합니다:</p>
<pre><code class="language-text">error: the trait bound `std::string::String: std::ops::Index&lt;_&gt;` is not
satisfied [--explain E0277]
  |&gt;
  |&gt;     let h = s1[0];
  |&gt;             ^^^^^
note: the type `std::string::String` cannot be indexed by `_`
</code></pre>
<p>에러와 노트 부분이 이야기해 줍니다: 러스트 스트링은 인덱싱을 지원하지 않는다고. 따라서 뒤따르는 질문은,
왜 안되는 걸까요? 이 질문에 답하기 위해서는 러스트가 어떻게 스트링을 메모리에 저장하는지에 관하여 살짝
이야기해야 합니다.</p>
<a class="header" href="ch08-02-strings.html#내부적-표현" id="내부적-표현"><h4>내부적 표현</h4></a>
<p><code>String</code>은 <code>Vec&lt;u8&gt;</code>을 감싼 것입니다(wrapper). 전에 보았던 몇가지 적절히 인코딩된 UTF-8
예제 스트링을 살펴봅시다. 첫번째로, 이것입니다:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Hola&quot;).len();

#}</code></pre></pre>
<p>이 경우, <code>len</code>은 4가 되는데, 이는 스트링 “Hola”를 저장하고 있는 <code>Vec</code>이 4바이트 길이라는 뜻입니다:
UTF-8로 인코딩되면 각각의 글자들이 1바이트씩 차지한다는 것이죠. 그런데 아래 예제는 어떨까요?</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Здравствуйте&quot;).len();

#}</code></pre></pre>
<p>이 스트링의 길이가 얼마인지 질문받은 사람은 12라고 답할런지도 모릅니다. 그러나 러스트의 대답은 24입니다.
이는 “Здравствуйте”를 UTF-8로 인코딩된 바이트들의 크기인데, 각각의 유니코드 스칼라 값이 저장소의
2바이트를 차지하기 때문입니다. 따라서, 스트링의 바이트들 안의 인덱스는 유효한 유니코드 스칼라 값과
항상 대응되지는 않을 것입니다.</p>
<p>이를 보여주기 위해, 다음과 같은 유효하지 않은 러스트 코드를 고려해 보세요:</p>
<pre><code class="language-rust ignore">let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];
</code></pre>
<p><code>answer</code>의 값은 무엇이 되어야 할까요? 첫번째 글자인 <code>З</code>이 되어야 할까요? UTF-8로 인코딩될 때,
<code>З</code>의 첫번째 바이트는 <code>208</code>이고, 두번째는 <code>151</code>이므로, <code>answer</code>는 사실 <code>208</code>이 되어야 하지만,
<code>208</code>은 그 자체로는 유효한 문자가 아닙니다. <code>208</code>을 반환하는 것은 사람들이 이 스트링의 첫번째 글자를
요청했을 경우 사람들이 기대하는 것이 아닙니다. 심지어는 라틴 글자들만 있을 때도요: <code>&amp;&quot;hello&quot;[0]</code>는
<code>h</code>가 아니라 <code>104</code>를 반환합니다. 기대치 않은 값을 반환하고 즉시 발견하기 힘들지도 모를 버그를 야기하는
것을 방지하기 위해, 러스트는 이러한 코드를 전혀 컴파일되지 않는 것을 채택하고 이러한 오해들을 일찌감치
방지합니다.</p>
<a class="header" href="ch08-02-strings.html#바이트와-스칼라-값과-문자소-클러스터grapheme-cluster-이런" id="바이트와-스칼라-값과-문자소-클러스터grapheme-cluster-이런"><h4>바이트와 스칼라 값과 문자소 클러스터(Grapheme cluster)! 이런!</h4></a>
<p>이는 UTF-8에 대한 다른 지점을 이끌어냅니다: 러스트의 관점에서는 문자열을 보는 세 가지의 정말
의미있는 방식이 있습니다: 바이트, 스칼라 값, 그리고 문자소 클러스터(사람들이 <em>글자</em>라고 부르는 것과
가장 근접한 것)입니다.</p>
<p>데바가나리 글자로 쓰여진 힌디어 “नमस्ते”를 보면, 이것은 궁극적으로 아래와 같이 <code>u8</code> 값들의
<code>Vec</code>으로서 저장됩니다:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>이건 18바이트이고, 컴퓨터가 이 데이터를 궁극적으로 저장하는 방법입니다. 만일 우리가 이를 유니코드 스칼라
값, 즉 러스트의 <code>char</code> 타입인 형태로 본다면, 아래와 같이 보이게 됩니다:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>여섯개의 <code>char</code> 값이 있지만, 네번쨰와 여섯번째는 글자가 아니고 그 자체로는 이해할 수 없는 발음 구별
부호입니다. 마지막으로, 만일 이를 문자소 클러스로서 본다면, 사람들이 발음할 이 단어를 구성하는 네 글자를
얻습니다:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>러스트는 컴퓨터가 저장하는 가공되지 않은(raw) 스트링을 번역하는 다른 방법을 제공하여, 데이터가 담고 있는
것이 어떤 인간의 언어든 상관없이 각각의 프로그램이 필요로 하는 통역방식을 선택할 수 있도록 합니다.</p>
<p>러스트가 <code>String</code>을 인덱스로 접근하여 문자를 얻지 못하도록 하는 마지막 이유는 인덱스 연산이
언제나 상수 시간(O(1))에 실행될 것으로 기대받기 때문입니다. 그러나 <code>String</code>을 가지고 그러한
성능을 보장하는 것은 불가능한데, 그 이유는 러스트가 스트링 내에 얼마나 많은 유효 문자가 있는지
알아내기 위해 내용물의 시작 지점부터 인덱스로 지정된 곳까지 훑어야 하기 때문입니다.</p>
<a class="header" href="ch08-02-strings.html#스트링-슬라이싱하기" id="스트링-슬라이싱하기"><h3>스트링 슬라이싱하기</h3></a>
<p>스트링 인덱싱의 리턴 타입이 어떤 것이 되어야 하는지 투명하지 않고, 스트링의 인덱싱이 종종 나쁜 아이디어이기
때문에, 여러분이 정말로 이를 원할 경우 러스트는 좀 더 구체적으로 지정하도록 요청하는 형태로 여러분을
만류합니다. <code>[]</code>에 숫자 하나를 사용하는 인덱싱보다 더 구체적일 수 있는 방법은 <code>[]</code>와 범위를 사용하여
특정 바이트들이 담고 있는 스트링 슬라이스를 만드는 것입니다:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];

#}</code></pre></pre>
<p>여기서 <code>s</code>는 스트링의 첫 4바이트를 담고 있는 <code>&amp;str</code>가 될 것입니다. 앞서 우리는 이 글자들이 각각
2바이트를 차지한다고 언급했으므로, 이는 <code>s</code>가 “Зд”이 될 것이란 뜻입니다.</p>
<p>만약에 <code>&amp;hello[0..1]</code>라고 했다면 어떻게 될까요? 답은 다음과 같습니다: 런타임에 패닉이 발생하는데,
이는 벡터 내에 유효하지 않은 인덱스에 접근했을 때와 동일한 방식입니다:</p>
<pre><code class="language-text">thread 'main' panicked at 'index 0 and/or 1 in `Здравствуйте` do not lie on
character boundary', ../src/libcore/str/mod.rs:1694
</code></pre>
<p>여러분은 조심스럽게 이 방법을 사용해야 하는데, 이는 여러분의 프로그램을 죽게 만들 수도 있기 때문입니다.</p>
<a class="header" href="ch08-02-strings.html#스트링-내에서-반복적으로-실행되는-메소드" id="스트링-내에서-반복적으로-실행되는-메소드"><h3>스트링 내에서 반복적으로 실행되는 메소드</h3></a>
<p>다행히도, 스트링의 요소에 접근하는 다른 방법이 있습니다.</p>
<p>만일 개별적인 유니코드 스칼라 값에 대한 연산을 수행하길 원한다면, 가장 좋은 방법은 <code>chars</code> 메소드를
이용하는 것입니다. <code>chars</code>를 “नमस्ते”에 대해 호출하면 <code>char</code>타입의 6개의 값으로 나누어 반환하며,
여러분은 각각의 요소에 접근하기 위해 이 결과값에 대해 반복(iterate)할 수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}

#}</code></pre></pre>
<p>이 코드는 다음을 출력할 것입니다:</p>
<pre><code class="language-text">न
म
स
्
त
े
</code></pre>
<p><code>bytes</code> 메소드는 가공되지 않은 각각의 바이트를 반환하는데, 여러분의 문제 범위에 따라 적절할 수도
있습니다:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}

#}</code></pre></pre>
<p>이 코드는 이 <code>String</code>을 구성하는 아래처럼 시작되는 18 바이트를 출력합니다:</p>
<pre><code class="language-text">224
164
168
224
// ... etc
</code></pre>
<p>하지만 유효한 유니코드 스칼라 값이 하나 이상의 바이트로 구성될지도 모른다는 것을 확실히 기억해주세요.</p>
<p>스트링으로부터 문자소 클러스터를 얻는 방법은 복잡해서, 이 기능은 표준 라이브러리를 통해 제공되지 않습니다.
여러분이 원하는 기능이 이것이라면 crates.io에서 사용 가능한 크레이트가 있습니다.</p>
<a class="header" href="ch08-02-strings.html#스트링은-그렇게-단순하지-않습니다" id="스트링은-그렇게-단순하지-않습니다"><h3>스트링은 그렇게 단순하지 않습니다</h3></a>
<p>종합하면, 스트링은 복잡합니다. 다른 프로그래밍 언어들은 이러한 복잡성을 프로그래머에게 어떻게 보여줄지에
대해 각기 다른 선택을 합니다. 러스트는 <code>String</code> 데이터의 올바른 처리가 모든 러스트 프로그램에 대한
기본적인 동작이 되도록 선택했는데, 이는 솔직히 프로그래머들이 UTF-8 데이터를 처리하는데 있어 더 많은
생각을 해야한다는 의미입니다. 이러한 거래는 다른 프로그래밍 언어들에 비해 더 복잡한 스트링을 노출시키지만,
한편으로는 여러분의 개발 생활 주기 후반에 비 ASCII 캐릭터를 포함하는 에러를 처리해야 하는 것을
막아줄 것입니다.</p>
<p>이것보다 살짝 덜 복잡한 것으로 옮겨 갑시다: 해쉬맵이요!</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ch08-01-vectors.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch08-03-hash-maps.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ch08-01-vectors.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="ch08-03-hash-maps.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="store.js"></script>
        <script src="book.js"></script>
    </body>
</html>
