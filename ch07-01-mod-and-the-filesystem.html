<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>`mod`와 파일 시스템 - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <style>
            .page-wrapper.has-warning > .nav-chapters {
              /* add height for warning content & margin */
              top: 120px;
            }

            p.warning {
                background-color: rgb(242, 222, 222);
                border-bottom-color: rgb(238, 211, 215);
                border-bottom-left-radius: 4px;
                border-bottom-right-radius: 4px;
                border-bottom-style: solid;
                border-bottom-width: 0.666667px;
                border-image-outset: 0 0 0 0;
                border-image-repeat: stretch stretch;
                border-image-slice: 100% 100% 100% 100%;
                border-image-source: none;
                border-image-width: 1 1 1 1;
                border-left-color: rgb(238, 211, 215);
                border-left-style: solid;
                border-left-width: 0.666667px;
                border-right-color: rgb(238, 211, 215);
                border-right-style: solid;
                border-right-width: 0.666667px;
                border-top-color: rgb(238, 211, 215);
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                border-top-style: solid;
                border-top-width: 0.666667px;
                color: rgb(185, 74, 72);
                margin-bottom: 0px;
                margin-left: 0px;
                margin-right: 0px;
                margin-top: 30px;
                padding-bottom: 8px;
                padding-left: 14px;
                padding-right: 35px;
                padding-top: 8px;
            }
            p.warning strong {
                color: rgb(185, 74, 72)
            }
            p.warning a {
                color: rgb(0, 136, 204)
            }
        </style>

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="ch01-00-introduction.html"><strong>1.</strong> Introduction</a></li><li><ul class="section"><li><a href="ch01-01-installation.html"><strong>1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong>1.2.</strong> Hello, World!</a></li></ul></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong>2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong>3.</strong> Common Programming Concepts</a></li><li><ul class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong>3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong>3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong>3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong>3.5.</strong> Control Flow</a></li></ul></li><li><a href="ch04-00-understanding-ownership.html"><strong>4.</strong> 소유권 이해하기</a></li><li><ul class="section"><li><a href="ch04-01-what-is-ownership.html"><strong>4.1.</strong> 소유권이 뭔가요?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong>4.2.</strong> 참조자와 빌림</a></li><li><a href="ch04-03-slices.html"><strong>4.3.</strong> 슬라이스</a></li></ul></li><li><a href="ch05-00-structs.html"><strong>5.</strong> Using Structs to Structure Related Data</a></li><li><ul class="section"><li><a href="ch05-01-defining-structs.html"><strong>5.1.</strong> Defining and Instantiating Structs</a></li><li><a href="ch05-02-example-structs.html"><strong>5.2.</strong> An Example Program Using Structs</a></li><li><a href="ch05-03-method-syntax.html"><strong>5.3.</strong> Method Syntax</a></li></ul></li><li><a href="ch06-00-enums.html"><strong>6.</strong> Enums and Pattern Matching</a></li><li><ul class="section"><li><a href="ch06-01-defining-an-enum.html"><strong>6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong>6.2.</strong> The <code>match</code> Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong>6.3.</strong> Concise Control Flow with <code>if let</code></a></li></ul></li><li><a href="ch07-00-modules.html"><strong>7.</strong> 모듈</a></li><li><ul class="section"><li><a href="ch07-01-mod-and-the-filesystem.html" class="active"><strong>7.1.</strong> <code>mod</code>와 파일 시스템</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong>7.2.</strong> <code>pub</code>으로 가시성 제어하기</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong>7.3.</strong> Importing Names with <code>use</code></a></li></ul></li><li><a href="ch08-00-common-collections.html"><strong>8.</strong> Common Collections</a></li><li><ul class="section"><li><a href="ch08-01-vectors.html"><strong>8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html"><strong>8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong>8.3.</strong> Hash Maps</a></li></ul></li><li><a href="ch09-00-error-handling.html"><strong>9.</strong> Error Handling</a></li><li><ul class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong>9.1.</strong> Unrecoverable Errors with <code>panic!</code></a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong>9.2.</strong> Recoverable Errors with <code>Result</code></a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong>9.3.</strong> To <code>panic!</code> or Not To <code>panic!</code></a></li></ul></li><li><a href="ch10-00-generics.html"><strong>10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ul class="section"><li><a href="ch10-01-syntax.html"><strong>10.1.</strong> Generic Data Types</a></li><li><a href="ch10-02-traits.html"><strong>10.2.</strong> Traits: Defining Shared Behavior</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong>10.3.</strong> Validating References with Lifetimes</a></li></ul></li><li><a href="ch11-00-testing.html"><strong>11.</strong> Testing</a></li><li><ul class="section"><li><a href="ch11-01-writing-tests.html"><strong>11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong>11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong>11.3.</strong> Test Organization</a></li></ul></li><li><a href="ch12-00-an-io-project.html"><strong>12.</strong> An I/O Project</a></li><li><ul class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong>12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong>12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong>12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong>12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong>12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong>12.6.</strong> Writing to <code>stderr</code> instead of <code>stdout</code></a></li></ul></li><li><a href="ch13-00-functional-features.html"><strong>13.</strong> Functional Language Features in Rust</a></li><li><ul class="section"><li><a href="ch13-01-closures.html"><strong>13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong>13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong>13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong>13.4.</strong> Performance</a></li></ul></li><li><a href="ch14-00-more-about-cargo.html"><strong>14.</strong> More about Cargo and Crates.io</a></li><li><ul class="section"><li><a href="ch14-01-release-profiles.html"><strong>14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong>14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong>14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong>14.4.</strong> Installing Binaries from Crates.io with <code>cargo install</code></a></li><li><a href="ch14-05-extending-cargo.html"><strong>14.5.</strong> Extending Cargo with Custom Commands</a></li></ul></li><li><a href="ch15-00-smart-pointers.html"><strong>15.</strong> Smart Pointers</a></li><li><ul class="section"><li><a href="ch15-01-box.html"><strong>15.1.</strong> <code>Box&lt;T&gt;</code> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong>15.2.</strong> The <code>Deref</code> Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong>15.3.</strong> The <code>Drop</code> Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong>15.4.</strong> <code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong>15.5.</strong> <code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong>15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ul></li><li><a href="ch16-00-concurrency.html"><strong>16.</strong> Fearless Concurrency</a></li><li><ul class="section"><li><a href="ch16-01-threads.html"><strong>16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong>16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong>16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong>16.4.</strong> Extensible Concurrency: <code>Sync</code> and <code>Send</code></a></li></ul></li><li><a href="ch17-00-oop.html"><strong>17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ul class="section"><li><a href="ch17-01-what-is-oo.html"><strong>17.1.</strong> What Does Object-Oriented Mean?</a></li><li><a href="ch17-02-trait-objects.html"><strong>17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong>17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ul></li><li><a href="ch18-00-patterns.html"><strong>18.</strong> Patterns Match the Structure of Values</a></li><li><ul class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong>18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="ch18-02-refutability.html"><strong>18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong>18.3.</strong> All the Pattern Syntax</a></li></ul></li><li><a href="ch19-00-advanced-features.html"><strong>19.</strong> Advanced Features</a></li><li><ul class="section"><li><a href="ch19-01-unsafe-rust.html"><strong>19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong>19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong>19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html"><strong>19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong>19.5.</strong> Advanced Functions &amp; Closures</a></li></ul></li><li><a href="ch20-00-final-project-a-web-server.html"><strong>20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ul class="section"><li><a href="ch20-01-single-threaded.html"><strong>20.1.</strong> A Single Threaded Web Server</a></li><li><a href="ch20-02-slow-requests.html"><strong>20.2.</strong> How Slow Requests Affect Throughput</a></li><li><a href="ch20-03-designing-the-interface.html"><strong>20.3.</strong> Designing the Thread Pool Interface</a></li><li><a href="ch20-04-storing-threads.html"><strong>20.4.</strong> Creating the Thread Pool and Storing Threads</a></li><li><a href="ch20-05-sending-requests-via-channels.html"><strong>20.5.</strong> Sending Requests to Threads Via Channels</a></li><li><a href="ch20-06-graceful-shutdown-and-cleanup.html"><strong>20.6.</strong> Graceful Shutdown and Cleanup</a></li></ul></li><li><a href="appendix-00.html"><strong>21.</strong> Appendix</a></li><li><ul class="section"><li><a href="appendix-01-keywords.html"><strong>21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong>21.2.</strong> B - Operators</a></li><li><strong>21.3.</strong> C - Derivable Traits</li><li><strong>21.4.</strong> D - Nightly Rust</li><li><strong>21.5.</strong> E - Macros</li><li><strong>21.6.</strong> F - Translations</li><li><a href="appendix-07-newest-features.html"><strong>21.7.</strong> G - Newest Features</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper has-warning">

            <div class="page">
                <header><p class="warning">You are reading a <strong>draft</strong> of the next edition of TRPL. For more, go <a href="../index.html">here</a>.</p></header>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>


                <div id="content" class="content">
                    <a class="header" href="ch07-01-mod-and-the-filesystem.html#mod와-파일-시스템" id="mod와-파일-시스템"><h2><code>mod</code>와 파일 시스템</h2></a>
<p>먼저 카고를 이용해서 새로운 프로젝트를 만드는 것으로 모듈 예제를 시작하려고 하는데,
바이너리 크레이트(crate)을 만드는 대신에 라이브러리 크레이트을 만들 것입니다. 여기서
라이브러리 크레이트이란 다른 사람들이 자신들의 프로젝트에 디펜던시(dependency)로 추가할
수 있는 프로젝트를 말합니다. 예를 들어, 2장의 <code>rand</code> 크레이트은 우리가 추측 게임
프로젝트에서 디펜던시로 사용했던 라이브러리 크레이트입니다.</p>
<p>우리는 몇가지 일반적인 네트워크 기능을 제공하는 라이브러리의 뼈대를 만들 것입니다;
여기서는 모듈들과 함수들의 조직화에 집중할 것이고, 함수의 본체에 어떤 코드가 들어가야
하는지는 신경쓰지 않겠습니다. 이 라이브러리를 <code>communicator</code>라고 부르겠습니다.
기본적으로, 카고는 다른 타입의 프로젝트로 특정하지 않는 이상 라이브러리를 만들
것입니다: 이전의 모든 장들에서 사용해왔던 <code>--bin</code> 옵션을 제거하면, 프로젝트는
라이브러리가 될 것입니다:</p>
<pre><code class="language-text">$ cargo new communicator
$ cd communicator
</code></pre>
<p>카고가 <em>src/main.rs</em> 대신 <em>src/lib.rs</em>을 생성했음을 주목하세요. <em>src/lib.rs</em>
내부를 보면 다음과 같은 코드를 찾을 수 있습니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
    }
}

#}</code></pre></pre>
<p>카고는 우리가 만든 라이브러리의 작성 시작을 돕기 위해 빈 테스트를 만드는데,
이는 <code>--bin</code> 옵션을 사용했을때 “Hello, world!” 바이너리를 만들어준 것과 사뭇
다릅니다. <code>#[]</code>와 <code>mod tests</code> 문법은 이 장의 “<code>super</code>를 이용하여 부모 모듈에
접근하기”절에서 더 자세히 다룰 것이지만, 당장은 <em>src/lib.rs</em>의 아래쪽에 이 코드를
남겨두겠습니다.</p>
<p><em>src/main.rs</em> 파일이 없기 떄문에, <code>cargo run</code> 커맨드로 카고가 실행할 것이 없습니다.
따라서, 여기서는 라이브러리 크레이트의 코드를 컴파일하기 위해 <code>cargo build</code>를 사용할
것입니다.</p>
<p>이제 여러분이 작성하는 코드의 의도에 따라 만들어지는 다양한 상황에 알맞도록 라이브러리
코드를 조직화하는 다양한 옵션들을 살펴보겠습니다.</p>
<a class="header" href="ch07-01-mod-and-the-filesystem.html#모듈-정의" id="모듈-정의"><h3>모듈 정의</h3></a>
<p>우리의 <code>communicator</code> 네트워크 라이브러리를 위해서, 먼저 <code>connect</code>라는 이름의 함수가
정의되어 있는 <code>network</code>라는 이름의 모듈을 정의하겠습니다. 러스트 내 모듈 정의는 모두
<code>mod</code>로 시작됩니다. 이 코드를 <em>src/lib.rs</em>의 시작 부분, 즉 테스트 코드의 윗 쪽에
추가해봅시다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}

#}</code></pre></pre>
<p><code>mod</code> 키워드 뒤에, 모듈의 이름 <code>network</code>가 쓰여지고 중괄호 안에 코드 블록이 옵니다.
이 블록 안의 모든 것은 이름공간 <code>network</code> 안에 있습니다. 위의 경우 <code>connect</code>라는
이름의 함수 하나가 있습니다. 이 함수를 <code>network</code> 모듈 바깥의 스크립트에서 호출하고자
한다면, 우리는 모듈을 특정할 필요가 있으므로 이름공간 문법 <code>::</code>를 이용해야 합니다:
<code>connect()</code> 이렇게만 하지 않고 <code>network::connect()</code> 이런 식으로요.</p>
<p>또한 같은 <em>src/lib.rs</em> 파일 내에 여러 개의 모듈을 나란히 정의할 수도 있습니다.
예를 들어, <code>connect</code>라는 이름의 함수를 갖고 있는 <code>client</code> 모듈을 정의하려면,
Listing 7-1에 보시는 바와 같이 이를 추가할 수 있습니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}

mod client {
    fn connect() {
    }
}

#}</code></pre></pre>
<p><span class="caption">Listing 7-1: <em>src/lib.rs</em> 내에 나란히 정의된 <code>network</code>
모듈과 <code>client</code> 모듈</span></p>
<p>이제 우리는 <code>network::connect</code> 함수와 <code>client::connect</code> 함수를 갖게 되었습니다.
이들은 완전히 다른 기능을 갖고 있을 수 있고, 서로 다른 모듈에 정의되어 있기 때문에
함수 이름이 서로 부딪힐 일은 없습니다.</p>
<p>이 경우, 우리가 라이브러리를 만드는 중이기 때문에, 라이브러리의 시작 지점으로서
제공되는 파일은 <em>src/lib.rs</em> 입니다. 하지만 모듈을 만드는 것에 관하여
<em>src/lib.rs</em>는 특별할 것이 없습니다. 우리는 라이브러리 크레이트의 <em>src/lib.rs</em> 내에
모듈을 만드는 것과 똑같은 방식으로 바이너리 크레이트의 <em>src/main.rs</em> 내에도 모듈을
만들 수 있습니다. 사실 모듈 안에 다른 모듈을 집어넣는 것도 가능한데, 이는 여러분의
모듈이 커짐에 따라 관련된 기능이 잘 조직화 되도록 하는 한편 각각의 기능을 잘 나누도록
하는데 유용할 수 있습니다. 여러분의 코드를 어떻게 조직화 할 것인가에 대한 선택은
여러분이 코드의 각 부분 간의 관계에 대해 어떻게 생각하고 있는지에 따라 달라집니다.
예를 들어, Listing 7-2와 같이 <code>client</code> 모듈과 <code>connect</code> 함수가 <code>network</code> 이름공간
내에 있다면 우리의 라이브러리 사용자가 더 쉽게 이해할지도 모릅니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }

    mod client {
        fn connect() {
        }
    }
}

#}</code></pre></pre>
<p><span class="caption">Listing 7-2: <code>client</code> 모듈을 <code>network</code> 모듈 안으로 이동</span></p>
<p><em>src/lib.rs</em> 파일에서 Listing 7-2와 같이 <code>client</code> 모듈이 <code>network</code> 모듈의
내부 모듈이 되도록 <code>mod network</code>와 <code>mod client</code>의 위치를 바꿔 봅시다. 이제
우리는 <code>network::connect</code>와 <code>network::client::connect</code> 함수를 갖게 되었습니다:
다시 말하지만, <code>connect</code>라는 이름의 두 함수는 서로 다른 이름공간에 있으므로
부딪힐 일이 없습니다.</p>
<p>이런 식으로 모듈들은 계층을 구성하게 됩니다. <em>src/lib.rs</em>의 내용은 가장 위의 층을
이루고, 서브 모듈들은 그보다 낮은 층에 있습니다. Listing 7-1 예제에서의 조직화가
계층 구조를 생각했을 때 어떻게 보일지 살펴봅시다:</p>
<pre><code class="language-text">communicator
 ├── network
 └── client
</code></pre>
<p>그리고 Listing 7-2 예제에 대응되는 계층 구조는 이렇습니다:</p>
<pre><code class="language-text">communicator
 └── network
     └── client
</code></pre>
<p>Listing 7-2에서 계층 구조는 <code>client</code>가 <code>network</code>의 형제이기 보다는 자식임을
보여줍니다. 더 복잡한 프로젝트는 많은 수의 모듈을 갖고 있을 수 있고, 이들은 지속적인
트래킹을 위해 논리적으로 잘 조직화될 필요가 있을 것입니다. 여러분의 프로젝트 내에서
“논리적으로”가 의미하는 것은 여러분에게 달려 있는 것이며, 여러분과 여러분의 라이브러리
사용자들이 프로젝트 도메인에 대해 어떻게 생각하는지에 따라 달라집니다. 여러분이 선호하는
어떤 형태의 구조이건 간에 여기서 보여준 나란한 모듈 및 중첩된(nested) 모듈을 만드는
테크닉을 이용해 보세요.</p>
<a class="header" href="ch07-01-mod-and-the-filesystem.html#모듈을-다른-파일로-옮기기" id="모듈을-다른-파일로-옮기기"><h3>모듈을 다른 파일로 옮기기</h3></a>
<p>Modules form a hierarchical structure, much like another structure in computing
that you’re used to: filesystems! We can use Rust’s module system along with
multiple files to split up Rust projects so not everything lives in
<em>src/lib.rs</em> or <em>src/main.rs</em>. For this example, let’s start with the code in
Listing 7-3:
모듈은 계층적인 구조를 형성하는데, 여러분이 익숙하게 사용하고 있는 다른 구조와 매우 닮았습니다: 바로
파일 시스템이죠! 러스트에서는 프로젝트를 잘게 나누기 위해 여러 개의 파일 상에서 모듈 시스템을 사용할
수 있어, 모든 것들이 <em>src/lib.rs</em>나 <em>src/main.rs</em> 안에 존재하지 않게할 수 있습니다. 이러한
예를 위해서, Listing 7-3에 있는 코드를 시작해봅시다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
mod client {
    fn connect() {
    }
}

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}

#}</code></pre></pre>
<p><span class="caption">Listing 7-3: 세 개의 모듈 <code>client</code>, <code>network</code>, <code>network::server</code>가
모두 <em>src/lib.rs</em>에 정의되어 있음</span></p>
<p>파일 <em>src/lib.rs</em>는 아래와 같은 모듈 계층을 갖고 있습니다:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<p>만일 이 모듈들이 여러 개의 함수들을 갖고 있고, 이 함수들이 길어지고 있다면, 우리가 작업하고자 하는
코드를 찾으려고 이 파일을 스크롤 하기가 까다로워질 것입니다. 함수들은 하나 혹은 그 이상의 <code>mod</code> 블록
안에 포함되어 있기 떄문에, 함수 내의 코드 라인들 또한 길어지기 시작할 것입니다. 이는 <code>client</code>,
<code>network</code>, 그리고 <code>server</code> 모듈을 <em>src/lib.rs</em>로부터 떼어내어 각자를 위한 파일들에 위치시키기
좋은 이유가 되겠습니다.</p>
<p>먼저 <code>client</code> 모듈의 코드를 <code>client</code> 모듈의 선언 부분만 남겨두는 것으로 바꾸세요. 그러니까 여러분의
<em>src/lib.rs</em>는 아래와 같이 될 것입니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
</code></pre>
<p>여기서는 여전히 <code>client</code> 모듈을 <em>선언</em>하고 있지만, 코드 블록을 세미콜론으로 대체함으로써, 우리는
러스트에게 <code>client</code> 모듈의 스코프 내에 정의된 코드를 다른 위치에서 찾으라고 말하는 것입니다. 달리
말하면, <code>mod client;</code>라는 라인의 뜻은 이렇습니다:</p>
<pre><code class="language-rust ignore">mod client {
    // contents of client.rs
}
</code></pre>
<p>이제 모듈의 이름과 같은 이름을 가진 외부 파일을 만들 필요가 있습니다. <em>client.rs</em> 파일을 여러분의
<em>src/</em> 디렉토리에 생성하고 여세요. 그런 뒤 아래와 같이 앞 단계에서 제거했던 <code>client</code> 모듈내의
<code>connect</code> 함수를 입력해세요:</p>
<p><span class="filename">Filename: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn connect() {
}

#}</code></pre></pre>
<p>이미 <em>src/lib.rs</em> 안에다 <code>client</code> 모듈을 <code>mod</code>를 이용하여 선언을 했기 때문에,
이 파일 안에는 <code>mod</code> 선언이 필요없다는 점을 기억하세요. 이 파일은 단지 <code>client</code> 모듈의 <em>내용물</em>만
제공할 뿐입니다. 만일 <code>mod client</code>를 여기에 또 집어넣는다면, 이는 <code>client</code> 모듈 내에 서브모듈
<code>client</code>를 만들게 됩니다!</p>
<p>러스트는 기본적으로 <em>src/lib.rs</em>만 찾아볼줄 압니다. 만약에 더 많은 파일을 프로젝트에 추가하고
싶다면, <em>src/lib.rs</em> 내에서 다른 파일을 찾아보라고 러스트에게 말해줄 필요가 있습니다; 이는
<code>mod client</code>라는 코드가 왜 <em>src/lib.rs</em> 내에 정의될 필요가 있는지, 그리고 <em>src/client.rs</em>
내에는 정의될 수 없는지에 대한 이유입니다.</p>
<p>이제 몇 개의 컴파일 경고가 생기지만, 프로젝트는 성공적으로 컴파일 되어야 합니다. 우리가 바이너리 크레이트
대신 라이브러리 크레이트를 만드는 중이므로 <code>cargo run</code> 대신 <code>cargo build</code>를 이용해야 한다는 점을
기억해두세요:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/client.rs:1:1
  |
1 | fn connect() {
  | ^

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/lib.rs:4:5
  |
4 |     fn connect() {
  |     ^

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/lib.rs:8:9
  |
8 |         fn connect() {
  |         ^
</code></pre>
<p>이 경고들은 사용된 적이 없는 함수가 있음을 우리에게 알려줍니다. 지금은 이 경고들을 너무 걱정하지 마세요:
이 장의 뒤에 나오는 “<code>pub</code>을 이용하여 가시성 제어하기”절에서 이 문제에 대해 알아볼 것입니다. 좋은 소식은
이들이 그냥 경고일 뿐이란 것입니다; 우리 프로젝트는 성공적으로 빌드됐습니다!</p>
<p>다음으로 같은 방식을 이용하여 <code>network</code> 모듈을 개별 파일로 추출해봅시다. <em>src/lib.rs</em> 안에서,
아래와 같이 <code>network</code> 모듈의 몸체를 지우고 선언부의 끝부분에 세미콜론을 붙이세요:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network;
</code></pre>
<p>그리고나서 새로운 <em>src/network.rs</em> 파일을 만들어서 아래를 입력하세요:</p>
<p><span class="filename">Filename: src/network.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn connect() {
}

mod server {
    fn connect() {
    }
}

#}</code></pre></pre>
<p>이 모듈 파일 내에는 <code>mod</code> 선언이 여전히 있음을 주목하세요; 이는 <code>server</code>가 <code>network</code>의 서브모듈로서
여전히 필요하기 때문입니다.</p>
<p>Run <code>cargo build</code> again. Success! We have one more module to extract: <code>server</code>.
Because it’s a submodule—that is, a module within a module—our current tactic
of extracting a module into a file named after that module won’t work. We’ll
try anyway so you can see the error. First, change <em>src/network.rs</em> to have
<code>mod server;</code> instead of the <code>server</code> module’s contents:
<code>cargo build</code>를 다시 실행시키세요. 성공! 여기 또 추출할만한 모듈이 하나 더 있습니다: <code>server</code> 말이죠.
이것이 서브모듈(즉, 모듈 내의 모듈)이기 때문에, 모듈을 파일로 추출해서 파일 이름을 모듈 이름으로 사용하는
전략은 사용하기 힘듭니다. 어쨌든 시도해서 에러를 확인해보겠습니다. 먼저, <em>src/network.rs</em> 내에서
<code>server</code> 모듈의 내용물 대신에 <code>mod server</code>을 쓰세요:</p>
<p><span class="filename">Filename: src/network.rs</span></p>
<pre><code class="language-rust ignore">fn connect() {
}

mod server;
</code></pre>
<p>Then create a <em>src/server.rs</em> file and enter the contents of the <code>server</code>
module that we extracted:
그후 <em>src/server.rs</em> 파일을 만들고 추출해둔 <code>server</code> 모듈의 내용물을 입력하세요:</p>
<p><span class="filename">Filename: src/server.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn connect() {
}

#}</code></pre></pre>
<p><code>cargo build</code>를 실행해보면, Listing 7-4와 같은 에러를 얻게 됩니다:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
error: cannot declare a new module at this location
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
  |
note: maybe move this module `network` to its own directory via `network/mod.rs`
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
note: ... or maybe `use` the module `server` instead of possibly redeclaring it
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
</code></pre>
<p><span class="caption">Listing 7-4: <code>server</code> 서브모듈을 <em>src/server.rs</em>로 추출을 시도했을 때
발생하는 에러</span></p>
<p>에러는 <code>이 위치에 새로운 모듈을 선언할수 없다</code>고 말해주며 <em>src/network.rs</em>의 <code>mod server;</code>
라인을 지적하고 있습니다. <em>src/network.rs</em>는 <em>src/lib.rs</em>와는 다소 다릅니다: 왜 그런지
이해하려면 계속 읽어주세요.</p>
<p>Listing 7-4의 중간의 노트는 실질적으로 매우 도움이 되는데, 그 이유는 우리가 아직 설명하지 않은
무언가를 지적하고 있기 때문입니다:</p>
<pre><code class="language-text">note: maybe move this module `network` to its own directory via
`network/mod.rs`
</code></pre>
<p>전에 사용했던 똑같은 파일 이름 쓰기 패턴을 계속해서 따르는 대신, 아래 노트에서 제안하는 것을 해볼
수 있습니다:</p>
<ol>
<li>부모 모듈의 이름에 해당하는, <em>network</em>라는 이름의 새로운 <em>디렉토리</em>를 만드세요.</li>
<li><em>src/network.rs</em> 파일을 이 새로운 <em>network</em> 디렉토리 안으로 옮기고, 파일 이름을
<em>src/network/mod.rs</em>로 고치세요.</li>
<li>서브모듈 파일 <em>src/server.rs</em>를 <em>network</em> 디렉토리 안으로 옮기세요.</li>
</ol>
<p>위의 단계들을 실행하기 위한 명령들입니다:</p>
<pre><code class="language-text">$ mkdir src/network
$ mv src/network.rs src/network/mod.rs
$ mv src/server.rs src/network
</code></pre>
<p>이제 <code>cargo build</code>를 다시 실행하면, 컴파일은 작동할 것입니다 (여전히 경고는 좀 있지만요). 우리의
모듈 레이아웃은 여전히 아래와 같이 되는데, 이는 Listing 7-3의 <em>src/lib.rs</em> 내의 코드에서 만든 것과
정확하게 동일합니다:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<p>이에 대응하는 파일 레이아웃는 아래와 같이 생겼습니다:</p>
<pre><code class="language-text">├── src
│   ├── client.rs
│   ├── lib.rs
│   └── network
│       ├── mod.rs
│       └── server.rs
</code></pre>
<p>그러니까 우리가 <code>network::server</code> 모듈을 추출하고자 할 때, 왜 <code>network::server</code> 모듈을
<em>src/server.rs</em>로 추출하는 대신, <em>src/network.rs</em> 파일에 <em>src/network/mod.rs</em>로 옮기고
<code>network::server</code> 코드를 <em>network</em> 디렉토리 안에 있는 <em>src/network/server.rs</em>에 넣었을까요?
그 이유는 <em>src</em> 디렉토리 안에 <em>server.rs</em> 파일이 있으면, 러스트는 <code>server</code>가 <code>network</code>의
서브모듈이라고 인식할 수 없기 때문입니다. 러스트가 동작하는 방식을 명확하게 알기 위해서, 아래와 같은 모듈
계층 구조를 가진, <em>src/lib.rs</em> 내에 모든 정의가 다 들어있는 다른 예제를 봅시다:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── client
</code></pre>
<p>이 예제에는 또다시 <code>client</code>, <code>network</code>, 그리고 <code>network::client</code>라는 세 개의 모듈이 있습니다.
모듈을 파일로 추출하기 위해 앞서 했던 단계를 따르면, <code>client</code> 모듈을 위한 <em>src/client.rs</em>을
만들게 될 것입니다. <code>network</code> 모듈을 위해서는 <em>src/network.rs</em> 파일을 만들게 될 것입니다.
하지만 <code>network::client</code> 모듈을 <em>src/client.rs</em>로 추출하는 것은 불가능한데, 그 이유는
최상위 층에 <code>client</code> 모듈이 이미 있기 때문이죠! 만일 <code>client</code>와 <code>network::client</code> 모듈
<em>둘다</em> <em>src/client.rs</em> 파일에 집어넣는다면, 러스트는 이 코드가 <code>client</code>를 위한 것인지,
아니면 <code>network::client</code>를 위한 것인지 알아낼 방법이 없을 것입니다.</p>
<p>따라서, <code>network</code> 모듈의 <code>network::client</code> 서브모듈을 위한 파일을 추출하기 위해서는
<em>src/network.rs</em> 파일 대신 <code>network</code> 모듈을 위한 디렉토리를 만들 필요가 있습니다. <code>network</code>
모듈 내의 코드는 그후 <em>src/network/mod.rs</em> 파일로 가고, 서브모듈 <code>network::client</code>은
<em>src/network/client.rs</em> 파일을 갖게할 수 있습니다. 이제 최상위 층의 <em>src/client.rs</em>는
모호하지 않게 <code>client</code> 모듈이 소유한 코드가 됩니다.</p>
<a class="header" href="ch07-01-mod-and-the-filesystem.html#모듈-파일-시스템의-규칙" id="모듈-파일-시스템의-규칙"><h3>모듈 파일 시스템의 규칙</h3></a>
<p>파일에 관한 모듈의 규칙을 정리해봅시다:</p>
<ul>
<li>만일 <code>foo</code>라는 이름의 모듈이 서브모듈을 가지고 있지 않다면, <em>foo.rs</em>라는 이름의 파일 내에
<code>foo</code>에 대한 선언을 집어넣어야 합니다.</li>
<li>만일 <code>foo</code>가 서브모듈을 가지고 있다면, <em>foo/mod.rs</em>라는 이름의 파일에 <code>foo</code>에 대한 선언을
집어넣어야 합니다.</li>
</ul>
<p>이 규칙들은 재귀적으로 적용되므로, <code>foo</code>라는 이름의 모듈이 <code>bar</code>라는 이름의 서브모듈을 갖고 있고
`bar는 서브모듈이 없다면, 여러분의 <em>src</em> 디렉토리 안에는 아래와 같은 파일들이 있어야 합니다:</p>
<pre><code class="language-text">├── foo
│   ├── bar.rs (contains the declarations in `foo::bar`)
│   └── mod.rs (contains the declarations in `foo`, including `mod bar`)
</code></pre>
<p>이 모듈들은 부모 모듈의 파일에 <code>mod</code> 키워드를 사용하여 선언되어 있어야 합니다.</p>
<p>다음으로, <code>pub</code> 키워드에 대해 알아보고 앞의 그 경고들을 없애봅시다!</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ch07-00-modules.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch07-02-controlling-visibility-with-pub.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ch07-00-modules.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="ch07-02-controlling-visibility-with-pub.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="store.js"></script>
        <script src="book.js"></script>
    </body>
</html>
