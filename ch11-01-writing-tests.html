<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>테스트 작성하기 - 테스트 작성하기 - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <style>
            .page-wrapper.has-warning > .nav-chapters {
              /* add height for warning content & margin */
              top: 120px;
            }

            p.warning {
                background-color: rgb(242, 222, 222);
                border-bottom-color: rgb(238, 211, 215);
                border-bottom-left-radius: 4px;
                border-bottom-right-radius: 4px;
                border-bottom-style: solid;
                border-bottom-width: 0.666667px;
                border-image-outset: 0 0 0 0;
                border-image-repeat: stretch stretch;
                border-image-slice: 100% 100% 100% 100%;
                border-image-source: none;
                border-image-width: 1 1 1 1;
                border-left-color: rgb(238, 211, 215);
                border-left-style: solid;
                border-left-width: 0.666667px;
                border-right-color: rgb(238, 211, 215);
                border-right-style: solid;
                border-right-width: 0.666667px;
                border-top-color: rgb(238, 211, 215);
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                border-top-style: solid;
                border-top-width: 0.666667px;
                color: rgb(185, 74, 72);
                margin-bottom: 0px;
                margin-left: 0px;
                margin-right: 0px;
                margin-top: 30px;
                padding-bottom: 8px;
                padding-left: 14px;
                padding-right: 35px;
                padding-top: 8px;
            }
            p.warning strong {
                color: rgb(185, 74, 72)
            }
            p.warning a {
                color: rgb(0, 136, 204)
            }
        </style>

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="ch01-00-introduction.html"><strong>1.</strong> Introduction</a></li><li><ul class="section"><li><a href="ch01-01-installation.html"><strong>1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong>1.2.</strong> Hello, World!</a></li></ul></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong>2.</strong> 추리 게임 튜토리얼</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong>3.</strong> 보편적인 프로그래밍 개념</a></li><li><ul class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong>3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong>3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong>3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong>3.5.</strong> Control Flow</a></li></ul></li><li><a href="ch04-00-understanding-ownership.html"><strong>4.</strong> 소유권 이해하기</a></li><li><ul class="section"><li><a href="ch04-01-what-is-ownership.html"><strong>4.1.</strong> 소유권이 뭔가요?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong>4.2.</strong> 참조자와 빌림</a></li><li><a href="ch04-03-slices.html"><strong>4.3.</strong> 슬라이스</a></li></ul></li><li><a href="ch05-00-structs.html"><strong>5.</strong> 연관된 데이터들을 구조체로 다루기</a></li><li><ul class="section"><li><a href="ch05-01-defining-structs.html"><strong>5.1.</strong> 구조체를 정의하고 생성하기</a></li><li><a href="ch05-02-example-structs.html"><strong>5.2.</strong> 구조체를 이용한 예제 프로그램</a></li><li><a href="ch05-03-method-syntax.html"><strong>5.3.</strong> 메소드 문법</a></li></ul></li><li><a href="ch06-00-enums.html"><strong>6.</strong> 열거형과 패턴 매칭</a></li><li><ul class="section"><li><a href="ch06-01-defining-an-enum.html"><strong>6.1.</strong> 열거형 정의하기</a></li><li><a href="ch06-02-match.html"><strong>6.2.</strong> <code>match</code> 흐름 제어 연산자</a></li><li><a href="ch06-03-if-let.html"><strong>6.3.</strong> <code>if let</code>을 사용한 간결한 흐름 제어</a></li></ul></li><li><a href="ch07-00-modules.html"><strong>7.</strong> 모듈</a></li><li><ul class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong>7.1.</strong> <code>mod</code>와 파일 시스템</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong>7.2.</strong> <code>pub</code>으로 가시성 제어하기</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong>7.3.</strong> <code>use</code>로 이름 가져오기</a></li></ul></li><li><a href="ch08-00-common-collections.html"><strong>8.</strong> 일반적인 컬렉션</a></li><li><ul class="section"><li><a href="ch08-01-vectors.html"><strong>8.1.</strong> 벡터</a></li><li><a href="ch08-02-strings.html"><strong>8.2.</strong> 스트링</a></li><li><a href="ch08-03-hash-maps.html"><strong>8.3.</strong> 해쉬맵</a></li></ul></li><li><a href="ch09-00-error-handling.html"><strong>9.</strong> 에러 처리</a></li><li><ul class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong>9.1.</strong> <code>panic!</code>과 함께하는 복구 불가능한 에러</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong>9.2.</strong> <code>Result</code>와 함께하는 복구 가능한 에러</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong>9.3.</strong> <code>panic!</code>이냐, <code>panic!</code>이 아니냐, 그것이 문제로다</a></li></ul></li><li><a href="ch10-00-generics.html"><strong>10.</strong> 제네릭 타입, 트레잇, 그리고 라이프타임</a></li><li><ul class="section"><li><a href="ch10-01-syntax.html"><strong>10.1.</strong> 제네릭 데이터 타입</a></li><li><a href="ch10-02-traits.html"><strong>10.2.</strong> 트레잇: 공유 동작을 정의하기</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong>10.3.</strong> 라이프타임을 이용한 참조자 유효화</a></li></ul></li><li><a href="ch11-00-testing.html"><strong>11.</strong> 테스팅</a></li><li><ul class="section"><li><a href="ch11-01-writing-tests.html" class="active"><strong>11.1.</strong> 테스트 작성하기</a></li><li><a href="ch11-02-running-tests.html"><strong>11.2.</strong> 테스트 실행하기</a></li><li><a href="ch11-03-test-organization.html"><strong>11.3.</strong> 테스트 조직화</a></li></ul></li><li><a href="ch12-00-an-io-project.html"><strong>12.</strong> An I/O Project</a></li><li><ul class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong>12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong>12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong>12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong>12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong>12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong>12.6.</strong> Writing to <code>stderr</code> instead of <code>stdout</code></a></li></ul></li><li><a href="ch13-00-functional-features.html"><strong>13.</strong> Functional Language Features in Rust</a></li><li><ul class="section"><li><a href="ch13-01-closures.html"><strong>13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong>13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong>13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong>13.4.</strong> Performance</a></li></ul></li><li><a href="ch14-00-more-about-cargo.html"><strong>14.</strong> More about Cargo and Crates.io</a></li><li><ul class="section"><li><a href="ch14-01-release-profiles.html"><strong>14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong>14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong>14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong>14.4.</strong> Installing Binaries from Crates.io with <code>cargo install</code></a></li><li><a href="ch14-05-extending-cargo.html"><strong>14.5.</strong> Extending Cargo with Custom Commands</a></li></ul></li><li><a href="ch15-00-smart-pointers.html"><strong>15.</strong> Smart Pointers</a></li><li><ul class="section"><li><a href="ch15-01-box.html"><strong>15.1.</strong> <code>Box&lt;T&gt;</code> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong>15.2.</strong> The <code>Deref</code> Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong>15.3.</strong> The <code>Drop</code> Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong>15.4.</strong> <code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong>15.5.</strong> <code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong>15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ul></li><li><a href="ch16-00-concurrency.html"><strong>16.</strong> Fearless Concurrency</a></li><li><ul class="section"><li><a href="ch16-01-threads.html"><strong>16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong>16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong>16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong>16.4.</strong> Extensible Concurrency: <code>Sync</code> and <code>Send</code></a></li></ul></li><li><a href="ch17-00-oop.html"><strong>17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ul class="section"><li><a href="ch17-01-what-is-oo.html"><strong>17.1.</strong> What Does Object-Oriented Mean?</a></li><li><a href="ch17-02-trait-objects.html"><strong>17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong>17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ul></li><li><a href="ch18-00-patterns.html"><strong>18.</strong> Patterns Match the Structure of Values</a></li><li><ul class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong>18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="ch18-02-refutability.html"><strong>18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong>18.3.</strong> All the Pattern Syntax</a></li></ul></li><li><a href="ch19-00-advanced-features.html"><strong>19.</strong> Advanced Features</a></li><li><ul class="section"><li><a href="ch19-01-unsafe-rust.html"><strong>19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong>19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong>19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html"><strong>19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong>19.5.</strong> Advanced Functions &amp; Closures</a></li></ul></li><li><a href="ch20-00-final-project-a-web-server.html"><strong>20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ul class="section"><li><a href="ch20-01-single-threaded.html"><strong>20.1.</strong> A Single Threaded Web Server</a></li><li><a href="ch20-02-slow-requests.html"><strong>20.2.</strong> How Slow Requests Affect Throughput</a></li><li><a href="ch20-03-designing-the-interface.html"><strong>20.3.</strong> Designing the Thread Pool Interface</a></li><li><a href="ch20-04-storing-threads.html"><strong>20.4.</strong> Creating the Thread Pool and Storing Threads</a></li><li><a href="ch20-05-sending-requests-via-channels.html"><strong>20.5.</strong> Sending Requests to Threads Via Channels</a></li><li><a href="ch20-06-graceful-shutdown-and-cleanup.html"><strong>20.6.</strong> Graceful Shutdown and Cleanup</a></li></ul></li><li><a href="appendix-00.html"><strong>21.</strong> Appendix</a></li><li><ul class="section"><li><a href="appendix-01-keywords.html"><strong>21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong>21.2.</strong> B - Operators</a></li><li><strong>21.3.</strong> C - Derivable Traits</li><li><strong>21.4.</strong> D - Nightly Rust</li><li><strong>21.5.</strong> E - Macros</li><li><strong>21.6.</strong> F - Translations</li><li><a href="appendix-07-newest-features.html"><strong>21.7.</strong> G - Newest Features</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper has-warning">

            <div class="page">
                <header><p class="warning">You are reading a <strong>draft</strong> of the next edition of TRPL. For more, go <a href="../index.html">here</a>.</p></header>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">테스트 작성하기 - The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>


                <div id="content" class="content">
                    <a class="header" href="ch11-01-writing-tests.html#테스트를-작성하는-방법" id="테스트를-작성하는-방법"><h2>테스트를 작성하는 방법</h2></a>
<p>테스트는 테스트 아닌 코드가 프로그램 내에서 기대했던 대로 기능을 하는지 검증하는 러스트
함수입니다. 테스트 함수의 본체는 통상적으로 셋업, 우리가 테스트하고 싶은 코드의 실행,
그런 다음 그 결과가 우리 예상대로인지 확고히 하는(assert) 단계를 담고 있습니다. 테스트
작성을 위해 러스트가 특별히 제공하는 기능들을 살펴봅시다: <code>test</code> 속성, 몇 가지 매크로,
그리고 <code>should_panic</code> 속성들을 말이죠.</p>
<a class="header" href="ch11-01-writing-tests.html#테스트-함수의-해부" id="테스트-함수의-해부"><h3>테스트 함수의 해부</h3></a>
<p>가장 단순하게 말하면, 러스트 내의 테스트란 <code>test</code> 속성(attribute)이 주석으로 달려진
(annotated) 함수입니다. 속성은 러스트 코드 조각에 대한 메타데이터입니다: 5장에서
우리가 구조체와 함께 사용했던 <code>derive</code> 속성이 한가지 예입니다. 함수를 테스트 함수로
만들기 위해서는, <code>fn</code> 전 라인에 <code>#[test]</code>를 추가합니다. <code>cargo test</code> 커맨드를
사용하여 테스트를 실행시키면, 러스트는 <code>test</code> 속성이 달려있는 함수들을 실행하고
각 테스트 함수가 성공 혹은 실패했는지를 보고하는 테스트 실행용 바이너리를 빌드할
것입니다.</p>
<!-- is it annotated with `test` by the user, or only automatically? I think
it's the latter, and has edited with a more active tone to make that clear, but
please change if I'm wrong -->
<!-- What do you mean by "only automatically"? The reader should be typing in
`#[test] on their own when they add new test functions; there's nothing special
about that text. I'm not sure what part of this chapter implied "only
automatically", can you point out where that's happening if we haven't taken
care of it? /Carol -->
<p>7장에서 여러분이 카고를 통해 새로운 라이브러리 프로젝트를 만들었을 때, 테스트 함수를
갖고 있는 테스트 모듈이 자동으로 생성되는 것을 보았습니다. 이는 우리의 테스트를 작성하기
시작하도록 돕기 위한 것인데, 이렇게 하면 우리가 새로운 프로젝트를 시작할 때마다
매번 테스트 함수를 위한 추가적인 구조 및 문법을 찾아보지 않아도 되기 때문입니다.
하지만, 우리는 원하는만큼 추가적인 테스트 함수들과 테스트 모듈들을 추가할 수 있습니다!</p>
<p>우리는 실제 코드를 테스팅하지는 않으면서 자동으로 만들어진 템플릿 테스트를 가지고
실험하는 식으로 테스트가 어떻게 동작하는지를 몇가지 관점에서 탐구할 것입니다.
그리고나서 우리가 작성한 몇몇 코드를 호출하고 동작이 정확한지를 확고히하는
실제의 테스트를 작성해 볼 것입니다.</p>
<p><code>adder</code>라고 하는 새로운 라이브러리 프로젝트를 만듭시다:</p>
<pre><code class="language-text">$ cargo new adder
     Created library `adder` project
$ cd adder
</code></pre>
<p>여러분의 adder 라이브러리 내에 있는 <code>src/lib.rs</code> 파일의 내용물은 아래와 같아야
합니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-1: <code>cargo new</code>를 이용하여 자동으로 생성된
테스트 모듈과 함수 </span></p>
<p>지금은 제일 위의 두 줄은 무시하고 함수가 어떻게 작동하는지 알아보는데 집중합시다.
<code>fn</code> 라인 전의 <code>#[test]</code> 어노테이션을 주목하세요: 이 속성이 바로 이것이 테스트 함수임을
나타내므로, 테스트 실행기는 이 함수를 테스트로 다루어야 한다는 것을 알게 됩니다.
또한 우리는 <code>tests</code> 모듈 내에 일반적인 시나리오를 셋업하거나 일반적인 연산을 수행하는
것을 돕기 위한 테스트 아닌 함수를 넣을 수 있으므로, 어떤 함수가 테스트 함수인지
<code>#[test]</code>를 가지고 표시할 필요가 있습니다.</p>
<p>이 함수는 현재 본체가 없는데, 이는 테스트에 실패할 코드가 없다는 의미입니다;
빈 테스트는 통과하는 테스트입니다! 이걸 실행하여 이 테스트가 통과하는지 봅시다.</p>
<p><code>cargo test</code> 커맨드는 Listing 11-2에서 보는 바와 같이 우리 프로젝트에 있는
모든 테스트를 실행합니다:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.22 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p><span class="caption">Listing 11-2: 자동으로 생성된 테스트를 실행한 결과 </span></p>
<p>카고는 우리의 테스트를 컴파일하고 실행했습니다. <code>Compiling</code>, <code>Finished</code>, 그리고
<code>Running</code> 라인 이후에, <code>running 1 test</code> 라인을 보게 됩니다. 그 다음 라인에는
생성된 테스트 함수의 이름인 <code>it_works</code>가 나타나고, 테스트의 실행 결과 <code>ok</code>가
나타납니다. 그리고나서 테스트 실행의 전체 요약을 보게 됩니다:
<code>test result: ok.</code>는 모든 테스트가 통과했다는 뜻입니다. <code>1 passed; 0 failed</code>는
통과하거나 실패한 테스트의 개수를 추가적으로 보여줍니다.</p>
<p>우리가 무시하라고 표시한 테스트가 없으므로, 요약문에 <code>0 ignored</code>라고 표시됩니다.
테스트를 실행하는 다른 방법에 대하여 다루는 다음 절에서 테스트를 무시하는 것에 대해
다룰 것입니다. <code>0 measured</code> 통계는 성능을 측정하는 벤치마크 테스트를 위한 것입니다.
벤치마크 테스트는 이 글이 쓰여진 시점에서는 오직 나이틀리(nightly) 러스트에서만 사용
가능합니다. 나이틀리 러스트에 대한 정보는 부록 D에 나와있습니다.</p>
<p><code>Doc-tests adder</code>로 시작하는 테스트 출력의 다음 부분은 문서 테스트의 결과를 보여주기
위한 것입니다. 아직 어떠한 문서 테스트도 없긴 하지만, 러스트는 우리의 API 문서 내에
나타난 어떠한 코드 예제라도 컴파일 할 수 있습니다. 이 기능은 우리의 문서와 코드가
동기화를 유지하도록 돕습니다! 우리는 14장의 &quot;문서 주석&quot;절 에서 문서 테스트를 작성하는
방법에 대해 이야기할 것입니다. 지금은 <code>Doc-tests</code> 출력을 무시할 것입니다.</p>
<!-- I might suggest changing the name of the function, could be misconstrued
as part of the test output! -->
<!-- `it_works` is always the name that `cargo new` generates for the first
test function, though. We wanted to show the reader what happens when you run
the tests immediately after generating a new project; they pass without you
needing to change anything. I've added a bit to walk through changing the
function name and seeing how the output changes; I hope that's sufficient.
/Carol -->
<p>우리의 테스트의 이름을 변경하고 테스트 출력이 어떻게 변하는지를 살펴봅시다.
다음과 같이 <code>it_works</code> 함수의 이름을 <code>exploration</code>으로 변경하세요:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
    }
}
#}</code></pre></pre>
<p>그리고 <code>cargo test</code>를 다시 실행시킵니다. 이제 출력 부분에서 <code>it_works</code> 대신
<code>exploration</code>을 볼 수 있을 것입니다:</p>
<pre><code class="language-text">running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>다른 테스트를 추가해봅시다. 하지만 이번에는 실패하는 테스트를 만들 것입니다! 테스트
함수 내의 무언가가 패닉을 일으키면 테스트는 실패합니다. 9장에서 패닉을 유발하는
가장 단순한 방법에 대해 이야기했었습니다: 바로 <code>panic!</code> 매크로를 호출하는 것이죠!
새로운 테스트를 입력하여 여러분의 <code>src/lib.rs</code>가 Listing 11-3과 같은 모양이
되게 해보세요:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
    }

    #[test]
    fn another() {
        panic!(&quot;Make this test fail&quot;);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-3: 두번째 테스트 추가; <code>panic!</code> 매크로를
호출하기 떄문에 실패할 테스트 </span></p>
<p>그리고 <code>cargo test</code>를 이용하여 다시 한번 테스트를 실행시키세요. 결과 출력은
Listing 11-4와 같이 나올 것인데, 이는 <code>exploration</code> 테스트는 통과하고 <code>another</code>는
실패했음을 보여줍니다:</p>
<pre><code class="language-text">running 2 tests
test tests::exploration ... ok
test tests::another ... FAILED

failures:

---- tests::another stdout ----
    thread 'tests::another' panicked at 'Make this test fail', src/lib.rs:9
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured

error: test failed
</code></pre>
<p><span class="caption">Listing 11-4: 한 테스트는 통과하고 다른 한 테스트는
실패할 때의 테스트 결과 </span></p>
<p><code>test tests::another</code> 라인은 <code>ok</code> 대신 <code>FAILED</code>이라 말해줍니다. 우리는 개별 결과
부분과 요약 부분 사이에 새로운 두개의 섹션을 보게 됩니다: 첫번째 섹션은 테스트 실패에
대한 구체적인 이유를 표시합니다. 이 경우, <code>another</code>는 <code>panicked at 'Make this test fail'</code>
때문에 실패했는데, 이는 <em>src/lib.rs</em>의 9번 라인에서 발생했습니다. 다음 섹션은
실패한 모든 테스트의 이름만 목록화한 것인데, 이는 테스트들이 많이 있고 구체적인 테스트
실패 출력이 많을 때 유용합니다. 실패하는 테스트의 이름은 이를 더 쉽게 디버깅하기 위해서
해당 테스트만을 실행시키는데 사용될 수 있습니다; 다음 절에서 테스트를 실행시키는 방법에
대한 더 많은 내용을 이야기할 것입니다.</p>
<p>마지막으로, 요약 라인입니다: 전체적으로, 우리의 테스트 결과는 <code>FAILED</code>입니다.
우리는 1개의 테스트에 통과했고 1개의 테스트에 실패했습니다.</p>
<p>이제 서로 다른 시나리오에서 테스트 결과가 어떻게 보이는지를 알았으니,
<code>panic!</code> 외에 테스트 내에서 유용하게 쓰일 수 있는 몇가지 매크로를 봅시다.</p>
<a class="header" href="ch11-01-writing-tests.html#assert-매크로를-이용하여-결과-확인하기" id="assert-매크로를-이용하여-결과-확인하기"><h3><code>assert!</code> 매크로를 이용하여 결과 확인하기</h3></a>
<p>표준 라이브러리에서 제공하는 <code>assert!</code> 매크로는 여러분이 테스트이 어떤 조건이 <code>true</code>임을 보장하기를
원하는 경우 유용합니다. <code>assert!</code> 매크로에는 부울린 타입으로 계산되는 인자가 제공됩니다. 만일 값이
<code>true</code>라면 <code>assert!</code>는 아무일도 하지 않고 테스트는 통과됩니다. 만일 값이 <code>false</code>라면, <code>assert!</code>는
<code>panic!</code> 매크로를 호출하는데, 이것이 테스트를 실패하게 합니다. 이는 우리의 코드가 우리 의도대로
기능하고 있는지를 체크하는 것을 도와주는 매크로 중 하나입니다.</p>
<!-- what kind of thing can be passed as an argument? Presumably when we use it
for real we won't pass it `true` or `false` as an argument, but some condition
that will evaluate to true or false? In which case, should below be phrased "If
the argument evaluates to true" and an explanation of that? Or maybe even a
working example would be better, this could be misleading -->
<!-- We were trying to really break it down, to show just how the `assert!`
macro works and what it looks like for it to pass or fail, before we got into
calling actual code. We've changed this section to move a bit faster and just
write actual tests instead. /Carol -->
<p>5장에 있는 Listing 5-9에 대한 기억을 완전히 떠올리시면, 거기서 <code>Rectangle</code> 구조체와 <code>can_hold</code>
메소드를 다루었는데 여기 Listing 11-5에 다시 등장했습니다. 이 코드를 <em>src/main.rs</em> 대신
<em>src/lib.rs</em>에 넣고, <code>assert!</code> 매크로를 사용하여 테스트를 작성해봅시다.</p>
<!-- Listing 5-9 wasn't marked as such; I'll fix it the next time I get Chapter
5 for editing. /Carol -->
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
pub struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &gt; other.length &amp;&amp; self.width &gt; other.width
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-5: 5장의 <code>Rectangle</code> 구조체와 <code>can_hold</code> 메소드
</span></p>
<p><code>can_hold</code> 메소드는 부울린 값을 반환하는데, 이는 <code>assert!</code> 매크로를 위한 완벽한 사용 사례라는
의미입니다! Listing 11-6에서, 길이 8에 너비 7인 <code>Rectangle</code> 인스턴스를 만들고, 이것이
길이 5에 너비 1인 다른 <code>Rectangle</code> 인스턴스를 포함할 수 있는지 단언(assert)해보는 것으로
<code>can_hold</code> 메소드를 시험하는 테스트를 작성해봅시다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(larger.can_hold(&amp;smaller));
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-6: 큰 사각형이 작은 사각형을 정말로 담을 수 있는지 검사하는
<code>can_hold</code>를 위한 테스트 </span></p>
<p><code>tests</code> 모듈 내에 새로운 라인이 추가된 것을 주목하세요: <code>use super::*;</code>. <code>tests</code> 모듈은
우리가 7장에서 다루었던 보통의 가시성 규칙을 따르는 일반적인 모듈입니다. 우리가 내부 모듈 내에 있기
때문에, 외부 모듈에 있는 코드를 내부 모듈의 스코프로 가져올 필요가 있습니다. 여기서는 글롭(<code>*</code>)을
사용하기로 선택했고 따라서 우리가 외부 모듈에 정의한 어떠한 것이듯 이 <code>tests</code>모듈에서 사용 가능합니다.</p>
<p>우리의 테스트는 <code>larger_can_hold_smaller</code>로 명명되었고, 요구된 바와 같이 <code>Rectangle</code>
인스턴스를 두 개 생성했습니다. 그 뒤 <code>assert!</code> 매크로를 호출하고 <code>larger.can_hold(&amp;smaller)</code>
호출의 결과값을 인자로서 넘겼습니다. 이 표현식은 <code>true</code>를 반환할 예정이므로, 우리의 테스트는
통과해야 합니다. 자, 이제 알아봅시다!</p>
<pre><code class="language-text">running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>통과되었군요! 이번에는 작은 사각형이 큰 사각형을 포함시킬수 없음을 단언하는 또다른 테스트를
추가합시다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(larger.can_hold(&amp;smaller));
    }

    #[test]
    fn smaller_can_not_hold_larger() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
#}</code></pre></pre>
<p>이 경우 <code>can_hold</code> 함수의 올바른 결과값은 <code>false</code>이므로, <code>assert!</code> 매크로에게 넘기기 전에
이 결과를 반대로 만들 필요가 있습니다. 이러한 방식으로, 우리의 테스트는 <code>can_hold</code>가 <code>false</code>를
반환할 경우에만 통과할 것입니다:</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_can_not_hold_larger ... ok
test tests::larger_can_hold_smaller ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>통과하는 테스트가 두개가 되었습니다! 이제는 만약 우리의 코드에 버그가 있다면 테스트 결과가 어찌되는지
봅시다. <code>can_hold</code> 메소드의 구현 부분 중 큰(&gt;) 부등호를 이용해 길이를 비교하는 부분을 작은(&lt;)
부등호로 바꿔봅시다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
pub struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &lt; other.length &amp;&amp; self.width &gt; other.width
    }
}
#}</code></pre></pre>
<p>테스트를 실행시키면 이제 아래와 같이 출력됩니다:</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_can_not_hold_larger ... ok
test tests::larger_can_hold_smaller ... FAILED

failures:

---- tests::larger_can_hold_smaller stdout ----
    thread 'tests::larger_can_hold_smaller' panicked at 'assertion failed:
    larger.can_hold(&amp;smaller)', src/lib.rs:22
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>우리의 테스트가 버그를 찾았습니다! <code>larger.length</code>는 8이고 <code>smaller.length</code>는 5이므로,
<code>can_hold</code>의 길이 부분에 대한 비교값은 이제 <code>false</code>를 반환하는데, 이는 8이 5보다 작지 않기
때문입니다.</p>
<a class="header" href="ch11-01-writing-tests.html#aseert_eq와-assert_ne를-이용한-동치equality-테스트" id="aseert_eq와-assert_ne를-이용한-동치equality-테스트"><h3><code>aseert_eq!</code>와 <code>assert_ne!</code>를 이용한 동치(equality) 테스트</h3></a>
<p>기능성을 테스트하는 일반적인 방법은 테스트 내의 코드의 결과값과 우리가 기대하는 값을 얻어서 이 둘이
서로 같은지를 비교하는 것입니다. 이를 <code>assert!</code> 매크로에 <code>==</code>를 이용한 표현식을 넘기는 식으로
할 수도 있습니다. 그러나 이러한 테스트를 더 편리하게 수행해주는 표준 라이브러리가 제공하는 한 쌍의
매크로가 있습니다: <code>assert_eq!</code>와 <code>assert_ne!</code>입니다. 이 매크로들은 각각 동치(equality)와
부동(inequality)을 위해 두 인자를 비교합니다. 또한 이들은 만일 단언에 실패한다면 두 값을 출력해
줄 것이므로, <em>왜</em> 테스트가 실패했는지를 포기 더 쉬워지는데, 반면 <code>assert!</code>는 <code>==</code> 표현식에 대해
<code>false</code> 값을 얻었음을 알려줄 뿐, 어떤 값이 <code>false</code>값을 야기했는지는 알려주지 않습니다.</p>
<p>Listing 11-7와 같이, 파라미터에 2를 더하여 결과를 반환하는 <code>add_two</code> 함수를 작성합시다. 그 후
<code>assert_eq!</code> 매크로를 이용하여 이 함수를 테스트합시다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-7: <code>assert_eq!</code> 매크로를 이용하는 <code>add_two</code> 함수 테스트
</span></p>
<p>이게 통과하는지 확인해 봅시다!</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p><code>assert_eq!</code> 매크로에 제공한 첫번째 인자 4는 <code>add_two(2)</code> 호출의 결과와 동일합니다.
이 테스트가 <code>test tests::it_adds_two ... ok</code>라고 하는 줄을 보았고, <code>ok</code> 문자열은 테스트가
통과했음을 나타냅니다!</p>
<p><code>assert_eq!</code>를 이용하는 테스트가 실패했을때는 어떻게 보이는지를 알아보기 위해 테스트에 버그를 집어넣어
봅시다. <code>add_two</code> 함수에 3을 대신 더하는 형태로 구현을 변경해보세요:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
#}</code></pre></pre>
<p>그리고 테스트를 다시 실행해보시요:</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
    thread 'tests::it_adds_two' panicked at 'assertion failed: `(left ==
    right)` (left: `4`, right: `5`)', src/lib.rs:11
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>우리의 테스트가 버그를 잡았어요! <code>it_adds_two</code> 테스트는
<code>assertion failed: `(left == right)` (left: `4`, right: `5`)</code>라는 메세지와 함께
실패했습니다. 이 메세지는 우리가 디버깅을 시작하는데 유용한 도움을 줍니다: <code>assert_eq!</code>의 <code>left</code>
인자는 4였는데, <code>add_two(2)</code>를 넣은 right` 인자는 5라고 말해주고 있습니다.</p>
<p>몇몇 언어와 테스트 프레임워크 내에서는, 두 값이 같은지를 단언하는 함수의 파라미터를 <code>expected</code>와
<code>actual</code>로 부르며 우리가 인자를 넣는 순서가 중요하다는 점을 기억하세요. 하지만 러스트에서는
그대신 <code>left</code>와 <code>right</code>라고 불리우며 우리가 기대한 값과 테스트 내의 코드가 생성하는 값을
지정하는 순서는 중요치 않습니다. 이 테스트의 단언을 <code>assert_eq!(add_two(2), 4)</code>로 작성할
수도 있는데, 이는 <code>assertion failed: `(left == right)` (left: `5`, right: `4`)</code>
와 같은 실패 메세지를 만들어낼 것입니다.</p>
<p><code>assert_ne!</code> 매크로는 우리가 제공한 두 개의 값이 서로 갖지 않으면 통과하고 동일하면 실패할 것입니다.
이 매크로는 어떤 값이 <em>될 것인지</em>는 정확히 확신하지 못하지만, 어떤 값이라면 절대로 <em>될 수 없는지</em>는
알고 있을 경우에 가장 유용합니다. 예를 들면, 만일 어떤 함수가 입력값을 어떤 방식으로든 변경한다는 것을
보장하지만, 그 입력값이 우리가 테스트를 실행한 요일에 따라 달라지는 형태라면, 단언을 하는 가장 좋은
방법은 함수의 결과값이 입력값과 같지 않다는 것일지도 모릅니다.</p>
<p>표면 아래에서, <code>assert_eq!</code>와 <code>assert_ne!</code> 매크로는 각각 <code>==</code>과 <code>!=</code> 연산자를 이용합니다.
단언에 실패하면, 이 매크로들은 디버그 포맷팅을 사용하여 인자들을 출력하는데, 이는 비교되는 값들이
<code>PartialEq</code>와 <code>Debug</code> 트레잇을 구현해야 한다는 의미입니다. 모든 기본 타입과 표준 라이브러리가
제공하는 대부분의 타입들은 이 트레잇들을 구현하고 있습니다. 여러분이 정의한 구조체나 열거형에 대해서,
단언에 실패할 경우에 값을 출력하기 위해서는 <code>Debug</code>를 구현해야 합니다. 5장에서 설명한 바와 같이
두 트레잇 모두 추론 가능한(derivable) 트레잇이기 때문에, 이 트레잇의 구현은 보통
<code>#[derive(PartialEq, Debug)]</code> 어노테이션을 여러분의 구조체나 열거형 정의부에 추가하는 정도로
간단합니다. 이에 대한 것과 다른 추론 가능한 트레잇에 대한 더 자세한 내용은 부록 C를 참고하세요.</p>
<a class="header" href="ch11-01-writing-tests.html#custom-failure-messages-커스텀-실패-메세지" id="custom-failure-messages-커스텀-실패-메세지"><h3>Custom Failure Messages 커스텀 실패 메세지</h3></a>
<p>또한 우리는 <code>assert!</code>, <code>assert_eq!</code> 및 <code>assert_ne!</code>의 추가 인자로서 커스텀 메세지를 입력하여
실패 메세지와 함께 출력되도록 할 수 있습니다. <code>assert!</code>가 요구하는 하나의 인자 후에 지정된 인자들이나
<code>assert_eq!</code>와 <code>assert_ne!</code>가 요구하는 두개의 인자 후에 지정된 인자들은 우리가 8장에서 다루었던
<code>format!</code> 매크로에 넘겨지므로, 여러분은 <code>{}</code> 변경자(placeholder)를 갖는 포맷 스트링과 이 변경자에
입력될 값들을 넘길 수 있습니다. 커스텀 메세지는 해당 단언의 의미를 문서화하기 위한 용도로서 유용하므로,
테스트가 실패했을 때, 코드에 어떤 문제가 있는지에 대해 더 좋은 생각을 가질 수 있습니다.</p>
<p>예를 들어, 이름을 부르며 사람들을 환영하는 함수가 있고, 이 함수에 넘겨주는 이름이 출력 내에 있는지
테스트하고 싶다고 칩시다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}
#}</code></pre></pre>
<p>여기서 이 프로그램의 요구사항은 아직 합의되지 않았고, 인삿말의 시작지점에 있는 <code>Hello</code> 텍스트가
변경될 것이라는 점이 꽤나 확실한 상태라고 칩시다. 우리는 그런 변경사항이 생기더라도 이름에 대한 테스트를
갱신할 필요는 없다고 결정했고, 따라서 <code>greeting</code> 함수로부터 반환된 값과 정확히 일치하는 체크 대신,
출력값이 입력 파라미터의 텍스트를 포함하고 있는지만 단언할 것입니다.</p>
<p><code>greeting</code>이 <code>name</code>을 포함하지 않도록 변경하는 것으로 버그를 집어넣어 테스트 실패가 어떻게 보이는지
살펴봅시다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}
#}</code></pre></pre>
<p>Running this test produces:</p>
<pre><code class="language-text">running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
    thread 'tests::greeting_contains_name' panicked at 'assertion failed:
    result.contains(&quot;Carol&quot;)', src/lib.rs:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::greeting_contains_name
</code></pre>
<p>이 메세지는 그저 단언이 실패했으며 몇번째 줄의 단언이 실패했는지만을 알려주고 있습니다. 이 경우에서
더 유용한 실패 메세지는 <code>greeting</code> 함수로부터 얻은 값을 출력하는 것일테지요. 테스트 함수를 바꿔서
<code>greeting</code> 함수로부터 얻은 실제 값으로 채워질 변경자를 이용한 포맷 스트링으로부터 만들어지는 커스텀
실패 메세지를 갖도록 해봅시다:</p>
<pre><code class="language-rust ignore">#[test]
fn greeting_contains_name() {
    let result = greeting(&quot;Carol&quot;);
    assert!(
        result.contains(&quot;Carol&quot;),
        &quot;Greeting did not contain name, value was `{}`&quot;, result
    );
}
</code></pre>
<p>이제 테스트를 다시 실행시키면, 더 많은 정보를 가진 에러메세지를 얻을 것입니다:</p>
<pre><code class="language-text">---- tests::greeting_contains_name stdout ----
    thread 'tests::greeting_contains_name' panicked at 'Greeting did not contain
    name, value was `Hello`', src/lib.rs:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>이제 실제로 테스트 출력에서 얻어진 값을 볼 수 있고, 이는 우리가 기대했던 일 대신 실제 어떤 일이
일어났는지 디버깅하는데 도움을 줄 것입니다.</p>
<a class="header" href="ch11-01-writing-tests.html#should_panic을-이용한-패닉에-대한-체크" id="should_panic을-이용한-패닉에-대한-체크"><h3><code>should_panic</code>을 이용한 패닉에 대한 체크</h3></a>
<p>우리의 코드가 우리가 기대한 정확한 값을 반환하는 것을 체크하는 것에 더하여, 우리의 코드가
우리가 기대한대로 에러가 나는 경우를 처리할 수 있는지 체크하는 것 또한 중요합니다. 예를 들어,
9장의 Listing 9-8에서 우리가 만들었던 <code>Guess</code> 타입을 떠올려보세요. <code>Guess</code>를 이용하는
다른 코드는 <code>Guess</code> 인스턴스가 1과 100 사이의 값만 가질 것이라는 보장에 의존하고 있습니다.
우리는 범위 밖의 값으로 <code>Guess</code> 인스턴스를 만드는 시도가 패닉을 일으킨다는 것을 확실히하는
테스트를 작성할 수 있습니다.</p>
<p>이는 또다른 속성인 <code>should_panic</code>를 테스트 함수에 추가함으로써 할 수 있습니다. 이 속성은
함수 내의 코드가 패닉을 일으키면 테스트가 통과하도록 만들어주며, 함수 내의 코드가 패닉을 일으키지
않는다면 테스트는 실패할 것입니다.</p>
<p>Listing 11-8은 <code>Guess::new</code>의 에러 조건이 우리 예상대로 발동되는지를 검사하는 테스트를
작성하는 방법을 보여줍니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-8: 어떤 조건이 <code>panic!</code>을 일으키는지에 대한 테스트
</span></p>
<p><code>#[should_panic]</code> 속성이 <code>#[test]</code> 속성 뒤, 그리고 적용될 테스트 함수 앞에 붙었습니다.
이 테스트가 통과될 때는 어떻게 보이는지 봅시다:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>좋아 보이는군요! 이제 <code>new</code> 함수가 100 이상의 값일때 패닉을 발생시키는 조건을 제거함으로써 코드에
버그를 넣어봅시다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Guess {
#     value: u32,
# }
#
impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1  {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}
#}</code></pre></pre>
<p>Listing 11-8의 테스트를 실행시키면, 아래와 같이 실패할 것입니다:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>이 경우에는 그다지 쓸모있는 메세지를 얻지 못하지만, 한번 테스트 함수를 살펴보게 되면,
함수가 <code>#[should_panic]</code>으로 어노테이션 되었다는 것을 볼 수 있습니다. 우리가 얻은 실패는
함수 내의 코드 <code>Guess::new(200)</code>가 패닉을 일으키지 않았다는 의미가 됩니다.</p>
<p>하지만 <code>should_panic</code> 테스트는 애매할 수 있는데, 그 이유는 이 속성이 단지 코드에서 어떤 패닉이
유발되었음만을 알려줄 뿐이기 때문입니다. <code>should_panic</code> 테스트는 일어날 것으로 예상한 것 외의
다른 이유로 인한 패닉이 일어날 지라도 통과할 것입니다. <code>should_panic</code> 테스트를 더 엄밀하게 만들기
위해서, <code>should_panic</code> 속성에 <code>expected</code> 파라미터를 추가할 수 있습니다. 이 테스트 도구는
실패 메세지가 제공된 텍스트를 담고 있는지 확실히 할 것입니다. 예를 들면, Listing 11-9와 같이
입력된 값이 너무 작거나 혹은 너무 클 경우에 대해 서로 다른 메세지를 가진 패닉을 일으키는 <code>new</code> 함수를
갖고 있는 수정된 <code>Guess</code> 코드를 고려해봅시다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                   value);
        } else if value &gt; 100 {
            panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;,
                   value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-9: 어떤 조건이 특정 패닉 메세지를 가진 <code>panic!</code>을
일으키는 테스트 </span></p>
<p>이 테스트는 통과할 것인데, 그 이유는 <code>should_panic</code> 속성에 추가한 <code>expected</code> 파라미터 값이
<code>Guess::new</code> 함수가 패닉을 일으킬 때의 메세지의 서브스트링이기 때문입니다. 우리가 예상하는
전체 패닉 메세지로 특정할 수도 있는데, 그러한 경우에는 <code>Guess value must be less than or equal to 100, got 200.</code>이 되겠지요. 이는 패닉 메세지가 얼마나 유일한지 혹은
유동적인지, 그리고 여러분의 테스트가 얼마나 정확하기를 원하는지에 따라서 달라집니다. 위의 경우,
패닉 메세지의 서브스트링은 실행된 함수의 코드가 <code>else if value &gt; 100</code> 경우에 해당함을
확신하기에 충분합니다.</p>
<p><code>expect</code> 메세지를 가진 <code>should_panic</code> 테스트가 실패하면 어떻게 되는지 보기 위해서, 다시 한번
<code>if value &lt; 1</code> 아래 코드 블록과 <code>else if value &gt; 100</code> 아래 코드 블록을 바꿔서 버그를
만들어봅시다:</p>
<pre><code class="language-rust ignore">if value &lt; 1 {
    panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;, value);
} else if value &gt; 100 {
    panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;, value);
}
</code></pre>
<p>이번에는 <code>should_panic</code> 테스트를 실행하면, 아래와 같이 실패합니다:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
    thread 'tests::greater_than_100' panicked at 'Guess value must be greater
    than or equal to 1, got 200.', src/lib.rs:10
note: Run with `RUST_BACKTRACE=1` for a backtrace.
note: Panic did not include expected string 'Guess value must be less than or
equal to 100'

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>실패 메세지는 이 테스트가 우리 예상에 맞게 실제로 패닉에 빠지기는 했으나, 패닉 메세지가 예상하는
스트링을 포함하지 않고있다고 말하고 있습니다 (<code>did not include expected string 'Guess value must be less than or equal to 100'</code>.) 우리가 얻어낸 패닉 메세지를 볼 수 이는데,
이 경우에는 <code>Guess value must be greater than or equal to 1, got 200.</code> 이었습니다.
그러면 우리는 어디에 우리의 버그가 있었는지를 찾아내기 시작할 수 있습니다!</p>
<p>이제까지 테스트를 작성하는 방법을 조사했으니, 우리의 테스트를 실행할 때 어떤 일이 벌어지는지를
살펴보고 <code>cargo test</code>와 함꼐 사용할 수 있는 어려가지 옵션들에 대해서 이야기해 봅시다.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ch11-00-testing.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch11-02-running-tests.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ch11-00-testing.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="ch11-02-running-tests.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="store.js"></script>
        <script src="book.js"></script>
    </body>
</html>
