<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>모듈성과 에러처리의 향상을 위한 리팩토링 - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="foreword.html">들어가기 앞서</a></li><li class="affix"><a href="ch00-00-introduction.html">소개</a></li><li><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 시작하기</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 설치하기</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 추리 게임 튜토리얼</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 보편적인 프로그래밍 개념</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 소유권 이해하기</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 소유권이 뭔가요?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 참조자와 빌림</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 슬라이스</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 연관된 데이터들을 구조체로 다루기</a></li><li><ol class="section"><li><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 구조체를 정의하고 생성하기</a></li><li><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 구조체를 이용한 예제 프로그램</a></li><li><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 메소드 문법</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 열거형과 패턴 매칭</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 열거형 정의하기</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 흐름 제어 연산자</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let을 사용한 간결한 흐름 제어</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> 모듈</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod와 파일 시스템</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> pub으로 가시성 제어하기</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> use로 이름 가져오기</a></li></ol></li><li><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 일반적인 컬렉션</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 벡터</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 스트링</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 해쉬맵</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 에러 처리</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!과 함께하는 복구 불가능한 에러</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result와 함께하는 복구 가능한 에러</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!이냐, panic!이 아니냐, 그것이 문제로다</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 제네릭 타입, 트레잇, 그리고 라이프타임</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 제네릭 데이터 타입</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 트레잇: 공유 동작을 정의하기</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 라이프타임을 이용한 참조자 유효화</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 테스팅</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 테스트 작성하기</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 테스트 실행하기</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 테스트 조직화</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O 프로젝트: 커맨드 라인 프로그램 만들기</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> 커맨드 라인 인자 허용하기</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> 파일 읽기</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html" class="active"><strong aria-hidden="true">12.3.</strong> 모듈성과 에러처리의 향상을 위한 리팩토링</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> 테스트 주도 개발로 라이브러리의 기능 개발하기</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 환경 변수들을 활용하기</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 표준출력 대신 표준에러로 에러메시지 출력하기</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 함수형 언어의 특성들: 반복자들과 클로저들</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> 클로저: 환경을 캡쳐할 수 있는 익명 함수</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 반복자로 일련의 항목들 처리하기</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O 프로젝트 개선하기</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> 성능 비교하기: 루프 vs. 반복자</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 스마트 포인터</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box<T>는 힙에 있는 데이터를 가리키고 알려진 크기를 갖습니다</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref 트레잇은 참조자를 통하여 데이터로의 접근을 허용합니다</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop 트레잇은 메모리 정리 코드를 실행시킵니다</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T>, 참조 카운팅 스마트 포인터</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T>와 내부 가변성 패턴</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 순환 참조를 만드는 것과 메모리 누수는 안전한 것에 해당됩니다</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency: Sync and Send</a></li></ol></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects that Allow for Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 값의 구조와 매칭되는 패턴</a></li><li><ol class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 패턴이 사용될 수 있는 모든 곳</a></li><li><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 반증 가능성: 패턴의 매칭이 실패할 수도 있는 경우</a></li><li><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> All the Pattern Syntax</a></li></ol></li><li><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Advanced Functions &amp; Closures</a></li></ol></li><li><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 마지막 프로젝트: 멀티스레드 웹서버 만들기</a></li><li><ol class="section"><li><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> 싱글 스레드 웹서버</a></li><li><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> 싱글 스레드 서버를 멀티스레드 서버로 바꾸기</a></li><li><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - Macros</a></li><li><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - Translations</a></li><li><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - Newest Features</a></li><li><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Rust Programming Language</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch12-03-improving-error-handling-and-modularity.html#a모듈성과-에러처리의-향상을-위한-리팩토링" id="a모듈성과-에러처리의-향상을-위한-리팩토링"><h2>모듈성과 에러처리의 향상을 위한 리팩토링</h2></a>
<p>우리 프로그램을 향상시키기 위해 네 가지 수정하고 싶은 문제가 있는데, 이들은 프로그램을
구조화하고 발생가능한 에러를 처리하는 방식과 관련있습니다.</p>
<p>첫 번째, 우리 <code>main</code> 함수는 현재 두 가지 작업을 수행합니다: 인자들을 분석하고 파일을
열지요. 이런 작은 함수에서, 이건 큰 문제가 안됩니다. 하지만 우리가 계속해서 <code>main</code>함수
안에 프로그램을 작성하여 커지게 되면, <code>main</code> 함수가 처리하는 작업의 수도 늘어나게 될
겁니다. 함수가 갖게되는 책임들만큼, 근원을 파악하기도, 테스트 하기에도, 부분 별로 나누지
않고는 수정하기도 어려워 집니다. 함수는 나뉘어 하나의 작업에 대해서만 책임을 지는 것이 더
좋은 구조입니다.</p>
<p>이 문제는 우리의 두 번째 문제와도 관련이 있습니다: <code>query</code> 와 <code>filename</code> 은<br />
프로그램의 설정을 저장하는 변수이고 <code>f</code> 와 <code>contents</code> 같은 변수는 프로그램의 논리
수행에 사용됩니다. <code>main</code>이 길어질수록 범위 내에 더 많은 변수 생깁니다. 범위 내에
더 많은 변수가 존재할수록, 각각의 변수를 추적하기 힘들어집니다. 목적을 분명히 하기 위해
설정 변수를 그룹화하여 하나의 구조로 결합시키는 것이 좋습니다.</p>
<p>세 번째 문제는 파일 열기가 실패 할 경우<code>expect</code>를 사용하여 오류 메시지를 출력해주는데,
에러 메시지가 <code>파일을 찾을 수 없음</code> 밖에 없습니다. 파일이 존재하지 않는 경우 외에도 파일
열기가 실패하는 경우들이 있습니다. 예를 들어 파일은 존재하지만 파일을 열 수있는 권한이 없을 수
있습니다. 현재는 이런 상황에도 <code>파일을 찾을 수 없음</code> 이란 오류 메시지를 출력하여 사용자에게
잘못된 조언을 해주게 됩니다.</p>
<p>넷째, 우리는 서로 다른 오류를 다루기 위해 <code>expect</code>를 반복적으로 사용하고 있습니다. 헌데
만약 사용자가 충분한 인수를 지정하지 않고 프로그램을 실행하면 Rust의 &quot;index out of
bounds&quot; 오류가 발생하는데 이는 문제를 명확하게 설명하지 않습니다. 우리가 모든 오류처리
코드를 한 군데 모아놓으면 후에 관리자는 오류처리 로직을 변경해야 할 때 오직 이 곳의 코드만
참고하면 되니 더 좋죠. 또한, 모든 오류 처리 코드를 한 곳에 저장하면 우리가 최종 사용자에게
도움이 되는 메시지를 출력하고 있는지 확신하는데도 도움이 됩니다.</p>
<p>이런 문제들을 우리 프로젝트를 리팩토링하여 해결해보도록 하겠습니다.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#a바이너리-프로젝트를-위한-핵심기능concern-나누기" id="a바이너리-프로젝트를-위한-핵심기능concern-나누기"><h3>바이너리 프로젝트를 위한 핵심기능(concern) 나누기</h3></a>
<p><code>main</code> 함수가 여러 작업에 책임을 갖게 되는 구조적 문제는 많은 바이너리 프로젝트에서
공통적입니다. 그래서 Rust 커뮤니티는 <code>main</code>이 커지기 시작할 때 바이너리 프로그램의
핵심기능을 나누기 위한 가이드라인 프로세스를 개발했습니다. 프로세스에는 다음 단계가 있습니다:</p>
<ol>
<li>당신의 프로그램을 <em>main.rs</em> 과 <em>lib.rs</em> 로 나누고 프로그램의 로직을 <em>lib.rs</em>
으로 옮깁니다.</li>
<li>커맨드라인 파싱 로직이 크지 않으면, <em>main.rs</em> 에 남겨둬도 됩니다.</li>
<li>커맨드라인 파싱 로직이 복잡해지기 시작할거 같으면, <em>main.rs</em> 에서 추출해서 <em>lib.rs</em>
로 옮기세요.</li>
<li>이런 절차를 통해 <code>main</code> 함수에는 다음의 핵심 기능들만 남아있어야 합니다:
<ul>
<li>인자 값들로 커맨드라인을 파싱하는 로직 호출</li>
<li>다른 환경들 설정</li>
<li><em>lib.rs</em>의 <code>run</code> 함수 호출</li>
<li><code>run</code>이 에러를 리턴하면, 에러 처리.</li>
</ul>
</li>
</ol>
<p>이 패턴이 핵심기능을 분리하는데 관한 모든 것입니다: <em>main.rs</em> 는 프로그램 실행을
담당하고, <em>lib.rs</em>는 맡은 작업에 관한 로직을 담당합니다. <code>main</code> 함수는 직접 테스트 할
수 없지만, 이런 구조로 <em>lib.rs</em> 으로 프로그램의 모든 함수와 로직을 옮긴 후에는 테스트가
가능해집니다. <em>main.rs</em>에는 읽어서 옳바른지 여부를 검증할 수 있을 정도로 적은 코드만을
남겨두도록 합니다. 다음의 과정을 거치며 재작업을 해봅시다.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#a인자-파서의-추출" id="a인자-파서의-추출"><h3>인자 파서의 추출</h3></a>
<p>먼저 우리는 커맨드라인 인자를 분석하는 기능을 추출할 겁니다. 항목 12-5에서 <code>main</code>의 시작 부분이 새로운 함수 <code>parse_config</code>를 호출하는 것을 볼 수 있을텐데, 이는 아직은  <em>src/main.rs</em>에 정의되어 있을 겁니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, filename) = parse_config(&amp;args);

    // ...snip...
}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let filename = &amp;args[2];

    (query, filename)
}
</code></pre>
<p><span class="caption">Listing 12-5: Extract a <code>parse_config</code> function from
<code>main</code></span></p>
<p>우리는 아직 커맨드라인 인자들을 벡터로 수집하고 있는데, 인덱스 1의 인수 값을 변수 <code>query</code>
에, 인덱스 2의 인수 값을 <code>main</code> 함수 내의 변수 <code>filename</code>에 할당하는 대신에 전체
벡터를 <code>parse_config</code> 함수로 전달합니다. <code>parse_config</code> 함수는 어디에 위치한
인자가 어떤 변수에 대입되는지에 대한 로직을 보유하고, 그 값들을 <code>main</code>으로 되돌려 줍니다.
우리는 여전히 <code>query</code>와 <code>filename</code>변수를 <code>main</code>에 생성하지만, <code>main</code>은
더 이상 커맨드라인 인자와 변수간의 상관 관계를 책임지지도 알아야 할 필요도 없죠.</p>
<p>이것이 우리가 작은 프로그램을 유지하기 위한 과도한 행동으로 보일수도 있지만, 우리는 조금씩
점진적으로 리팩토링을 진행하고 있습니다. 이런 변화를 준 뒤에는, 프로그램을 다시 실행해 인자의
파싱이 정상적으로 동작하고 있는지 확인해보십시오. 진행 상황을 자주 확인하면 문제가 생겼을 때
원인을 파악하는데 도움이 됩니다.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#a설정-변수들을-그룹짓기" id="a설정-변수들을-그룹짓기"><h4>설정 변수들을 그룹짓기</h4></a>
<!-- 원문의 내용이 잘못 작성된 것 같음. At the moment, we’re returning a tuple, but then we immediately break that tuple up into individual parts again. 문장은 but 이후 문장이 부정적 의미로 와야맞는 될 것 같음 -->
<p>우리는 이 함수의 기능을 더 향상시키기 위해 또 다른 작은 행동을 할 수 있습니다. 현재 우리는
튜플을 반환하고 있는데, 그 시점에 즉시 튜플을 개별된 부분으로 나눌 수가 없습니다. 이는 우리가
아직은 제대로 된 추상화를 하지 못하고 있다는 신호일 수 있습니다.</p>
<p>또 다른 의미로는 <code>config</code>의 부분인 <code>parse_config</code>에 향상시킬 지점이 있다는 것으로,
우리가 반환하는 두 개의 값은 관련되어 있으며 모두 하나의 설정 값에 대한 부분이죠. 우리는 현재
두 값을 튜플로 그룹화하는 것 이외의 다른 의미를 전달하지 않습니다. 두 값을 하나의 구조체에
넣고 각 구조체 필드에 의미있는 이름을 지정할 수 있습니다. 이렇게 하면 이 코드의 향후 유지
보수 담당자가 서로 다른 값이 서로 어떻게 관련되어 있고 그 목적이 무엇인지 쉽게 이해할 수
있습니다.</p>
<blockquote>
<p>Note: some people call this anti-pattern of using primitive values when a
complex type would be more appropriate <em>primitive obsession</em>.</p>
</blockquote>
<p>항목 12-6에서 <code>query</code>와 <code>filename</code>을 필드로 갖는 <code>Config</code>란 구조체 정의가
추가된 것을 볼 수 있습니다. 우리는 또한 <code>parse_config</code> 함수를 변경하여 <code>Config</code>
구조체의 객체를 반환하게 변경하였으며, <code>main</code>에서 별개의 변수가 아닌 구조체의 필드를
사용하도록 변경했습니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"># use std::env;
# use std::fs::File;
#
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    // ...snip...
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
</code></pre></pre>
<p>Listing 12-6: Refactoring <code>parse_config</code> to return an instance of a <code>Config</code> struct</p>
<p>이제 <code>parse_config</code>의 선언은 <code>Config</code> 값을 반환한다는 것을 알려줍니다.
<code>parse_config</code> 의 내부에서는 <code>args</code>의 <code>String</code>값을 참조하는 문자열 조각을
반환했었지만, 이제는 <code>Config</code>를 정의하고 자체 <code>String</code>의 값을 포함하도록 선택했습니다.
<code>main</code>의 <code>args</code>변수는 인자 값들의 소유주로 <code>parse_config</code>에는 그들을 대여해줄 뿐
입니다. 그렇기에 만약 <code>Config</code>가 <code>args</code>의 값들에 대한 소유권을 가지려고 시도하면 Rust의
대여 규칙을 위반하게 됩니다.</p>
<p>우리가 <code>String</code> 데이터를 관리하는 방식은 여러가지가 있겠습니다만, 가장 쉽고 약간 비효율적인 방법은 <code>clone</code> 메소드를 호출하는 겁니다. 이 방식은 <code>Config</code> 객체에서 소유하게 할 data 전체에 대한 복사본을 만들 것이며, 이런 방식은 참조만 보관하는 것에 비해 약간 더 많은 비용과 메모리가 소비됩니다. 하지만 데이터의 복제본을 만드는 방식은 우리가 참조의 생명주기를 관리하지 않아도 되기 때문에 우리의 코드를 매우 직관적이게 합니다. 그래서 이런 상황에서는 약간의 성능을 포기하고 간소함을 유지하는 것이 매우 가치있는 거래입니다.</p>
<blockquote>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#clone-사용의-기회비용" id="clone-사용의-기회비용"><h3><code>clone</code> 사용의 기회비용</h3></a>
<p>많은 Rust 사용자들은 런타임 비용 때문에 소유권 문제를 수정하기 위해 clone을 사용하지
않는 경향이 있습니다. 13장 이터레이터에서, 이런 상황에서보다 효율적인 메소드를
사용하는 법을 배우겠지만, 지금은 한 번만 clone하며 query와 filename이 매우 작기
때문에 몇 개의 문자열을 clone하여 진행하는 것이 좋습니다. 첫 번째 단계에서는 코드를
최대한 최적화하는 것보다 약간 비효율적이더라도 넘어가는게 좋습니다. Rust에 대한 경험이
많을수록 바람직한 방법으로 곧장 진행할 수 있을 겁니다. 지금은 clone을 호출하는 것이
완벽한 선택입니다.</p>
</blockquote>
<p><code>parse_config</code>에 의해 반환된 <code>Config</code>의 객체를 <code>config</code>라는 변수에 넣고 이전에
별도로 <code>query</code>와 <code>filename</code>이란 이름으로 나뉘어 있던 변수 대신 <code>Config</code> 구조체의
필드를 사용하도록 <code>main</code>을 업데이트했습니다.</p>
<p>우리의 코드는 이제 보다 분명하게 <code>query</code>와 <code>filename</code>이 연관되어 있으며 이들의 목적이
프로그램이 어떻게 동작할지에 대한 설정이라는 의도를 전달할 수 있습니다. 이 값을 사용하는 모든 코드는 그들의 의도에 맞게 지정된 필드를 <code>config</code> 객체에서 찾을 수 있습니다.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#config를-위한-생성자-만들기" id="config를-위한-생성자-만들기"><h4><code>Config</code>를 위한 생성자 만들기.</h4></a>
<p>지금까지 우리는 <code>main</code>에서 <code>parse_config</code>함수로 커맨드라인 인자를 파싱하는 로직을
추출했습니다. 이를 통해 우리 코드에서 <code>query</code>와 <code>filename</code>값이 연관되어 있고 그
연결성이 전달되어야 한다는 것을 알았습니다. 그래서 우리는 <code>Config</code> 구조체를 추가하고
그 의도와 목적에 맞게 <code>query</code>와 <code>filename</code>을 명명했으며 <code>parse_config</code> 함수에서
변수의 이름을 구조체 필드 이름으로 반환 할 수 있게 했습니다.</p>
<p>그래서 이제 <code>parse_config</code> 함수의 목적은 <code>Config</code> 객체를 생성하는 것인데, 우리는
<code>parse_config</code>라는 평범한 함수를 <code>Config</code> 구조체와 관련된 <code>new</code>라는 함수로 변경
할 수 있습니다. 이런 변경은 우리의 코드를 보다 자연스럽게 만들어 줍니다:<code>String::new</code>를
호출하여 <code>String</code>형의 객체를 생성하는 것처럼 표준 라이브러리들의 객체를 생성할 수 있습니다.
그리고 <code>parse_config</code>를 <code>Config</code>와 연관된 <code>new</code>함수로 변경하게 되면, 우리는
<code>Config</code>의 객체를 <code>Config::new</code>를 호출하여 생성할 수 있게 됩니다. 항목 12-7는
우리가 해야할 변동사항 보여줍니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"># use std::env;
#
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);

    // ...snip...
}

# struct Config {
#     query: String,
#     filename: String,
# }
#
// ...snip...

impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
</code></pre></pre>
<p><span class="caption">Listing 12-7: Changing <code>parse_config</code> into
<code>Config::new</code></span></p>
<p>우리는 <code>main</code>을 갱신하여 <code>parse_config</code>를 호출하는 대신 <code>Config::new</code>를
호출하게 되었습니다. 우리는 <code>parse_config</code>의 이름을 <code>new</code>로 바꾸고 그를 <code>impl</code>블록
안으로 옮겼는데, 이를 통해 <code>new</code>함수가 <code>Config</code>와 연결되게 됩니다. 다시 컴파일을 하고
제대로 동작하는지 확인해보도록 합시다.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#a에러-처리-수정하기" id="a에러-처리-수정하기"><h3>에러 처리 수정하기</h3></a>
<p>이번에는 우리의 에러 처리를 수정해 볼 겁니다. 만일 <code>args</code> 벡터가 3개 미만의 아이템을<br />
가지고 있을 때 인덱스 <code>2</code> 혹은 <code>3</code>의 값에 접근하려는 시도를 하면 프로그램은 패닉을
일으키게 된다고 했던 것을 상기시켜 드립니다. 프로그램을 인자 없이 실행해보시면;
다음같이 될 겁니다.</p>
<pre><code class="language-text">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/greprs`
thread 'main' panicked at 'index out of bounds: the len is 1
but the index is 1',  /stable-dist-rustc/build/src/libcollections/vec.rs:1307
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p><code>index out of bounds: the len is 1 but the index is 1</code> 줄은
프로그래머를 위해 의도된 에러 메시지이지, 최종 사용자에게는 무슨 일이 있었는지 무엇을 해야 하는지
이해하는데 아무런 도움이 되지 않습니다. 당장 한번 고쳐보겠습니다.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#a에러-메시지-향상시키기" id="a에러-메시지-향상시키기"><h4>에러 메시지 향상시키기</h4></a>
<p>항목 12-8에서 <code>new</code>함수에 검사를 추가하여 인덱스 <code>1</code>과 <code>2</code>에 접근하기 전에 조각이
충분한 길이인지를 확인합니다. 조각이 충분히 길지 않다면, 프로그램은 더 좋은 에러메시지
<code>index out of bounds</code>를 보여주고 패닉을 일으킵니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">// ...snip...
fn new(args: &amp;[String]) -&gt; Config {
    if args.len() &lt; 3 {
        panic!(&quot;not enough arguments&quot;);
    }
    // ...snip...
</code></pre>
<p><span class="caption">항목 12-8: 인자의 숫자가 몇 개인지 검증 추가</span></p>
<p>이것은 항목 9-8에서 작성한 <code>Guess::new</code>함수와 유사합니다. 이 함수는 <code>value</code>인수가 유효한 값의 범위를 벗어난 경우 <code>panic!</code>을 호출했습니다. 값의 범위를 검사하는 대신에, 우리는<code>args</code>의 길이가 적어도 3개인지 검사하면, 함수의 나머지 부분은 이 조건이 이미 충족되었다는 가정 하에서 동작할 수 있습니다. <code>args</code>가 3개 보다 적은 아이템을 가진다면, 이 조건은 true가 되고 우리는 <code>panic!</code> 매크로를 호출해 프로그램을 즉시 종료 시킬겁니다.</p>
<p>이런 몇 줄의 추가 코드들을 <code>new</code>상에 추가하고, 우리 프로그램을 아무 인자도 없이 다시 실행시키면
다음과 같은 에러를 볼 수 있을 겁니다.</p>
<pre><code class="language-bash">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/greprs`
thread 'main' panicked at 'not enough arguments', src/main.rs:29
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>이 결과 더 합리적인 좋은 오류 메시지가 표시됩니다. 그러나 사용자에게 제공하고 싶지 않은 추가
정보가 있습니다. 따라서 항목 9-8에서 사용한 기술을 사용하는 것은 여기선 최선의 방법은 아닙니다.
<code>panic!</code>에 대한 호출은 9장에서 논의했던 것처럼 사용 방법에 대한 문제가 아닌 아니라 프로그래밍
관련 문제에 더 적합합니다. 대신, 우리는 9장에서 배운 다른 기법으로 <code>Result</code>를 반환하는 것을
성공이나 오류를 나타낼 수 있습니다.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#new에서-panic을-호출하는-대신-result를-반환하기" id="new에서-panic을-호출하는-대신-result를-반환하기"><h4><code>new</code>에서 <code>panic!</code>을 호출하는 대신 <code>Result</code>를 반환하기.</h4></a>
<p>우리는 <code>Result</code>를 반환 값으로 선택하여 성공인 경우에는 <code>Config</code> 객체를 포함시키고 에러가
발생한 경우에는 문제가 무엇인지 설명할 수 있게 만들 수 있다. <code>Config::new</code>가 <code>main</code>과
상호작용할 시에, 우리는 <code>Result</code>를 사용하여 문제가 있다고 신호할 수 있다. 그리고<code>main</code>에선
<code>Err</code>의 값을 사용자들에게 보다 실용적인 방식으로 변환하여 보여줄 수 있다. <code>thread 'main'</code>
으로 시작하는 문자들과 <code>panic!</code>을 사용해서 보여지는 <code>RUST_BACKTRACE</code>관련 메시지 없이.</p>
<p>항목 12-9에서 당신이 변경해야 할 <code>Config::new</code>의 반환 값과 <code>Result</code>를 반환하기 위한
함수 본문을 보여줍니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
</code></pre>
<p><span class="caption">항목 12-9: <code>Config::new</code>에서 <code>Result</code>반환</span></p>
<p>우리의 <code>new</code> 함수는 이제 성공 시에는 <code>Config</code>객체가 에러 시에는 <code>&amp;'static str</code>가 포함된
<code>Result</code>를 반환하게 됩니다. 10장의 &quot;The Static Lifetime&quot;에서 `&amp;'static str'이
문자열 리터럴이라고 다뤘는데, 이게 현재 우리의 에러 타입입니다.</p>
<p>우리는 <code>new</code>함수의 본문에서 두 가지 변경을했습니다 : 사용자가 충분한 인수를 전달하지 않을 때
<code>panic!</code>을 호출하는 대신 <code>Err</code>값을 반환하고 <code>Config</code>를 반환할 때는 <code>Ok</code>로 포장하여
반환 합니다. 이런 변경으로 인해 함수는 새로운 타입 선언을 갖게 됩니다.</p>
<p><code>Config::new</code>가 <code>Err</code>값을 반환하게 함으로써, <code>main</code>함수는 <code>new</code>함수로부터 반환된
<code>Result</code>값을 처리하고 에러 상황에 프로세스를 더 깨끗하게 종료 할 수 있습니다.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#confignew를-호출하고-에러-처리하기" id="confignew를-호출하고-에러-처리하기"><h4><code>Config::new</code>를 호출하고 에러 처리하기</h4></a>
<p>에러 케이스를 처리하고 사용자-친화적인 메시지를 출력하기 위해서, 항목 12-10에서처럼
<code>Config::new</code>가 리턴하는 <code>Result</code>를 처리하기 위해 <code>main</code>을 갱신해야 합니다. 그리고
우리 커맨드라인 프로그램을 <code>panic!</code>으로 0이 아닌 값을 발생시킬 때에는 종료시켜야 하므로 직접
구현해보도록 합시다. 0이 아닌 종료 값은 우리 프로그램을 호출한 프로그램에게 우리의 프로그램이 에러
상태로 종료되었음을 알리는 규칙입니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // ...snip...
</code></pre>
<p><span class="caption">항목 12-10: new <code>Config</code>가 실패했을 때 에러 코드와 함께 종료시키기</span></p>
<p>이 목록에서 우리는 이전에 다루지 않았던 메소드를 사용하고 있습니다: <code>unwrap_or_else</code>는
표준 라이브러리에 의해 <code>Result &lt;T, E&gt;</code>에 정의되어 있습니다. <code>unwrap_or_else</code>를
사용하면 <code>panic!</code>이 아닌 에러 처리를 직접 정의 할 수 있습니다. <code>Result</code>가 <code>Ok</code> 값이면,
이 메소드의 동작은 <code>unwrap</code>과 유사합니다 : 그것은 <code>Ok</code>로 포장한 내부 값을 반환합니다.
그러나 <code>Err</code>값이면 메소드는 <em>closure</em>의 코드를 호출합니다. <em>closure</em>는 익명의 함수로
<code>unwrap_or_else</code>에 인수로 전달됩니다. 13장에서 클로저에 대해 더 자세히 다룰 것입니다.
여기서 알아 두어야 할 것은 <code>unwrap_or_else</code>가 <code>Err</code>의 내부 값, 이번 경우에는 항목
12-9에서 우리가 추가한 정적 문자열인 <code>not enough arguments</code>을, 수직파이프 사이에
위치하는 <code>err</code>로 인자로서 우리의 클로저로 전달한다는 겁니다. 클로저에 있는 코드는 이런 과정을
거쳐 실행 시에 <code>err</code>값을 사용할 수 있습니다.</p>
<p>우리는 새 <code>use</code>줄을 추가하여 <code>process</code>를 공유 라이브러리에서 import했습니다. 에러 상황에
실행될 클로저의 코드는 단 두 줄 입니다. 에러 값을 출력해주고 <code>process::exit</code>를 호출합니다.
<code>process::exit</code>함수는 프로그래을 즉시 중단시키고 종료 상태 코드로 전달받은 값을 반환합니다.
이것은 항목 12-8에서 사용한 <code>panic!</code>기반의 처리 방식과 유사해 보이지만, 더이상 필요하지 않은
출력을 하지 않죠. 해볼까요?</p>
<pre><code class="language-text">$ cargo run
   Compiling greprs v0.1.0 (file:///projects/greprs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48 secs
     Running `target/debug/greprs`
Problem parsing arguments: not enough arguments
</code></pre>
<p>훌륭하네요! 이 출력은 우리 사용자들에게 훨씬 친화적입니다.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#run-함수-추출하기" id="run-함수-추출하기"><h3><code>run</code> 함수 추출하기</h3></a>
<p>이제 환경 설정 파싱 리팩토링을 마무리 했습니다. 우리 프로그램의 로직으로 돌아갑시다. 우리가
&quot;바이너리 프로젝트에서 핵심 기능의 분리&quot;절에서 논의한 과정에 따라, 우리는 <code>main</code>함수에 구성
설정 또는 오류 처리와 관계 없는 남아있는 모든 로직들을 담고있는 <code>run</code>함수를 추출 할 겁니다.
이 과정이 종료되면, <code>main</code>은 간결해져 쉽게 검증할 수 있어지고, 우리는 다른 모든 로직에 대한
테스트를 작성할 수 있을 겁니다.</p>
<p>항목 12-11 추출된 <code>run</code> 함수를 보여줍니다. 현재 우리는 함수를 추출하여 <em>src/main.rs</em>에
함수를 정의하는 작고 점진적 개선만 수행하고 있습니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // ...snip...

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    run(config);
}

fn run(config: Config) {
    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents).expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}

// ...snip...
</code></pre>
<p><span class="caption">항목 12-11: 남은 프로그램 로직을 <code>run</code> 함수로 추출하기 </span></p>
<p>이제 <code>run</code>함수에는 <code>main</code>에 잔존하는 파일을 읽는 것부터 나머지 모든 로직이 포함됩니다.
<code>run</code> 함수는 <code>Config</code> 객체를 인수로 취합니다.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#run-함수에서-에러-반환하기" id="run-함수에서-에러-반환하기"><h4><code>run</code> 함수에서 에러 반환하기</h4></a>
<p>나머지 프로그램 로직을 <code>main</code>이 아닌<code>run</code> 함수로 분리하면, Listing 12-9의
<code>Config::new</code>처럼 에러 처리를 향상시킬 수 있습니다. <code>expect</code>를 호출하여 프로그램을 패닉
상태로 만드는 대신, <code>run</code>함수는 무언가가 잘못되었을 때 <code>Result &lt;T, E&gt;</code>를 리턴 할
것입니다. 이러면 사용자 친화적인 방법으로 오류를 처리하는 로직을 <code>main</code>으로 통합 할 수
있습니다. 항목 12-12는 <code>run</code>의 선언부와 본문의 변경 사항을 보여줍니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;

// ...snip...

fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    println!(&quot;With text:\n{}&quot;, contents);

    Ok(())
}
</code></pre>
<p><span class="caption">항목 12-12: <code>run</code> 함수가 <code>Result</code>를 반환하게 바꾸기 </span></p>
<p>우리는 여기서 세 가지 큰 변화를 만들었습니다. 먼저, <code>run</code> 함수의 리턴 타입을 <code>Result &lt;(), Box &lt;Error &gt;&gt;</code>로 바꿨습니다. 이 함수는 이전에 유닛 타입 <code>()</code>을 반환했으며,
우리는 <code>Ok</code>의 경우 반환할 값으로 이 타입을 유지합니다.</p>
<p>우리의 에러 타입으로, <em>특성 오브젝트</em> Box <Error>를 사용합니다 (그리고 상단에 <code>use</code>문으로
<code>std::error::Error</code>를 범위 내로 임포트 해왔습니다). 우리는 특성 오브젝트들을 17장에서
다룰 것입니다. 지금 당장은, <code>Box&lt;Error&gt;</code>는 함수가 <code>Error</code> 특성을 구현하는 타입을
반환한다는 것만 알면 되고, 특별히 어떤 타입이 반환될지에 대해서는 알 필요 없습니다. 이런 방식은
다양한 에러 상황에 다른 타입의 오류 값을 반환 할 수 있는 유연성을 확보할 수 있습니다.</p>
<p>우리가 만든 두 번째 변화는 우리가 9 장에서 이야기했듯이, <code>?</code>에 대한 <code>expect</code>에 대한 호출을 제거한 것입니다. 에러 시에 <code>panic!</code>을 호출하는 것보다 현재 함수에서 에러 값을 반환하며 호출자가 처리 할 수 ​​있도록 하였습니다.</p>
<p>셋째, 이 함수는 성공 사례에서 <code>Ok</code>값을 반환합니다. 우리는 <code>run</code> 함수의 성공 타입을 선언부에서
<code>()</code>로 선언했습니다, 이것은 우리가 유닛 타입 값을 <code>Ok</code> 값으로 감쌀 필요가 있음을 의미합니다.
이 <code>Ok (())</code>구문은 조금 이상하게 보일 수 있지만, <code>()</code>를 사용하는 것과 마찬가지로 이는
사이드이펙트 없이 <code>run</code>을 호출하는 것을 나타내는 관용적인 방법입니다. 우리가 필요로 하는 값을
반환하지 않습니다.</p>
<p>실행시키면, 컴파일 될텐데, 경고를 보여줍니다:</p>
<pre><code class="language-text">warning: unused result which must be used, #[warn(unused_must_use)] on by default
  --&gt; src/main.rs:39:5
   |
39 |     run(config);
   |     ^^^^^^^^^^^^
</code></pre>
<p>Rust는 우리 코드가 오류가 있음을 나타내는 <code>Result</code> 값을 무시한다는 것을 알려줍니다. 우리는
에러가 있는지 아닌지를 확인하지 않고 있고, 컴파일러는 우리에게 아마도 여기에 에러 처리 코드를
작성해야 한다는 것을 상기 시켜줄 것입니다! 당장 바로잡아 봅시다.</p>
<p>Rust는 우리 코드가 오류가 있음을 나타내는 'Result'값을 무시한다는 것을 알려줍니다. 우리는 에러가 있는지 아닌지를 확인하지 않고 있고, 컴파일러는 아마도 여기에 에러 처리 코드를 가지고 있다는 것을 상기 시켜줄 것입니다! 지금 바로 잡아 보자.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#main안의-run에서-반환되는-에러-처리하기" id="main안의-run에서-반환되는-에러-처리하기"><h4><code>main</code>안의 <code>run</code>에서 반환되는 에러 처리하기</h4></a>
<p>우리는 항목 12-10의 <code>Config::new</code>를 사용하여 오류를 처리하는 방식과 비슷한 방법을 사용하여 오류를 검사하고 멋지게 처리합니다. 그러나 약간의 차이점이 있습니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // ...snip...

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p>우리는 <code>unwrap_or_else</code>를 호출하기 보다 <code>if let</code>을 사용하여 <code>run</code>이 <code>Err</code>값을
반환하는지 검사하고 만약 그렇다면 <code>process::exit(1)</code>을 호출합니다. <code>run</code>은
<code>Config::new</code>가 <code>Config</code>객체를 반환하는 것처럼 우리가 <code>unwrap</code>하기를 원하는 값을
반환하지 않습니다. 왜냐하면 <code>run</code>은 성공하면 <code>()</code>를 반환하기 때문에, 우리는 에러가 발생한
경우만 신경쓰면 됩니다. 그래서 우리는 <code>unwrap_or_else</code>을 통해 포장을 벗길 필요가 없죠,
값은 무조건 <code>()</code>일테니까요.</p>
<p><code>if let</code>과 <code>unwrap_or_else</code> 함수의 내용은 동일한 경우에 동일한 동작을 합니다, 오류를
출력하고 종료하죠.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#a라이브러리-크레이트로-코드를-나누기" id="a라이브러리-크레이트로-코드를-나누기"><h3>라이브러리 크레이트로 코드를 나누기</h3></a>
<p>지금까지 꽤 좋아 보인다! 이제 우리는 <em>src/main.rs</em> 파일을 나눠서 <em>src/lib.rs</em>에 몇 개의 코드를 넣어서 테스트 할 수 있고 작은 <em>src/main.rs</em> 파일을 갖게 될 것입니다.</p>
<p><em>src/main.rs</em>에 파편으로 존재하는 다음 코드들을 새 파일로 옮겨봅시다.
<em>src/lib.rs</em>:</p>
<ul>
<li><code>run</code> 함수 정의</li>
<li>관련있는<code>use</code> 문들</li>
<li><code>Config</code>의 정의</li>
<li><code>Config::new</code> 함수와 정의</li>
</ul>
<p><em>src/lib.rs</em>의 내용은 항목 12-13에서 보이는 것과 같을겁니다.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt;{
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    println!(&quot;With text:\n{}&quot;, contents);

    Ok(())
}
</code></pre>
<p><span class="caption">항목 12-13: <code>Config</code>과 <code>run</code>을 <em>src/lib.rs</em>로 옮기기</span></p>
<p>우리는 <code>Config</code>의 필드 및 <code>new</code> 메소드와 <code>run</code> 함수에 대해 <code>pub</code>을 자유롭게 사용했습니다. 이제 우리가 테스트 할 수있는 공개 API를 가진 라이브러리 크레이트가 생겼습니다.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#a바이너리-크레이트에서-라이브러리-크레이트-호출하기" id="a바이너리-크레이트에서-라이브러리-크레이트-호출하기"><h4>바이너리 크레이트에서 라이브러리 크레이트 호출하기</h4></a>
<p>이제 우리는 <em>src/main.rs</em>에 있는 바이너리 크레이트의 범위에 <em>src/lib.rs</em>로 옮긴 코드를
<code>extern crate greprs</code>를 사용하여 가져와야 합니다. 이후 <code>use greprs::Config</code>
행을 추가하여 <code>Config</code> 타입을 범위로 가져오고 항목 12-14와 같이 크레이트 이름으로<code>run</code>
함수 앞에 접두사를 붙입니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate greprs;

use std::env;
use std::process;

use greprs::Config;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    if let Err(e) = greprs::run(config) {
        println!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p><span class="caption">항목 12-14: <code>greprs</code>크레이트를 <em>src/main.rs</em> 범위로 연결하기</span></p>
<!-- 이하의  https://doc.rust-lang.org/book/second-edition/ch12-03-improving-error-handling-and-modularity.html 
에서 직접 옮겼습니다. -->
<p>라이브러리 크레이트를 바이너리 크레이트에 가져 오려면 <code>extern crate minigrep</code>을
사용합니다. 그런 다음 <code>minigrep::Config</code>줄을 추가하여 <code>Config</code>타입을 범위로 가져오고
<code>run</code> 함수 접두어에 크레이트 이름을 붙입니다. 이를 통해 모든 기능이 연결되어 있어야 하며
작동해야 합니다. <code>cargo run</code>을 실행하여 모든 것이 올바르게 연결되어 있는지 확인하십시오.</p>
<p>아오! 빡시게 작업했네요, 우리의 미래를 우리 스스로가 성공의 방향으로 설정했습니다. 이제 에러를
처리가 훨씬 쉬워졌고, 우리의 코드를 보다 모듈화하였습니다. 거의 모든 작업은 여기
<em>src/lib.rs</em>에서 수행될 겁니다.</p>
<p>새롭게 확보한 모듈성을 통해 이전의 코드로는 하지 못했을 무언가를 쉽게 할 수 있는 이점을 확보했습니다:몇 개의 테스트를 작성해봅시다!</p>
<!-- 이 내용은 https://doc.rust-lang.org/book/second-edition/ch12-03-improving-error-handling-and-modularity.html 에서 직접 옮겼습니다. -->
<!-- To bring the library crate into the binary crate, we use extern crate minigrep. Then we’ll add a use minigrep::Config line to bring the Config type into scope, and we’ll prefix the run function with our crate name. With that, all the functionality should be connected and should work. Give it a cargo run and make sure everything is wired up correctly.
<p>Whew! That was a lot of work, but we’ve set ourselves up for success in the future. Now it’s much easier to handle errors, and we’ve made our code more modular. Almost all of our work will be done in src/lib.rs from here on out.</p>
<p>Let’s take advantage of this newfound modularity by doing something that would have been hard with our old code, but is easy with our new code: write some tests! --&gt;</p>
<!-- 업데이트된 원본:
## Refactoring to Improve Modularity and Error Handling
<p>To improve our program, we’ll fix four problems that have to do with the
program’s structure and how it’s handling potential errors.</p>
<p>First, our <code>main</code> function now performs two tasks: it parses arguments and
opens files. For such a small function, this isn’t a major problem. However, if
we continue to grow our program inside <code>main</code>, the number of separate tasks the
<code>main</code> function handles will increase. As a function gains responsibilities, it
becomes more difficult to reason about, harder to test, and harder to change
without breaking one of its parts. It’s best to separate functionality so each
function is responsible for one task.</p>
<p>This issue also ties into the second problem: although <code>query</code> and <code>filename</code>
are configuration variables to our program, variables like <code>f</code> and <code>contents</code>
are used to perform the program’s logic. The longer <code>main</code> becomes, the more
variables we’ll need to bring into scope; the more variables we have in scope,
the harder it will be to keep track of the purpose of each. It’s best to group
the configuration variables into one structure to make their purpose clear.</p>
<p>The third problem is that we’ve used <code>expect</code> to print an error message when
opening the file fails, but the error message just prints <code>file not found</code>.
Opening a file can fail in a number of ways besides the file being missing: for
example, the file might exist, but we might not have permission to open it.
Right now, if we’re in that situation, we’d print the <code>file not found</code> error
message, which would give the user the wrong information!</p>
<p>Fourth, we use <code>expect</code> repeatedly to handle different errors, and if the user
runs our program without specifying enough arguments, they’ll get an <code>index out of bounds</code> error from Rust that doesn’t clearly explain the problem. It would
be best if all the error-handling code were in one place so future maintainers
had only one place to consult in the code if the error-handling logic needed to
change. Having all the error-handling code in one place will also ensure that
we’re printing messages that will be meaningful to our end users.</p>
<p>Let’s address these four problems by refactoring our project.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#separation-of-concerns-for-binary-projects" id="separation-of-concerns-for-binary-projects"><h3>Separation of Concerns for Binary Projects</h3></a>
<p>The organizational problem of allocating responsibility for multiple tasks to
the <code>main</code> function is common to many binary projects. As a result, the Rust
community has developed a process to use as a guideline for splitting the
separate concerns of a binary program when <code>main</code> starts getting large. The
process has the following steps:</p>
<ul>
<li>
<p>Split your program into a <em>main.rs</em> and a <em>lib.rs</em> and move your program’s
logic to <em>lib.rs</em>.</p>
</li>
<li>
<p>As long as your command line parsing logic is small, it can remain in
<em>main.rs</em>.</p>
</li>
<li>
<p>When the command line parsing logic starts getting complicated, extract it
from <em>main.rs</em> and move it to <em>lib.rs</em>.</p>
</li>
<li>
<p>The responsibilities that remain in the <code>main</code> function after this process
should be limited to the following:</p>
<ul>
<li>Calling the command line parsing logic with the argument values</li>
<li>Setting up any other configuration</li>
<li>Calling a <code>run</code> function in <em>lib.rs</em></li>
<li>Handling the error if <code>run</code> returns an error</li>
</ul>
</li>
</ul>
<p>This pattern is about separating concerns: <em>main.rs</em> handles running the
program, and <em>lib.rs</em> handles all the logic of the task at hand. Because you
can’t test the <code>main</code> function directly, this structure lets you test all of
your program’s logic by moving it into functions in <em>lib.rs</em>. The only code
that remains in <em>main.rs</em> will be small enough to verify its correctness by
reading it. Let’s rework our program by following this process.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#extracting-the-argument-parser" id="extracting-the-argument-parser"><h4>Extracting the Argument Parser</h4></a>
<p>We’ll extract the functionality for parsing arguments into a function that
<code>main</code> will call to prepare for moving the command line parsing logic to
<em>src/lib.rs</em>. Listing 12-5 shows the new start of <code>main</code> that calls a new
function <code>parse_config</code>, which we’ll define in <em>src/main.rs</em> for the moment.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, filename) = parse_config(&amp;args);

    // --snip--
}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let filename = &amp;args[2];

    (query, filename)
}
</code></pre>
<p><span class="caption">Listing 12-5: Extracting a <code>parse_config</code> function from
<code>main</code></span></p>
<p>We’re still collecting the command line arguments into a vector, but instead of
assigning the argument value at index <code>1</code> to the variable <code>query</code> and the
argument value at index <code>2</code> to the variable <code>filename</code> within the <code>main</code>
function, we pass the whole vector to the <code>parse_config</code> function. The
<code>parse_config</code> function then holds the logic that determines which argument
goes in which variable and passes the values back to <code>main</code>. We still create
the <code>query</code> and <code>filename</code> variables in <code>main</code>, but <code>main</code> no longer has the
responsibility of determining how the command line arguments and variables
correspond.</p>
<p>This rework may seem like overkill for our small program, but we’re refactoring
in small, incremental steps. After making this change, run the program again to
verify that the argument parsing still works. It’s good to check your progress
often, to help identify the cause of problems when they occur.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#grouping-configuration-values" id="grouping-configuration-values"><h4>Grouping Configuration Values</h4></a>
<p>We can take another small step to improve the <code>parse_config</code> function further.
At the moment, we’re returning a tuple, but then we immediately break that
tuple into individual parts again. This is a sign that perhaps we don’t have
the right abstraction yet.</p>
<p>Another indicator that shows there’s room for improvement is the <code>config</code> part
of <code>parse_config</code>, which implies that the two values we return are related and
are both part of one configuration value. We’re not currently conveying this
meaning in the structure of the data other than by grouping the two values into
a tuple; we could put the two values into one struct and give each of the
struct fields a meaningful name. Doing so will make it easier for future
maintainers of this code to understand how the different values relate to each
other and what their purpose is.</p>
<blockquote>
<p>Note: Some people call this anti-pattern of using primitive values when a
complex type would be more appropriate <em>primitive obsession</em>.</p>
</blockquote>
<p>Listing 12-6 shows the addition of a struct named <code>Config</code> defined to have
fields named <code>query</code> and <code>filename</code>. We’ve also changed the <code>parse_config</code>
function to return an instance of the <code>Config</code> struct and updated <code>main</code> to use
the struct fields rather than having separate variables:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"># use std::env;
# use std::fs::File;
#
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    // --snip--
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
</code></pre></pre>
<p><span class="caption">Listing 12-6: Refactoring <code>parse_config</code> to return an
instance of a <code>Config</code> struct</span></p>
<p>The signature of <code>parse_config</code> now indicates that it returns a <code>Config</code> value.
In the body of <code>parse_config</code>, where we used to return string slices that
reference <code>String</code> values in <code>args</code>, we now define <code>Config</code> to contain owned
<code>String</code> values. The <code>args</code> variable in <code>main</code> is the owner of the argument
values and is only letting the <code>parse_config</code> function borrow them, which means
we’d violate Rust’s borrowing rules if <code>Config</code> tried to take ownership of the
values in <code>args</code>.</p>
<p>We could manage the <code>String</code> data in a number of different ways, but the
easiest, though somewhat inefficient, route is to call the <code>clone</code> method on
the values. This will make a full copy of the data for the <code>Config</code> instance to
own, which takes more time and memory than storing a reference to the string
data. However, cloning the data also makes our code very straightforward
because we don’t have to manage the lifetimes of the references; in this
circumstance, giving up a little performance to gain simplicity is a worthwhile
trade-off.</p>
<blockquote>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#the-trade-offs-of-using-clone" id="the-trade-offs-of-using-clone"><h3>The Trade-Offs of Using <code>clone</code></h3></a>
<p>There’s a tendency among many Rustaceans to avoid using <code>clone</code> to fix
ownership problems because of its runtime cost. In Chapter 13, you’ll learn
how to use more efficient methods in this type of situation. But for now,
it’s okay to copy a few strings to continue making progress because you’ll
make these copies only once and your filename and query string are very
small. It’s better to have a working program that’s a bit inefficient than to
try to hyperoptimize code on your first pass. As you become more experienced
with Rust, it’ll be easier to start with the most efficient solution, but for
now, it’s perfectly acceptable to call <code>clone</code>.</p>
</blockquote>
<p>We’ve updated <code>main</code> so it places the instance of <code>Config</code> returned by
<code>parse_config</code> into a variable named <code>config</code>, and we updated the code that
previously used the separate <code>query</code> and <code>filename</code> variables so it now uses
the fields on the <code>Config</code> struct instead.</p>
<p>Now our code more clearly conveys that <code>query</code> and <code>filename</code> are related and
that their purpose is to configure how the program will work. Any code that
uses these values knows to find them in the <code>config</code> instance in the fields
named for their purpose.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#creating-a-constructor-for-config" id="creating-a-constructor-for-config"><h4>Creating a Constructor for <code>Config</code></h4></a>
<p>So far, we’ve extracted the logic responsible for parsing the command line
arguments from <code>main</code> and placed it in the <code>parse_config</code> function. Doing so
helped us to see that the <code>query</code> and <code>filename</code> values were related and that
relationship should be conveyed in our code. We then added a <code>Config</code> struct to
name the related purpose of <code>query</code> and <code>filename</code> and to be able to return the
values’ names as struct field names from the <code>parse_config</code> function.</p>
<p>So now that the purpose of the <code>parse_config</code> function is to create a <code>Config</code>
instance, we can change <code>parse_config</code> from a plain function to a function
named <code>new</code> that is associated with the <code>Config</code> struct. Making this change
will make the code more idiomatic. We can create instances of types in the
standard library, such as <code>String</code>, by calling <code>String::new</code>. Similarly, by
changing <code>parse_config</code> into a <code>new</code> function associated with <code>Config</code>, we’ll
be able to create instances of <code>Config</code> by calling <code>Config::new</code>. Listing 12-7
shows the changes we need to make:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"># use std::env;
#
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);

    // --snip--
}

# struct Config {
#     query: String,
#     filename: String,
# }
#
// --snip--

impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
</code></pre></pre>
<p><span class="caption">Listing 12-7: Changing <code>parse_config</code> into
<code>Config::new</code></span></p>
<p>We’ve updated <code>main</code> where we were calling <code>parse_config</code> to instead call
<code>Config::new</code>. We’ve changed the name of <code>parse_config</code> to <code>new</code> and moved it
within an <code>impl</code> block, which associates the <code>new</code> function with <code>Config</code>. Try
compiling this code again to make sure it works.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#fixing-the-error-handling" id="fixing-the-error-handling"><h3>Fixing the Error Handling</h3></a>
<p>Now we’ll work on fixing our error handling. Recall that attempting to access
the values in the <code>args</code> vector at index <code>1</code> or index <code>2</code> will cause the
program to panic if the vector contains fewer than three items. Try running the
program without any arguments; it will look like this:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1
but the index is 1', src/main.rs:29:21
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>The line <code>index out of bounds: the len is 1 but the index is 1</code> is an error
message intended for programmers. It won’t help our end users understand what
happened and what they should do instead. Let’s fix that now.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#improving-the-error-message" id="improving-the-error-message"><h4>Improving the Error Message</h4></a>
<p>In Listing 12-8, we add a check in the <code>new</code> function that will verify that the
slice is long enough before accessing index <code>1</code> and <code>2</code>. If the slice isn’t
long enough, the program panics and displays a better error message than the
<code>index out of bounds</code> message.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--
fn new(args: &amp;[String]) -&gt; Config {
    if args.len() &lt; 3 {
        panic!(&quot;not enough arguments&quot;);
    }
    // --snip--
</code></pre>
<p><span class="caption">Listing 12-8: Adding a check for the number of
arguments</span></p>
<p>This code is similar to the <code>Guess::new</code> function we wrote in Listing 9-9, where
we called <code>panic!</code> when the <code>value</code> argument was out of the range of valid
values. Instead of checking for a range of values here, we’re checking that the
length of <code>args</code> is at least <code>3</code> and the rest of the function can operate under
the assumption that this condition has been met. If <code>args</code> has fewer than three
items, this condition will be true, and we call the <code>panic!</code> macro to end the
program immediately.</p>
<p>With these extra few lines of code in <code>new</code>, let’s run the program without any
arguments again to see what the error looks like now:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:30:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>This output is better: we now have a reasonable error message. However, we also
have extraneous information we don’t want to give to our users. Perhaps using
the technique we used in Listing 9-9 isn’t the best to use here: a call to
<code>panic!</code> is more appropriate for a programming problem rather than a usage
problem, as discussed in Chapter 9. Instead, we can use the other technique you
learned about in Chapter 9—returning a <code>Result</code> that indicates either success
or an error.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#returning-a-result-from-new-instead-of-calling-panic" id="returning-a-result-from-new-instead-of-calling-panic"><h4>Returning a <code>Result</code> from <code>new</code> Instead of Calling <code>panic!</code></h4></a>
<p>We can instead return a <code>Result</code> value that will contain a <code>Config</code> instance in
the successful case and will describe the problem in the error case. When
<code>Config::new</code> is communicating to <code>main</code>, we can use the <code>Result</code> type to
signal there was a problem. Then we can change <code>main</code> to convert an <code>Err</code>
variant into a more practical error for our users without the surrounding text
about <code>thread 'main'</code> and <code>RUST_BACKTRACE</code> that a call to <code>panic!</code> causes.</p>
<p>Listing 12-9 shows the changes we need to make to the return value of
<code>Config::new</code> and the body of the function needed to return a <code>Result</code>. Note
that this won’t compile until we update <code>main</code> as well, which we’ll do in the
next listing.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
</code></pre>
<p><span class="caption">Listing 12-9: Returning a <code>Result</code> from
<code>Config::new</code></span></p>
<p>Our <code>new</code> function now returns a <code>Result</code> with a <code>Config</code> instance in the
success case and a <code>&amp;'static str</code> in the error case. Recall from “The Static
Lifetime” section in Chapter 10 that <code>&amp;'static str</code> is the type of string
literals, which is our error message type for now.</p>
<p>We’ve made two changes in the body of the <code>new</code> function: instead of calling
<code>panic!</code> when the user doesn’t pass enough arguments, we now return an <code>Err</code>
value, and we’ve wrapped the <code>Config</code> return value in an <code>Ok</code>. These changes
make the function conform to its new type signature.</p>
<p>Returning an <code>Err</code> value from <code>Config::new</code> allows the <code>main</code> function to
handle the <code>Result</code> value returned from the <code>new</code> function and exit the process
more cleanly in the error case.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#calling-confignew-and-handling-errors" id="calling-confignew-and-handling-errors"><h4>Calling <code>Config::new</code> and Handling Errors</h4></a>
<p>To handle the error case and print a user-friendly message, we need to update
<code>main</code> to handle the <code>Result</code> being returned by <code>Config::new</code>, as shown in
Listing 12-10. We’ll also take the responsibility of exiting the command line
tool with a nonzero error code from <code>panic!</code> and implement it by hand. A
nonzero exit status is a convention to signal to the process that called our
program that the program exited with an error state.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
</code></pre>
<p><span class="caption">Listing 12-10: Exiting with an error code if creating a
new <code>Config</code> fails</span></p>
<p>In this listing, we’ve used a method we haven’t covered before:
<code>unwrap_or_else</code>, which is defined on <code>Result&lt;T, E&gt;</code> by the standard library.
Using <code>unwrap_or_else</code> allows us to define some custom, non-<code>panic!</code> error
handling. If the <code>Result</code> is an <code>Ok</code> value, this method’s behavior is similar
to <code>unwrap</code>: it returns the inner value <code>Ok</code> is wrapping. However, if the value
is an <code>Err</code> value, this method calls the code in the <em>closure</em>, which is an
anonymous function we define and pass as an argument to <code>unwrap_or_else</code>. We’ll
cover closures in more detail in Chapter 13. For now, you just need to know
that <code>unwrap_or_else</code> will pass the inner value of the <code>Err</code>, which in this
case is the static string <code>not enough arguments</code> that we added in Listing 12-9,
to our closure in the argument <code>err</code> that appears between the vertical pipes.
The code in the closure can then use the <code>err</code> value when it runs.</p>
<p>We’ve added a new <code>use</code> line to import <code>process</code> from the standard library. The
code in the closure that will be run in the error case is only two lines: we
print the <code>err</code> value and then call <code>process::exit</code>. The <code>process::exit</code>
function will stop the program immediately and return the number that was
passed as the exit status code. This is similar to the <code>panic!</code>-based handling
we used in Listing 12-8, but we no longer get all the extra output. Let’s try
it:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48 secs
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>Great! This output is much friendlier for our users.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#extracting-logic-from-main" id="extracting-logic-from-main"><h3>Extracting Logic from <code>main</code></h3></a>
<p>Now that we’ve finished refactoring the configuration parsing, let’s turn to
the program’s logic. As we stated in “Separation of Concerns for Binary
Projects”, we’ll extract a function named <code>run</code> that will hold all the logic
currently in the <code>main</code> function that isn’t involved with setting up
configuration or handling errors. When we’re done, <code>main</code> will be concise and
easy to verify by inspection, and we’ll be able to write tests for all the
other logic.</p>
<p>Listing 12-11 shows the extracted <code>run</code> function. For now, we’re just making
the small, incremental improvement of extracting the function. We’re still
defining the function in <em>src/main.rs</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    run(config);
}

fn run(config: Config) {
    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)
        .expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}

// --snip--
</code></pre>
<p><span class="caption">Listing 12-11: Extracting a <code>run</code> function containing the
rest of the program logic</span></p>
<p>The <code>run</code> function now contains all the remaining logic from <code>main</code>, starting
from reading the file. The <code>run</code> function takes the <code>Config</code> instance as an
argument.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#returning-errors-from-the-run-function" id="returning-errors-from-the-run-function"><h4>Returning Errors from the <code>run</code> Function</h4></a>
<p>With the remaining program logic separated into the <code>run</code> function, we can
improve the error handling, as we did with <code>Config::new</code> in Listing 12-9.
Instead of allowing the program to panic by calling <code>expect</code>, the <code>run</code>
function will return a <code>Result&lt;T, E&gt;</code> when something goes wrong. This will let
us further consolidate into <code>main</code> the logic around handling errors in a
user-friendly way. Listing 12-12 shows the changes we need to make to the
signature and body of <code>run</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;

// --snip--

fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    println!(&quot;With text:\n{}&quot;, contents);

    Ok(())
}
</code></pre>
<p><span class="caption">Listing 12-12: Changing the <code>run</code> function to return
<code>Result</code></span></p>
<p>We’ve made three significant changes here. First, we changed the return type of
the <code>run</code> function to <code>Result&lt;(), Box&lt;Error&gt;&gt;</code>. This function previously
returned the unit type, <code>()</code>, and we keep that as the value returned in the
<code>Ok</code> case.</p>
<p>For the error type, we used the <em>trait object</em> <code>Box&lt;Error&gt;</code> (and we’ve brought
<code>std::error::Error</code> into scope with a <code>use</code> statement at the top). We’ll cover
trait objects in Chapter 17. For now, just know that <code>Box&lt;Error&gt;</code> means the
function will return a type that implements the <code>Error</code> trait, but we don’t
have to specify what particular type the return value will be. This gives us
flexibility to return error values that may be of different types in different
error cases.</p>
<p>Second, we’ve removed the calls to <code>expect</code> in favor of <code>?</code>, as we talked about
in Chapter 9. Rather than <code>panic!</code> on an error, <code>?</code> will return the error value
from the current function for the caller to handle.</p>
<p>Third, the <code>run</code> function now returns an <code>Ok</code> value in the success case. We’ve
declared the <code>run</code> function’s success type as <code>()</code> in the signature, which
means we need to wrap the unit type value in the <code>Ok</code> value. This <code>Ok(())</code>
syntax might look a bit strange at first, but using <code>()</code> like this is the
idiomatic way to indicate that we’re calling <code>run</code> for its side effects only;
it doesn’t return a value we need.</p>
<p>When you run this code, it will compile but will display a warning:</p>
<pre><code class="language-text">warning: unused `std::result::Result` which must be used
  -[!!!REMOVE THIS!!!]-&gt; src/main.rs:18:5
   |
18 |     run(config);
   |     ^^^^^^^^^^^^
= note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Rust tells us that our code ignored the <code>Result</code> value and the <code>Result</code> value
might indicate that an error occurred. But we’re not checking to see whether or
not there was an error, and the compiler reminds us that we probably meant to
have some error handling code here! Let’s rectify that problem now.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#handling-errors-returned-from-run-in-main" id="handling-errors-returned-from-run-in-main"><h4>Handling Errors Returned from <code>run</code> in <code>main</code></h4></a>
<p>We’ll check for errors and handle them using a technique similar to one we used
with <code>Config::new</code> in Listing 12-10, but with a slight difference:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p>We use <code>if let</code> rather than <code>unwrap_or_else</code> to check whether <code>run</code> returns an
<code>Err</code> value and call <code>process::exit(1)</code> if it does. The <code>run</code> function doesn’t
return a value that we want to <code>unwrap</code> in the same way that <code>Config::new</code>
returns the <code>Config</code> instance. Because <code>run</code> returns <code>()</code> in the success case,
we only care about detecting an error, so we don’t need <code>unwrap_or_else</code> to
return the unwrapped value because it would only be <code>()</code>.</p>
<p>The bodies of the <code>if let</code> and the <code>unwrap_or_else</code> functions are the same in
both cases: we print the error and exit.</p>
<a class="header" href="ch12-03-improving-error-handling-and-modularity.html#splitting-code-into-a-library-crate" id="splitting-code-into-a-library-crate"><h3>Splitting Code into a Library Crate</h3></a>
<p>Our <code>minigrep</code> project is looking good so far! Now we’ll split the
<em>src/main.rs</em> file and put some code into the <em>src/lib.rs</em> file so we can test
it and have a <em>src/main.rs</em> file with fewer responsibilities.</p>
<p>Let’s move all the code that isn’t the <code>main</code> function from <em>src/main.rs</em> to
<em>src/lib.rs</em>:</p>
<ul>
<li>The <code>run</code> function definition</li>
<li>The relevant <code>use</code> statements</li>
<li>The definition of <code>Config</code></li>
<li>The <code>Config::new</code> function definition</li>
</ul>
<p>The contents of <em>src/lib.rs</em> should have the signatures shown in Listing 12-13
(we’ve omitted the bodies of the functions for brevity). Note that this won’t
compile until we modify <em>src/main.rs</em> in the listing after this one.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    // --snip--
}
</code></pre>
<p><span class="caption">Listing 12-13: Moving <code>Config</code> and <code>run</code> into
<em>src/lib.rs</em></span></p>
<p>We’ve made liberal use of the <code>pub</code> keyword: on <code>Config</code>, on its fields and its
<code>new</code> method, and on the <code>run</code> function. We now have a library crate that has a
public API that we can test!</p>
<p>Now we need to bring the code we moved to <em>src/lib.rs</em> into the scope of the
binary crate in <em>src/main.rs</em>, as shown in Listing 12-14:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate minigrep;

use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
    if let Err(e) = minigrep::run(config) {
        // --snip--
    }
}
</code></pre>
<p><span class="caption">Listing 12-14: Bringing the <code>minigrep</code> crate into the
scope of <em>src/main.rs</em></span></p>
<p>To bring the library crate into the binary crate, we use <code>extern crate minigrep</code>. Then we add a <code>use minigrep::Config</code> line to bring the <code>Config</code> type
into scope, and we prefix the <code>run</code> function with our crate name. Now all the
functionality should be connected and should work. Run the program with <code>cargo run</code> and make sure everything works correctly.</p>
<p>Whew! That was a lot of work, but we’ve set ourselves up for success in the
future. Now it’s much easier to handle errors, and we’ve made the code more
modular. Almost all of our work will be done in <em>src/lib.rs</em> from here on out.</p>
<p>Let’s take advantage of this newfound modularity by doing something that would
have been difficult with the old code but is easy with the new code: we’ll
write some tests!
--&gt;</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch12-02-reading-a-file.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch12-04-testing-the-librarys-functionality.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch12-02-reading-a-file.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch12-04-testing-the-librarys-functionality.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
