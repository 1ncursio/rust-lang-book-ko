<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title> - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <style>
            .page-wrapper.has-warning > .nav-chapters {
              /* add height for warning content & margin */
              top: 120px;
            }

            p.warning {
                background-color: rgb(242, 222, 222);
                border-bottom-color: rgb(238, 211, 215);
                border-bottom-left-radius: 4px;
                border-bottom-right-radius: 4px;
                border-bottom-style: solid;
                border-bottom-width: 0.666667px;
                border-image-outset: 0 0 0 0;
                border-image-repeat: stretch stretch;
                border-image-slice: 100% 100% 100% 100%;
                border-image-source: none;
                border-image-width: 1 1 1 1;
                border-left-color: rgb(238, 211, 215);
                border-left-style: solid;
                border-left-width: 0.666667px;
                border-right-color: rgb(238, 211, 215);
                border-right-style: solid;
                border-right-width: 0.666667px;
                border-top-color: rgb(238, 211, 215);
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                border-top-style: solid;
                border-top-width: 0.666667px;
                color: rgb(185, 74, 72);
                margin-bottom: 0px;
                margin-left: 0px;
                margin-right: 0px;
                margin-top: 30px;
                padding-bottom: 8px;
                padding-left: 14px;
                padding-right: 35px;
                padding-top: 8px;
            }
            p.warning strong {
                color: rgb(185, 74, 72)
            }
            p.warning a {
                color: rgb(0, 136, 204)
            }
        </style>

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="ch01-00-introduction.html"><strong>1.</strong> Introduction</a></li><li><ul class="section"><li><a href="ch01-01-installation.html"><strong>1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong>1.2.</strong> Hello, World!</a></li></ul></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong>2.</strong> 추리 게임 튜토리얼</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong>3.</strong> 보편적인 프로그래밍 개념</a></li><li><ul class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong>3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong>3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong>3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong>3.5.</strong> Control Flow</a></li></ul></li><li><a href="ch04-00-understanding-ownership.html"><strong>4.</strong> 소유권 이해하기</a></li><li><ul class="section"><li><a href="ch04-01-what-is-ownership.html"><strong>4.1.</strong> 소유권이 뭔가요?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong>4.2.</strong> 참조자와 빌림</a></li><li><a href="ch04-03-slices.html"><strong>4.3.</strong> 슬라이스</a></li></ul></li><li><a href="ch05-00-structs.html"><strong>5.</strong> 연관된 데이터들을 구조체로 다루기</a></li><li><ul class="section"><li><a href="ch05-01-defining-structs.html"><strong>5.1.</strong> 구조체를 정의하고 생성하기</a></li><li><a href="ch05-02-example-structs.html"><strong>5.2.</strong> An Example Program Using Structs</a></li><li><a href="ch05-03-method-syntax.html"><strong>5.3.</strong> Method Syntax</a></li></ul></li><li><a href="ch06-00-enums.html"><strong>6.</strong> 열거형과 패턴 매칭</a></li><li><ul class="section"><li><a href="ch06-01-defining-an-enum.html"><strong>6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong>6.2.</strong> The <code>match</code> Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong>6.3.</strong> Concise Control Flow with <code>if let</code></a></li></ul></li><li><a href="ch07-00-modules.html"><strong>7.</strong> 모듈</a></li><li><ul class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong>7.1.</strong> <code>mod</code>와 파일 시스템</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong>7.2.</strong> <code>pub</code>으로 가시성 제어하기</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong>7.3.</strong> <code>use</code>로 이름 가져오기</a></li></ul></li><li><a href="ch08-00-common-collections.html"><strong>8.</strong> 일반적인 컬렉션</a></li><li><ul class="section"><li><a href="ch08-01-vectors.html"><strong>8.1.</strong> 벡터</a></li><li><a href="ch08-02-strings.html"><strong>8.2.</strong> 스트링</a></li><li><a href="ch08-03-hash-maps.html"><strong>8.3.</strong> 해쉬맵</a></li></ul></li><li><a href="ch09-00-error-handling.html"><strong>9.</strong> 에러 처리</a></li><li><ul class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong>9.1.</strong> <code>panic!</code>과 함께하는 복구 불가능한 에러</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong>9.2.</strong> <code>Result</code>와 함께하는 복구 가능한 에러</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong>9.3.</strong> <code>panic!</code>이냐, <code>panic!</code>이 아니냐, 그것이 문제로다</a></li></ul></li><li><a href="ch10-00-generics.html"><strong>10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ul class="section"><li><a href="ch10-01-syntax.html"><strong>10.1.</strong> Generic Data Types</a></li><li><a href="ch10-02-traits.html"><strong>10.2.</strong> Traits: Defining Shared Behavior</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong>10.3.</strong> Validating References with Lifetimes</a></li></ul></li><li><a href="ch11-00-testing.html"><strong>11.</strong> Testing</a></li><li><ul class="section"><li><a href="ch11-01-writing-tests.html"><strong>11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong>11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong>11.3.</strong> Test Organization</a></li></ul></li><li><a href="ch12-00-an-io-project.html"><strong>12.</strong> An I/O Project</a></li><li><ul class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong>12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong>12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong>12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong>12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong>12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong>12.6.</strong> Writing to <code>stderr</code> instead of <code>stdout</code></a></li></ul></li><li><a href="ch13-00-functional-features.html"><strong>13.</strong> Functional Language Features in Rust</a></li><li><ul class="section"><li><a href="ch13-01-closures.html"><strong>13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong>13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong>13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong>13.4.</strong> Performance</a></li></ul></li><li><a href="ch14-00-more-about-cargo.html"><strong>14.</strong> More about Cargo and Crates.io</a></li><li><ul class="section"><li><a href="ch14-01-release-profiles.html"><strong>14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong>14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong>14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong>14.4.</strong> Installing Binaries from Crates.io with <code>cargo install</code></a></li><li><a href="ch14-05-extending-cargo.html"><strong>14.5.</strong> Extending Cargo with Custom Commands</a></li></ul></li><li><a href="ch15-00-smart-pointers.html"><strong>15.</strong> Smart Pointers</a></li><li><ul class="section"><li><a href="ch15-01-box.html"><strong>15.1.</strong> <code>Box&lt;T&gt;</code> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong>15.2.</strong> The <code>Deref</code> Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong>15.3.</strong> The <code>Drop</code> Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong>15.4.</strong> <code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong>15.5.</strong> <code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong>15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ul></li><li><a href="ch16-00-concurrency.html"><strong>16.</strong> Fearless Concurrency</a></li><li><ul class="section"><li><a href="ch16-01-threads.html"><strong>16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong>16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong>16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong>16.4.</strong> Extensible Concurrency: <code>Sync</code> and <code>Send</code></a></li></ul></li><li><a href="ch17-00-oop.html"><strong>17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ul class="section"><li><a href="ch17-01-what-is-oo.html"><strong>17.1.</strong> What Does Object-Oriented Mean?</a></li><li><a href="ch17-02-trait-objects.html"><strong>17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong>17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ul></li><li><a href="ch18-00-patterns.html"><strong>18.</strong> Patterns Match the Structure of Values</a></li><li><ul class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong>18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="ch18-02-refutability.html"><strong>18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong>18.3.</strong> All the Pattern Syntax</a></li></ul></li><li><a href="ch19-00-advanced-features.html"><strong>19.</strong> Advanced Features</a></li><li><ul class="section"><li><a href="ch19-01-unsafe-rust.html"><strong>19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong>19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong>19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html"><strong>19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong>19.5.</strong> Advanced Functions &amp; Closures</a></li></ul></li><li><a href="ch20-00-final-project-a-web-server.html"><strong>20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ul class="section"><li><a href="ch20-01-single-threaded.html"><strong>20.1.</strong> A Single Threaded Web Server</a></li><li><a href="ch20-02-slow-requests.html"><strong>20.2.</strong> How Slow Requests Affect Throughput</a></li><li><a href="ch20-03-designing-the-interface.html"><strong>20.3.</strong> Designing the Thread Pool Interface</a></li><li><a href="ch20-04-storing-threads.html"><strong>20.4.</strong> Creating the Thread Pool and Storing Threads</a></li><li><a href="ch20-05-sending-requests-via-channels.html"><strong>20.5.</strong> Sending Requests to Threads Via Channels</a></li><li><a href="ch20-06-graceful-shutdown-and-cleanup.html"><strong>20.6.</strong> Graceful Shutdown and Cleanup</a></li></ul></li><li><a href="appendix-00.html"><strong>21.</strong> Appendix</a></li><li><ul class="section"><li><a href="appendix-01-keywords.html"><strong>21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong>21.2.</strong> B - Operators</a></li><li><strong>21.3.</strong> C - Derivable Traits</li><li><strong>21.4.</strong> D - Nightly Rust</li><li><strong>21.5.</strong> E - Macros</li><li><strong>21.6.</strong> F - Translations</li><li><a href="appendix-07-newest-features.html"><strong>21.7.</strong> G - Newest Features</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper has-warning">

            <div class="page">
                <header><p class="warning">You are reading a <strong>draft</strong> of the next edition of TRPL. For more, go <a href="../index.html">here</a>.</p></header>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>


                <div id="content" class="content">
                    <a class="header" href="print.html#introduction" id="introduction"><h1>Introduction</h1></a>
<p>Welcome to “The Rust Programming Language,” an introductory book about Rust.
Rust is a programming language that’s focused on safety, speed, and
concurrency. Its design lets you create programs that have the performance and
control of a low-level language, but with the powerful abstractions of a
high-level language. These properties make Rust suitable for programmers who
have experience in languages like C and are looking for a safer alternative, as
well as those from languages like Python who are looking for ways to write code
that performs better without sacrificing expressiveness.</p>
<p>Rust performs the majority of its safety checks and memory management decisions
at compile time, so that your program's runtime performance isn't impacted. This
makes it useful in a number of use cases that other languages aren’t good at:
programs with predictable space and time requirements, embedding in other
languages, and writing low-level code, like device drivers and operating
systems. It's also great for web applications: it powers the Rust package
registry site, <a href="https://crates.io/">crates.io</a>!  We're excited to see what <em>you</em> create with Rust.</p>
<p>This book is written for a reader who already knows how to program in at least
one programming language. After reading this book, you should be comfortable
writing Rust programs. We’ll be learning Rust through small, focused examples
that build on each other to demonstrate how to use various features of Rust as
well as how they work behind the scenes.</p>
<a class="header" href="print.html#contributing-to-the-book" id="contributing-to-the-book"><h2>Contributing to the book</h2></a>
<p>This book is open source. If you find an error, please don’t hesitate to file an
issue or send a pull request <a href="https://github.com/rust-lang/book">on GitHub</a>. Please see <a href="https://github.com/rust-lang/book/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a> for
more details.</p>
<a class="header" href="print.html#installation" id="installation"><h2>Installation</h2></a>
<p>The first step to using Rust is to install it. You’ll need an internet
connection to run the commands in this chapter, as we’ll be downloading Rust
from the internet.</p>
<p>We’ll be showing off a number of commands using a terminal, and those lines all
start with <code>$</code>. You don't need to type in the <code>$</code> character; they are there to indicate
the start of each command. You’ll see many tutorials and examples around the web
that follow this convention: <code>$</code> for commands run as a regular user, and <code>#</code>
for commands you should be running as an administrator. Lines that don't start
with <code>$</code> are typically showing the output of the previous command.</p>
<a class="header" href="print.html#installing-on-linux-or-mac" id="installing-on-linux-or-mac"><h3>Installing on Linux or Mac</h3></a>
<p>If you're on Linux or a Mac, all you need to do is open a terminal and type
this:</p>
<pre><code class="language-text">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>This will download a script and start the installation. You may be prompted for
your password. If it all goes well, you’ll see this appear:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>Of course, if you disapprove of the <code>curl | sh</code> pattern, you can download, inspect
and run the script however you like.</p>
<a class="header" href="print.html#installing-on-windows" id="installing-on-windows"><h3>Installing on Windows</h3></a>
<p>On Windows, go to <a href="https://rustup.rs/">https://rustup.rs</a><!-- ignore --> and
follow the instructions to download rustup-init.exe. Run that and follow the
rest of the instructions it gives you.</p>
<p>The rest of the Windows-specific commands in the book will assume that you are
using <code>cmd</code> as your shell. If you use a different shell, you may be able to run
the same commands that Linux and Mac users do. If neither work, consult the
documentation for the shell you are using.</p>
<a class="header" href="print.html#custom-installations" id="custom-installations"><h3>Custom installations</h3></a>
<p>If you have reasons for preferring not to use rustup.rs, please see <a href="https://www.rust-lang.org/install.html">the Rust
installation page</a> for other options.</p>
<a class="header" href="print.html#updating" id="updating"><h3>Updating</h3></a>
<p>Once you have Rust installed, updating to the latest version is easy.
From your shell, run the update script:</p>
<pre><code class="language-text">$ rustup update
</code></pre>
<a class="header" href="print.html#uninstalling" id="uninstalling"><h3>Uninstalling</h3></a>
<p>Uninstalling Rust is as easy as installing it. From your shell, run
the uninstall script:</p>
<pre><code class="language-text">$ rustup self uninstall
</code></pre>
<a class="header" href="print.html#troubleshooting" id="troubleshooting"><h3>Troubleshooting</h3></a>
<p>If you've got Rust installed, you can open up a shell, and type this:</p>
<pre><code class="language-text">$ rustc --version
</code></pre>
<p>You should see the version number, commit hash, and commit date in a format
similar to this for the latest stable version at the time you install:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>If you see this, Rust has been installed successfully!
Congrats!</p>
<p>If you don't and you're on Windows, check that Rust is in your <code>%PATH%</code> system
variable.</p>
<p>If it still isn't working, there are a number of places where you can get help.
The easiest is <a href="irc://irc.mozilla.org/#rust">the #rust IRC channel on irc.mozilla.org</a><!-- ignore -->,
which you can access through <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Go to that address, and you'll
be chatting with other Rustaceans (a silly nickname we call ourselves) who can
help you out. Other great resources include <a href="https://users.rust-lang.org/">the Users forum</a> and
<a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<a class="header" href="print.html#local-documentation" id="local-documentation"><h3>Local documentation</h3></a>
<p>The installer also includes a copy of the documentation locally, so you can
read it offline. Run <code>rustup doc</code> to open the local documentation in your
browser.</p>
<p>Any time there's a type or function provided by the standard library and you're
not sure what it does, use the API documentation to find out!</p>
<a class="header" href="print.html#hello-world" id="hello-world"><h2>Hello, World!</h2></a>
<p>Now that you have Rust installed, let’s write your first Rust program. It's
traditional when learning a new language to write a little program to print the
text “Hello, world!” to the screen, and in this section, we'll follow that
tradition.</p>
<blockquote>
<p>Note: This book assumes basic familiarity with the command line. Rust itself
makes no specific demands about your editing, tooling, or where your code
lives, so if you prefer an IDE to the command line, feel free to use your
favorite IDE.</p>
</blockquote>
<a class="header" href="print.html#creating-a-project-directory" id="creating-a-project-directory"><h3>Creating a Project Directory</h3></a>
<p>First, make a directory to put your Rust code in. Rust doesn't care where your code
lives, but for this book, we'd suggest making a <em>projects</em> directory in your
home directory and keeping all your projects there. Open a terminal and enter
the following commands to make a directory for this particular project:</p>
<p>Linux and Mac:</p>
<pre><code class="language-text">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>Windows CMD:</p>
<pre><code class="language-cmd">&gt; mkdir %USERPROFILE%\projects
&gt; cd %USERPROFILE%\projects
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<p>Windows PowerShell:</p>
<pre><code class="language-powershell">&gt; mkdir $env:USERPROFILE\projects
&gt; cd $env:USERPROFILE\projects
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<a class="header" href="print.html#writing-and-running-a-rust-program" id="writing-and-running-a-rust-program"><h3>Writing and Running a Rust Program</h3></a>
<p>Next, make a new source file and call it <em>main.rs</em>. Rust files always end with
the <em>.rs</em> extension. If you’re using more than one word in your filename, use
an underscore to separate them. For example, you'd use <em>hello_world.rs</em> rather
than <em>helloworld.rs</em>.</p>
<p>Now open the <em>main.rs</em> file you just created, and type the following code:</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Save the file, and go back to your terminal window. On Linux or OSX, enter the
following commands:</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>On Windows, run <code>.\main.exe</code> instead of <code>./main</code>. Regardless of your
operating system, you should see the string <code>Hello, world!</code> print to the
terminal. If you did, then congratulations! You've officially written a Rust
program. That makes you a Rust programmer! Welcome!</p>
<a class="header" href="print.html#anatomy-of-a-rust-program" id="anatomy-of-a-rust-program"><h3>Anatomy of a Rust Program</h3></a>
<p>Now, let’s go over what just happened in your &quot;Hello, world!&quot; program in
detail. Here's the first piece of the puzzle:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>These lines define a <em>function</em> in Rust. The <code>main</code> function is special: it's
the first thing that is run for every executable Rust program. The first line
says, “I’m declaring a function named <code>main</code> that has no parameters and returns
nothing.” If there were parameters, their names would go inside the
parentheses, <code>(</code> and <code>)</code>.</p>
<p>Also note that the function body is wrapped in curly braces, <code>{</code> and <code>}</code>. Rust
requires these around all function bodies. It's considered good style to put
the opening curly brace on the same line as the function declaration, with one
space in between.</p>
<p>Inside the <code>main</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;Hello, world!&quot;);
#}</code></pre></pre>
<p>This line does all of the work in this little program: it prints text to the
screen. There are a number of details to notice here. The first is that Rust
style is to indent with four spaces, not a tab.</p>
<p>The second important part is <code>println!</code>. This is calling a Rust <em>macro</em>,
which is how metaprogramming is done in Rust. If it were calling a function
instead, it would look like this: <code>println</code> (without the <code>!</code>). We'll discuss
Rust macros in more detail in Appendix E, but for now you just need to know
that when you see a <code>!</code> that means that you’re calling a macro instead of a
normal function.</p>
<p>Next is <code>&quot;Hello, world!&quot;</code> which is a <em>string</em>. We pass this string as an
argument to <code>println!</code>, which prints the string to the screen. Easy enough!</p>
<p>The line ends with a semicolon (<code>;</code>). The <code>;</code> indicates that this expression is
over, and the next one is ready to begin. Most lines of Rust code end with a
<code>;</code>.</p>
<a class="header" href="print.html#compiling-and-running-are-separate-steps" id="compiling-and-running-are-separate-steps"><h3>Compiling and Running Are Separate Steps</h3></a>
<p>In &quot;Writing and Running a Rust Program&quot;, we showed you how to run a newly
created program. We'll break that process down and examine each step now.</p>
<p>Before running a Rust program, you have to compile it. You can use the Rust
compiler by entering the <code>rustc</code> command and passing it the name of your source
file, like this:</p>
<pre><code class="language-text">$ rustc main.rs
</code></pre>
<p>If you come from a C or C++ background, you'll notice that this is similar to
<code>gcc</code> or <code>clang</code>. After compiling successfully, Rust should output a binary
executable, which you can see on Linux or OSX by entering the <code>ls</code> command in
your shell as follows:</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<p>On Windows, you'd enter:</p>
<pre><code class="language-cmd">&gt; dir /B %= the /B option says to only show the file names =%
main.exe
main.rs
</code></pre>
<p>This shows we have two files: the source code, with the <em>.rs</em> extension, and the
executable (<em>main.exe</em> on Windows, <em>main</em> everywhere else). All that's left to
do from here is run the <em>main</em> or <em>main.exe</em> file, like this:</p>
<pre><code class="language-text">$ ./main  # or .\main.exe on Windows
</code></pre>
<p>If <em>main.rs</em> were your &quot;Hello, world!&quot; program, this would print <code>Hello, world!</code> to your terminal.</p>
<p>If you come from a dynamic language like Ruby, Python, or JavaScript, you may
not be used to compiling and running a program being separate steps. Rust is an
<em>ahead-of-time compiled</em> language, which means that you can compile a program,
give it to someone else, and they can run it even without having Rust
installed. If you give someone a <code>.rb</code>, <code>.py</code>, or <code>.js</code> file, on the other
hand, they need to have a Ruby, Python, or JavaScript implementation installed
(respectively), but you only need one command to both compile and run your
program. Everything is a tradeoff in language design.</p>
<p>Just compiling with <code>rustc</code> is fine for simple programs, but as your project
grows, you'll want to be able to manage all of the options your project has
and make it easy to share your code with other people and projects. Next, we'll
introduce you to a tool called Cargo, which will help you write real-world Rust
programs.</p>
<a class="header" href="print.html#hello-cargo" id="hello-cargo"><h2>Hello, Cargo!</h2></a>
<p>Cargo is Rust’s build system and package manager, and Rustaceans use Cargo to
manage their Rust projects because it makes a lot of tasks easier. For example,
Cargo takes care of building your code, downloading the libraries your code
depends on, and building those libraries. We call libraries your code needs
<em>dependencies</em>.</p>
<p>The simplest Rust programs, like the one we've written so far, don’t have any
dependencies, so right now, you'd only be using the part of Cargo that can take
care of building your code. As you write more complex Rust programs, you’ll
want to add dependencies, and if you start off using Cargo, that will be a lot
easier to do.</p>
<p>As the vast, vast majority of Rust projects use Cargo, we will assume that
you’re using it for the rest of the book. Cargo comes installed with Rust
itself, if you used the official installers as covered in the Installation
chapter. If you installed Rust through some other means, you can check if you
have Cargo installed by typing the following into your terminal:</p>
<pre><code class="language-text">$ cargo --version
</code></pre>
<p>If you see a version number, great! If you see an error like <code>command not found</code>, then you should look at the documentation for your method of
installation to determine how to install Cargo separately.</p>
<a class="header" href="print.html#creating-a-project-with-cargo" id="creating-a-project-with-cargo"><h3>Creating a Project with Cargo</h3></a>
<p>Let's create a new project using Cargo and look at how it differs from our
project in <code>hello_world</code>. Go back to your projects directory (or wherever you
decided to put your code):</p>
<p>Linux and Mac:</p>
<pre><code class="language-text">$ cd ~/projects
</code></pre>
<p>Windows:</p>
<pre><code class="language-cmd">&gt; cd %USERPROFILE%\projects
</code></pre>
<p>And then on any operating system run:</p>
<pre><code class="language-text">$ cargo new hello_cargo --bin
$ cd hello_cargo
</code></pre>
<p>We passed the <code>--bin</code> argument to <code>cargo new</code> because our goal is to make an
executable application, as opposed to a library. Executables are binary
executable files often called just <em>binaries</em>. We've given <code>hello_cargo</code>
as the name for our project, and Cargo creates its files in a directory
of the same name that we can then go into.</p>
<p>If we list the files in the <em>hello_cargo</em> directory, we can see that Cargo has
generated two files and one directory for us: a <em>Cargo.toml</em> and a <em>src</em>
directory with a <em>main.rs</em> file inside. It has also initialized a new git
repository in the <em>hello_cargo</em> directory for us, along with a <em>.gitignore</em>
file; you can change this to use a different version control system, or no
version control system, by using the <code>--vcs</code> flag.</p>
<p>Open up <em>Cargo.toml</em> in your text editor of choice. It should look something
like this:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
</code></pre>
<p>This file is in the <a href="https://github.com/toml-lang/toml"><em>TOML</em></a><!-- ignore --> (Tom's Obvious, Minimal
Language) format. TOML is similar to INI but has some extra goodies and is used
as Cargo’s configuration format.</p>
<p>The first line, <code>[package]</code>, is a section heading that indicates that the
following statements are configuring a package. As we add more information to
this file, we’ll add other sections.</p>
<p>The next three lines set the three bits of configuration that Cargo needs to
see in order to know that it should compile your program: its name, what
version it is, and who wrote it. Cargo gets your name and email information
from your environment. If it’s not correct, go ahead and fix that and save the
file.</p>
<p>The last line, <code>[dependencies]</code>, is the start of a section for you to list any
<em>crates</em> (which is what we call packages of Rust code) that your project will
depend on so that Cargo knows to download and compile those too. We won't need
any other crates for this project, but we will in the guessing game tutorial in
the next chapter.</p>
<p>Now let's look at <em>src/main.rs</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargo has generated a &quot;Hello World!&quot; for you, just like the one we wrote
earlier! So that part is the same. The differences between our previous project
and the project generated by Cargo that we've seen so far are:</p>
<ul>
<li>Our code goes in the <em>src</em> directory</li>
<li>The top level contains a <em>Cargo.toml</em> configuration file</li>
</ul>
<p>Cargo expects your source files to live inside the <em>src</em> directory so that the
top-level project directory is just for READMEs, license information,
configuration files, and anything else not related to your code. In this way,
using Cargo helps you keep your projects nice and tidy. There's a place for
everything, and everything is in its place.</p>
<p>If you started a project that doesn't use Cargo, as we did with our project in
the <em>hello_world</em> directory, you can convert it to a project that does use
Cargo by moving your code into the <em>src</em> directory and creating an appropriate
<em>Cargo.toml</em>.</p>
<a class="header" href="print.html#building-and-running-a-cargo-project" id="building-and-running-a-cargo-project"><h3>Building and Running a Cargo Project</h3></a>
<p>Now let's look at what's different about building and running your Hello World
program through Cargo! To do so, enter the following commands:</p>
<pre><code class="language-text">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
</code></pre>
<p>This should have created an executable file in <em>target/debug/hello_cargo</em> (or
<em>target\debug\hello_cargo.exe</em> on Windows), which you can run with this command:</p>
<pre><code class="language-text">$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
</code></pre>
<p>Bam! If all goes well, <code>Hello, world!</code> should print to the terminal once more.</p>
<p>Running <code>cargo build</code> for the first time also causes Cargo to create a new file
at the top level called <em>Cargo.lock</em>, which looks like this:</p>
<p><span class="filename">Filename: Cargo.lock</span></p>
<pre><code class="language-toml">[root]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
</code></pre>
<p>Cargo uses the <em>Cargo.lock</em> to keep track of dependencies in your application.
This project doesn't have dependencies, so the file is a bit sparse.
Realistically, you won't ever need to touch this file yourself; just let Cargo
handle it.</p>
<p>We just built a project with <code>cargo build</code> and ran it with
<code>./target/debug/hello_cargo</code>, but we can also use <code>cargo run</code> to compile
and then run:</p>
<pre><code class="language-text">$ cargo run
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Notice that this time, we didn't see the output telling us that Cargo was
compiling <code>hello_cargo</code>. Cargo figured out that the files haven’t changed, so
it just ran the binary. If you had modified your source code, Cargo would have
rebuilt the project before running it, and you would have seen something like
this:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>So a few more differences we've now seen:</p>
<ul>
<li>Instead of using <code>rustc</code>, build a project using <code>cargo build</code> (or build and
run it in one step with <code>cargo run</code>)</li>
<li>Instead of the result of the build being put in the same directory as our
code, Cargo will put it in the <em>target/debug</em> directory.</li>
</ul>
<p>The other advantage of using Cargo is that the commands are the same no matter
what operating system you're on, so at this point we will no longer be
providing specific instructions for Linux and Mac versus Windows.</p>
<a class="header" href="print.html#building-for-release" id="building-for-release"><h3>Building for Release</h3></a>
<p>When your project is finally ready for release, you can use <code>cargo build --release</code> to compile your project with optimizations. This will create an
executable in <em>target/release</em> instead of <em>target/debug</em>. These optimizations
make your Rust code run faster, but turning them on makes your program take
longer to compile. This is why there are two different profiles: one for
development when you want to be able to rebuild quickly and often, and one for
building the final program you’ll give to a user that won't be rebuilt and
that we want to run as fast as possible. If you're benchmarking the running
time of your code, be sure to run <code>cargo build --release</code> and benchmark with
the executable in <em>target/release</em>.</p>
<a class="header" href="print.html#cargo-as-convention" id="cargo-as-convention"><h3>Cargo as Convention</h3></a>
<p>With simple projects, Cargo doesn't provide a whole lot of value over just
using <code>rustc</code>, but it will prove its worth as you continue. With complex
projects composed of multiple crates, it’s much easier to let Cargo coordinate
the build. With Cargo, you can just run <code>cargo build</code>, and it should work the
right way. Even though this project is simple, it now uses much of the real
tooling you’ll use for the rest of your Rust career. In fact, you can get
started with virtually all Rust projects you want to work
on with the following commands:</p>
<pre><code class="language-text">$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
</code></pre>
<blockquote>
<p>Note: If you want to look at Cargo in more detail, check out the official
<a href="http://doc.crates.io/guide.html">Cargo guide</a>, which covers all of its features.</p>
</blockquote>
<a class="header" href="print.html#추리-게임" id="추리-게임"><h1>추리 게임</h1></a>
<p>실습 프로젝트를 통해 러스트를 사용해 봅시다. 이번 장은 실제 프로젝트에서 몇몇
일반적인 Rust 개념이 어떻게 활용되는지를 소개하려 합니다. 이 과정에서 <code>let</code>, <code>match</code>,
메소드, 연관함수(assiciated functions), 외부 크레이트(external crates) 등의 활용 방법을
배울 수 있습니다. 이런 개념들은 다음 장들에서 더 자세히 다뤄질 것입니다. 이번 장에서는
여러분이 직접 기초적인 내용을 실습합니다.</p>
<p>우리는 고전적인 입문자용 프로그래밍 문제인 추리 게임을 구현해 보려 합니다. 이
프로그램은 1~100 사이의 임의의 정수를 생성합니다. 다음으로 플레이어가 프로그램에 추리한
정수를 입력합니다. 프로그램은 입력받은 추리값이 정답보다 높거나 낮은지를 알려줍니다.
추리값이 정답이라면 축하 메세지를 보여주고 종료됩니다.</p>
<a class="header" href="print.html#새로운-프로젝트를-준비하기" id="새로운-프로젝트를-준비하기"><h2>새로운 프로젝트를 준비하기</h2></a>
<p>새로운 프로젝트를 준비하기 위해 1장에서 생성했던 디렉토리인 <em>projects</em> 로 이동하고
아래 예제처럼 Cargo를 이용하여 새로운 프로젝트를 생성합니다.</p>
<pre><code class="language-text">$ cargo new guessing_game --bin
$ cd guessing_game
</code></pre>
<p>첫 명령문인 <code>cargo new</code>는 프로젝트의 이름 (<code>guessing_game</code>)을 첫번째 인자로 받습니다.
<code>--bin</code> 플래그는 Cargo가 1장과 비슷하게 바이너리용 프로젝트를 생성하도록 합니다.
두번째 명령문은 작업 디렉토리를 새로운 프로젝트의 디렉토리로 변경합니다.</p>
<p>생성된 <em>Cargo.toml</em> 파일을 살펴봅시다.</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
</code></pre>
<p>만약 Cargo가 환경변수에서 가져온 author 정보가 잘못되었다면 파일을 수정하고 저장하면
됩니다.</p>
<p>1장에서 보았듯이 <code>cargo new</code>는 여러분을 위해 &quot;Hello, world!&quot; 프로그램을 생성합니다.
<em>src/main.rs</em> 파일을 살펴보면 다음과 같습니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>이제 이 &quot;Hello, world!&quot; 프로그램을 <code>cargo run</code> 명령문을 이용하여 컴파일하고 실행해
봅시다.</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p><code>run</code> 명령어는 이번 실습 프로젝트처럼 빠르게 반복(iteration)을 하고 싶을 때 유용합니다.
우리는 다음 iteartion으로 넘어가기 전 빠르게 각 iteration을 테스트하고 싶습니다.</p>
<p><em>src/main.rs</em> 를 다시 열어 두세요. 이 파일에 모든 코드를 작성할 것입니다.</p>
<a class="header" href="print.html#추리값을-처리하기" id="추리값을-처리하기"><h2>추리값을 처리하기</h2></a>
<p>프로그램의 첫 부분은 사용자 입력 요청, 입력값의 처리 후 입력값이 기대하던 형식인지
검증합니다. 첫 시작으로 플레이어가 추리한 값을 입력받을 수 있게 할 것입니다.
Listing 2-1의 코드를 <em>src/main.rs</em> 에 작성하세요.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p><span class="caption">Listing 2-1: 사용자가 추리한 값을 입력 받아 그대로 출력하는 코드</span></p>
<p>이 코드에 담긴 다양한 정보를 하나씩 살펴 보겠습니다. 사용자 입력을 받고 결과값을
표시하기 위해서는 <code>io</code> (input/output) 라이브러리를 스코프로 가져와야 합니다. <code>io</code>
라이브러리는 <code>std</code>라고 불리는 표준 라이브러리에 있습니다.</p>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<p>러스트는 모든 프로그램의 스코프에 <a href="../../std/prelude/index.html"><em>prelude</em></a><!-- ignore --> 내의 타입들을
가져옵니다. 만약 여러분이 원하는 타입이 prelude에 없다면 <code>use</code>문을 활용하여
명시적으로 그 타입을 가져와야 합니다. <code>std::io</code>는 사용자의 입력을 받는 것을
포함하여 <code>io</code>와 관련된 기능들을 제공합니다.</p>
<p>1장에서 보았듯이 <code>main</code> 함수는 프로그램의 진입점입니다.</p>
<pre><code class="language-rust ignore">fn main() {
</code></pre>
<p><code>fn</code> 문법은 새로운 함수를 선언하며 <code>()</code>는 인자가 없음을 나타내고 <code>{</code>는 함수 본문의
시작을 나타냅니다.</p>
<p>1장에서 배웠듯이 <code>println!</code>은 string을 화면에 표시하는 매크로입니다.</p>
<pre><code class="language-rust ignore">println!(&quot;Guess the number!&quot;);

println!(&quot;Please input your guess.&quot;);
</code></pre>
<p>이 코드는 게임에 대한 설명과 사용자의 입력을 요청하는 글자를 표시합니다.</p>
<a class="header" href="print.html#값을-변수에-저장하기" id="값을-변수에-저장하기"><h3>값을 변수에 저장하기</h3></a>
<p>다음으로 우리는 다음 코드처럼 사용자의 입력값을 저장할 공간을 생성할 수 있습니다.</p>
<pre><code class="language-rust ignore">let mut guess = String::new();
</code></pre>
<p>이제 프로그램이 점점 흥미로워지고 있습니다! 이 짧은 라인에서 여러 일들이 벌어집니다.
이 라인이 <em>변수</em> 를 생성하는 <code>let</code>문임을 주목하세요. 다음 코드도 변수를 선언하는
예시입니다.</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<p>이 라인은 <code>foo</code>라는 변수를 선언하고 <code>bar</code>라는 값과 묶습니다. 러스트에서
변수는 기본적으로 불변입니다. 다음 예시는 변수 앞에 <code>mut</code>을 이용하여 가변변수를
만드는 법을 보여줍니다.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foo = 5; // immutable
let mut bar = 5; // mutable
#}</code></pre></pre>
<blockquote>
<p>Note: <code>//</code> 문법은 현재 위치부터 라인의 끝까지 주석임을 나타냅니다.
러스트는 주석의 모든 내용을 무시합니다.</p>
</blockquote>
<p>이제 <code>let mut guess</code>가 <code>guess</code>라는 이름의 가변변수임을 알 수 있습니다. <code>=</code>의
반대편의 값은 <code>guess</code>와 묶이게 되는데 이번 예시에서는 함수 <code>String::new</code>의 결과값인
새로운 <code>String</code> 인스턴스가 묶이는 대상이 됩니다. <a href="../../std/string/struct.String.html"><code>String</code></a><!-- ignore -->은
표준 라이브러리에서 제공하는 확장 가능한(growable) UTF-8 인코딩의 문자열 타입입니다.</p>
<p><code>::new</code>에 있는 <code>::</code>는 <code>new</code>가 <code>String</code> 타입의 <em>연관함수</em> 임을 나타냅니다. 연관함수는
하나의 타입을 위한 함수이며, 이 경우에는 하나의 <code>String</code> 인스턴스가 아니라 <code>String</code>
타입을 위한 함수입니다. 몇몇 언어에서는 이것을 <em>정적 메소드</em> 라고 부릅니다.</p>
<p><code>new</code> 함수는 새로운 빈 <code>String</code>을 생성합니다. <code>new</code> 함수는 새로운 값을 생성하기 위한
일반적인 이름이므로 많은 타입에서 찾아볼 수 있습니다.</p>
<p>요약하자면 <code>let mut guess = String::new();</code> 라인은 새로운 빈 <code>String</code> 인스턴스와
연결된 가변변수를 생성합니다.</p>
<p>프로그램에 첫번째 라인에 <code>use std::io;</code> 를 이용하여 표준 라이브러리의 input/output
기능을 포함한 것을 떠올려 보세요. 이제 우리는 <code>io</code>의 연관함수인 <code>stdin</code>을 호출합니다.</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess)
    .expect(&quot;Failed to read line&quot;);
</code></pre>
<p>만약 프로그램 시작점에 <code>use std::io</code>가 없다면 함수 호출 시 <code>std::io::stdin</code>처럼 작성해야
합니다. <code>stdin</code> 함수는 터미널의 표준 입력의 핸들(handle)의 타입인 <a href="../../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->의
인스턴스를 돌려줍니다.</p>
<p>코드의 다음 부분인 <code>.read_line(&amp;mut guess)</code>는 사용자로부터 입력을 받기 위해 표준
입력 핸들에서 <code>.read_line(&amp;mut guess)</code> 메소드를 호출합니다. 또한 <code>read_line</code>에 <code>&amp;mut guess</code>
를 인자로 하나 넘깁니다.</p>
<p><code>read_line</code>은 사용자가 표준 입력에 입력할 때마다 입력된 문자들을 하나의 문자열에 저장하므로
인자로 값을 저장할 문자열이 필요합니다. 그 문자열 인자는 사용자 입력을 추가하면서 변경되므로
가변이어야 합니다.</p>
<p><code>&amp;</code>는 코드의 여러 부분에서 데이터를 여러 번 메모리로 복사하지 않고 접근하기 위한 방법을
제공하는 <em>참조자</em> 임을 나타냅니다. 참조자는 복잡한 특성으로서 러스트의 큰 이점 중 하나가
참조자를 사용함으로써 얻는 안전성과 용이성입니다. 이 프로그램을 작성하기 위해 참조자의
자세한 내용을 알 필요는 없습니다. 4장에서 참조자에 대해 전체적으로 설명할 것입니다.
지금 당장은 참조자가 변수처럼 기본적으로 불변임을 알기만 하면 됩니다. 따라서 가변으로
바꾸기 위해 <code>&amp;guess</code>가 아니라 <code>&amp;mut guess</code>로 작성해야 합니다.</p>
<p>아직 이 라인에 대해 다 설명하지 않았습니다. 한 라인처럼 보이지만 사실은 이 라인과 논리적으로
연결된 라인이 더 있습니다. 두번째 라인은 다음 메소드입니다.</p>
<pre><code class="language-rust ignore">.expect(&quot;Failed to read line&quot;);
</code></pre>
<p><code>.foo()</code> 형태의 문법으로 메소드를 호출할 경우 긴 라인을 나누기 위해 다음 줄과 여백을 넣는 것이
바람직합니다. 위 코드를 아래처럼 쓸 수도 있습니다.</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);
</code></pre>
<p>하지만 하나의 긴 라인은 가독성이 떨어지므로 두 개의 메소드 호출을 위한 라인으로 나누는
것이 좋습니다. 이제 이 라인이 무엇인지에 대해 이야기해 봅시다.</p>
<a class="header" href="print.html#result-타입으로-잠재된-실패-다루기" id="result-타입으로-잠재된-실패-다루기"><h3><code>Result</code> 타입으로 잠재된 실패 다루기</h3></a>
<p>이전에 언급한 것처럼 <code>read_line</code>은 우리가 인자로 넘긴 문자열에 사용자가 입력을 저장할
뿐 아니라 하나의 값을 돌려 줍니다. 여기서 돌려준 값은 <a href="../../std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->
입니다. 러스트는 표준 라이브러리에 여러 종류의 <code>Result</code> 타입을 가지고 있습니다.
제네릭 <a href="../../std/result/enum.Result.html"><code>Result</code></a><!-- ignore -->이나 <code>io:Result</code>가 그 예시입니다.</p>
<p><code>Result</code> 타입은 <a href="ch06-00-enums.html"><em>열거형(enumerations)</em></a><!-- ignore -->로써 <em>enums</em> 라고 부르기도
합니다. 열거형은 정해진 값들만을 가질 수 있으며 이러한 값들은 열거형의 <em>variants</em>
라고 부릅니다. 6장에서 열거형에 대해 더 자세히 다룹니다.</p>
<p><code>Result</code>의 variants는 <code>Ok</code>와 <code>Err</code>입니다. <code>Ok</code>는 처리가 성공했음을 나타내며 내부적으로
성공적으로 생성된 결과를 가지고 있습니다. <code>Err</code>는 처리가 실패했음을 나타내고 그
이유에 대한 정보를 가지고 있습니다.</p>
<p>이러한 <code>Result</code>는 에러 처리를 위한 정보를 표현하기 위해 사용됩니다. <code>Result</code> 타입의
값들은 다른 타입들처럼 메소드들을 가지고 있습니다. <code>io::Result</code> 인스턴스는
<a href="../../std/result/enum.Result.html#method.expect"><code>expect</code> 메소드</a><!-- ignore -->를 가지고 있습니다. 만약 <code>io::Result</code> 인스턴스가 <code>Err</code>일
경우 <code>expect</code> 메소드는 프로그램이 작동을 멈추게 하고  <code>expect</code>에 인자로 넘겼던 메세지를
출력하도록 합니다. 만약 <code>read_line</code> 메소드가 <code>Err</code>를 돌려줬다면 그 에러는 운영체제로부터
생긴 에러일 경우가 많습니다. 만약 <code>io::Result</code>가 <code>Ok</code> 값이라면 <code>expect</code>는 <code>Ok</code>가 가지고 있는
결과값을 돌려주어 사용할 수 있도록 합니다. 이 경우 결과값은 사용자가 표준 입력으로 입력했던
바이트의 개수입니다.</p>
<p>만약 <code>expect</code>를 호출하지 않는다면 컴파일은 되지만 경고가 나타납니다.</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
src/main.rs:10:5: 10:39 warning: unused result which must be used,
#[warn(unused_must_use)] on by default
src/main.rs:10     io::stdin().read_line(&amp;mut guess);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>러스트는 <code>read_line</code>가 돌려주는 <code>Result</code> 값을 사용하지 않았음을 경고하며 일어날 수 있는
에러를 처리하지 않았음을 알려줍니다. 이 경고를 없애는 옳은 방법은 에러를 처리하는 코드를
작성하는 것이지만 만약 문제가 발생했을 때 프로그램이 멈추길 바란다면 <code>expect</code>를 사용할
수 있습니다. 9장에서 에러가 발생했을 때 이를 처리하는 방법에 대해 배웁니다.</p>
<a class="header" href="print.html#println-변경자placeholder를-이용한-값-출력" id="println-변경자placeholder를-이용한-값-출력"><h3><code>println!</code> 변경자(placeholder)를 이용한 값 출력</h3></a>
<p>지금까지 작성한 코드에서 닫는 중괄호 말고도 살펴봐야 하는 코드가 하나 더 있습니다. 내용은
아래와 같습니다.</p>
<pre><code class="language-rust ignore">println!(&quot;You guessed: {}&quot;, guess);
</code></pre>
<p>이 라인은 사용자가 입력한 값을 저장한 문자열을 출력합니다. <code>{}</code>는 변경자로써 값이
표시되는 위치를 나타냅니다. <code>{}</code>를 이용하여 하나 이상의 값을 표시할 수도 있습니다.
첫번째 <code>{}</code>는 형식 문자열(format string) 이후의 첫번째 값을 표시하며, 두번째 <code>{}</code>는 두번째 값을 나타내며
이후에도 비슷하게 작동합니다. 다음 코드는 <code>println!</code>을 이용하여 여러 값을 표시하는 방법을
보여줍니다.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 10;

println!(&quot;x = {} and y = {}&quot;, x, y);
#}</code></pre></pre>
<p>이 코드는 <code>x = 5 and y = 10</code>을 출력합니다.</p>
<a class="header" href="print.html#첫번째-부분을-테스트하기" id="첫번째-부분을-테스트하기"><h3>첫번째 부분을 테스트하기</h3></a>
<p>추리 게임의 처음 부분을 테스트 해 봅시다. <code>cargo run</code>을 통해 실행할 수 있습니다.</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>지금까지 게임의 첫번째 부분을 작성했습니다. 우리는 입력값을 받고 그 값을 출력했습니다.</p>
<a class="header" href="print.html#비밀번호를-생성하기" id="비밀번호를-생성하기"><h2>비밀번호를 생성하기</h2></a>
<p>다음으로 사용자가 추리하기 위한 비밀번호를 생성해야 합니다. 게임을 다시
하더라도 재미있도록 비밀번호는 매번 달라야 합니다. 게임이 너무 어렵지 않도록
1에서 100 사이의 임의의 수를 사용합시다. 러스트는 아직 표준 라이브러리에
임의의 값을 생성하는 기능이 없습니다. 하지만 러스트 팀에서는
<a href="https://crates.io/crates/rand"><code>rand</code> 크레이트</a>를 제공합니다.</p>
<a class="header" href="print.html#크레이트crate를-사용하여-더-많은-기능-가져오기" id="크레이트crate를-사용하여-더-많은-기능-가져오기"><h3>크레이트(Crate)를 사용하여 더 많은 기능 가져오기</h3></a>
<p><em>크레이트</em>는 러스트 코드의 묶음(package)임을 기억하세요. 우리가 만들고 있는
프로젝트는 실행이 가능한 <em>binary crate</em> 입니다. <code>rand</code> crate는 다른
프로그램에서 사용되기 위한 용도인 <em>library crate</em> 입니다.</p>
<p>Cargo에서 외부 크레이트의 활용이 정말 멋진 부분입니다. <code>rand</code>를 사용하는
코드를 작성하기 전에 <em>Cargo.toml</em> 을 수정하여 <code>rand</code> 크레이트를 의존 리스트에
추가해야 합니다. 파일을 열고 Cargo가 여러분을 위해 생성한 <code>[dependencies]</code> 절의 시작
바로 아래에 다음 내용을 추가하세요.</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p><em>Cargo.toml</em> 파일에서 하나의 절의 시작 이후의 모든 내용은 그 절에 포함되며 이는 다음 절이
나타날 때까지 동일합니다.  [dependencies] 절은 여러분의 프로젝트가 의존하고 있는 외부
크레이트와 각각의 요구 버전을 Cargo에 명시하는 곳입니다. 지금의 경우 우리는 <code>rand</code>
크레이트의 유의적 버전인 <code>0.3.14</code>을 명시했습니다. Cargo는 버전을 명시하는 표준에 해당하는
<a href="http://semver.org">Semantic Versioning</a><!-- ignore -->(semver)을 이용합니다. <code>0.3.14</code>는
<code>^0.3.14</code>의 축약형이 되며 이는 버전 <code>0.3.14</code>와 호환되는 API를 제공하는
모든 버전임을 의미합니다.</p>
<p>이제 Listing 2-2처럼 코드 수정 없이 프로젝트를 빌드 해 봅시다.</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
 Downloading libc v0.2.14
   Compiling libc v0.2.14
   Compiling rand v0.3.14
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p><span class="caption">Listing 2-2: rand 크레이트를 의존성으로 추가한 후
<code>cargo build</code> 를 실행한 결과</span></p>
<p>여러분은 다른 버전명이나 라인의 순서가 다르게 보일 수 있습니다. 버전명이
다르더라도 SemVer 덕분에 현재 코드와 호환될 것입니다.</p>
<p>이제 우리는 외부 의존성을 가지게 되었고, Cargo는 <a href="https://crates.io">Crates.io</a> 데이터의
복사본인 <em>레지스트리(registry)</em> 에서 모든 것들을 가져옵니다. Cartes.io는 러스트의
생태계의 개발자들이 다른 사람들도 이용할 수 있도록 러스트 오픈소스를 공개하는 곳입니다.</p>
<p>레지스트리를 업데이트하면 Cargo는 <code>[dependencies]</code> 절을 확인하고 아직 여러분이 가지고
있지 않은 것들을 다운 받습니다. 이 경우 우리는 <code>rand</code>만 의존한다고 명시했지만 <code>rand</code>는
<code>libc</code>에 의존하기 때문에 <code>libc</code>도 다운 받습니다. 러스트는 이것들을 다운받은 후 컴파일
하여 의존성을 해결된 프로젝트를 컴파일합니다.</p>
<p>만약 아무것도 변경하지 않고 <code>cargo build</code>를 실행한다면 어떠한 결과도 얻지 못합니다.
Cargo는 이미 의존 패키지들을 다운받고 컴파일했음을 알고 있고 여러분이  <em>Cargo.toml</em>
를 변경하지 않은 것을 알고 있습니다. 또한 Cargo는 코드가 변경되지 않은 것도 알고 있기에
코드도 다시 컴파일하지 않습니다. 아무것도 할 일이 없기에 그냥 종료될 뿐입니다. 만약
여러분이 <em>src/main.rs</em> 파일을 열어 사소한 변경을 하고 저장한 후 다시 빌드를 한다면 한
라인이 출력됨을 확인할 수 있습니다.</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>이 라인은 Cargo가 <em>src/main.rs</em> 의 사소한 변경을 반영하여 빌드를 업데이트 했음을
보여줍니다. 의존 패키지가 변경되지 않았으므로 Cargo는 이미 다운받고 컴파일된 것들을
재사용할 수 있음을 알고 있습니다. 따라서 Cargo는 여러분의 코드에 해당하는 부분만을
다시 빌드합니다.</p>
<a class="header" href="print.html#재현-가능한-빌드를-보장하는-cargolock" id="재현-가능한-빌드를-보장하는-cargolock"><h4>재현 가능한 빌드를 보장하는 <em>Cargo.lock</em></h4></a>
<p>Cargo는 여러분만 아니라 다른 누구라도 여러분의 코드를 빌드할 경우 같은 산출물이
나오도록 보장하는 방법을 가지고 있습니다. Cargo는 여러분이 다른 의존성을 추가하지
전까지는 여러분이 명시한 의존 패키지만을 사용합니다. 예로 <code>rand</code> 크레이트의 다음
버전인 <code>v0.3.15</code>에서 중요한 결함이 고쳐졌지만 당신의 코드를 망치는 변경점(regression)
이 있다면 어떻게 될까요?</p>
<p>이 문제의 해결책은 여러분이 처음 <code>cargo build</code>를 수행할 때 생성되어 이제
<em>guessing_game</em> 디렉토리 내에 존재하는 <em>Cargo.lock</em> 입니다. 여러분이 처음 프로젝트를
빌드할 때 Cargo는 기준을 만족하는 모든 의존 패키지의 버전을 확인하고 <em>Cargo.lock</em> 에
이를 기록합니다. 만약 여러분이 미래에 프로젝트를 빌드할 경우 Cargo는 모든 버전들을
다시 확인하지 않고 <em>Cargo.lock</em> 파일이 존재하는지 확인하여 그 안에 명시된 버전들을
사용합니다. 이는 여러분이 재현가능한 빌드를 자동으로 가능하게 합니다. 즉 여러분의
프로젝트는 <em>Cargo.lock</em> 덕분에 당신이 명시적으로 업그레이드하지 않는 이상 <code>0.3.14</code>를
이용합니다.</p>
<a class="header" href="print.html#크레이트를-새로운-버전으로-업그레이드하기" id="크레이트를-새로운-버전으로-업그레이드하기"><h4>크레이트를 새로운 버전으로 업그레이드하기</h4></a>
<p>만약 당신이 <em>정말</em> 크레이트를 업데이트하고 싶은 경우를 위해 Cargo는 <code>update</code> 명령어를
제공합니다. 이것은</p>
<ol>
<li><em>Cargo.lock</em> 파일을 무시하고 <em>Cargo.toml</em> 에 여러분이 명시한 요구사항에 맞는 최신
버전을 확인합니다.</li>
<li>만약 이 버전들로 문제가 없다면 Cargo는 해당 버전을 <em>Cargo.lock</em> 에 기록합니다.</li>
</ol>
<p>하지만 Cargo는 기본적으로 <code>0.3.0</code>보다 크고 <code>0.4.0</code>보다 작은 버전을 찾을 것입니다.
만약 <code>rand</code> 크레이트가 새로운 두 개의 버전인 <code>0.3.15</code>와 <code>0.4.0</code>을 릴리즈했다면
여러분이 <code>cargo update</code>를 실행했을 때 다음의 메세지를 볼 것입니다.</p>
<pre><code class="language-text">$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    Updating rand v0.3.14 -&gt; v0.3.15
</code></pre>
<p>이 시점에 여러분은 <em>Cargo.lock</em> 파일에서 변경이 일어난 것과 앞으로 사용될 <code>rand</code>
크레이트의 버전이 <code>0.3.15</code>임을 확인할 수 있습니다.</p>
<p>만약 여러분이 <code>0.4.0</code>이나 <code>0.4.x</code>에 해당하는 모든 버전을 받고 싶다면 <em>Cargo.toml</em> 을
다음과 같이 업데이트해야 합니다.</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.4.0&quot;
</code></pre>
<p>다음번에 여러분이 <code>cargo build</code>를 실행하면 Cargo는 가용 가능한 크레이트들의
레지스트리를 업데이트할 것이고 여러분의 <code>rand</code>요구사항을 새롭게 명시한 버전에
따라 재계산할 것입니다.</p>
<p><a href="http://doc.crates.io">Cargo</a><!-- ignore -->와 <a href="http://doc.crates.io/crates-io.html">그의 생태계</a><!-- ignore -->에 대해
더 많은 것들은 14장에서 다뤄지지만 지금 당장은 이 정도만 알면 됩니다. Cargo는 라이브러리의
재사용을 쉽게 하여 러스트 사용자들이 많은 패키지들과 결합된 더 작은 프로젝트들을 작성할
수 있도록 도와줍니다.</p>
<a class="header" href="print.html#임의의-숫자를-생성하기" id="임의의-숫자를-생성하기"><h3>임의의 숫자를 생성하기</h3></a>
<p>이제 <code>rand</code>를 <em>사용</em> 해 봅시다. 다음 단계는 <em>src/main.rs</em> 를 Listing 2-3처럼
업데이트하면 됩니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p><span class="caption">Listing 2-3: 임의의 숫자를 생성하기 위해 필요한 코드</span></p>
<p>우리는 <code>extern crate rand;</code>을 추가하여 러스트에게 우리가 외부에 의존하는
크레이트가 있음을 알립니다. 이 라인은 <code>use rand</code>으로도 표기할 수 있으며
이제 우리는 <code>rand::</code>를 앞에 붙여 <code>rand</code>내의 모든 것을 호출할 수 있습니다.</p>
<p>다음으로 우리는 또 다른 <code>use</code> 라인인 <code>use rand::Rng</code>를 추가합니다. <code>Rng</code>는
정수 생성기가 구현한 메소드들을 정의한 trait이며 해당 메소드들을 이용하기
위해서는 반드시 스코프 내에 있어야 합니다. 10장에서 trait에 대해 더 자세히
다룰 것입니다.</p>
<p>또한 우리는 중간에 두 개의 라인을 추가합니다. <code>rand::thread_rng</code> 함수는 OS가
시드(seed)를 정하고 현재 스레드에서만 사용되는 특별한 정수생성기를 돌려
줍니다. 다음으로 우리는 <code>get_range</code> 메소드를 호출합니다. 이 메소드는
<code>Rng</code> trait에 정의되어 있으므로 <code>use rand::Rng</code> 문을 통해 스코프로 가져올
수 있습니다. <code>gen_range</code> 메소드는 두 개의 숫자를 인자로 받고 두 숫자 사이에
있는 임의의 숫자를 생성합니다. 하한선은 포함되지만 상한선은 제외되므로
1부터 100 사이의 숫자를 생성하려면 <code>1</code>과 <code>101</code>을 넘겨야 합니다.</p>
<p>크레이트에서 어떤 trait를 사용하고 어떤 함수나 메소드들을 호출하는 것을
아는 것은 단순히 <em>아는 것</em> 이 아닙니다. 각각의 크레이트의 문서에서 사용 방법을
제공합니다. Cargo의 또다른 멋진 특성은 <code>cargo doc --open</code> 명령어로써 로컬에서
여러분의 모든 의존 패키지들이 제공하는 문서들을 빌드해서 브라우저에 표시해
줍니다. 만약 <code>rand</code> 크레이트의 다른 기능들에 흥미가 있다면
<code>cargo doc --open</code>을 실행하고 왼쪽의 사이드바에 <code>rand</code>를 클릭하세요.</p>
<p>코드에 추가한 두 번째 라인은 비밀번호를 표시합니다. 이 라인은 우리가
프로그램을 개발 중일 때 테스트를 할 수 있도록 하지만 최종 버전에서는 삭제할
것입니다. 게임을 시작하자마자 정답을 출력하는 게임을 그다지 많지 않으니까요!</p>
<p>이제 프로그램을 몇 번 실행해 봅시다.</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>매 실행마다 다른 숫자면서 1부터 100 사이의 숫자가 나타나야 합니다. 잘 하셨습니다!</p>
<a class="header" href="print.html#비밀번호와-추리값을-비교하기" id="비밀번호와-추리값을-비교하기"><h2>비밀번호와 추리값을 비교하기</h2></a>
<p>이제 우리는 입력값과 임의의 정수를 가지고 있음으로 비교가 가능합니다.
Listing 2-4는 그 단계를 보여주고 있습니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p><span class="caption">Listing 2-4: 두 숫자를 비교한 결과 처리하기</span></p>
<p>처음으로 나타난 새로운 요소는 표준 라이브러리로부터 <code>std::cmp::Ordering</code>을
스코프로 가져오는 또다른 <code>use</code>입니다. <code>Ordering</code>은 <code>Result</code>와 같은
열거형이지만  <code>Ordering</code>의 값은 <code>Less</code>, <code>Greater</code>, <code>Equal</code>입니다. 이것들은
여러분이 두 개의 값을 비교할 때 나올 수 있는 결과들입니다.</p>
<p>그리고 나서 우리는 <code>Ordering</code> 타입을 이용하는 다섯 줄을 마지막에 추가 했습니다.</p>
<pre><code class="language-rust ignore">match guess.cmp(&amp;secret_number) {
    Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
    Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
    Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
}
</code></pre>
<p><code>cmp</code> 메소드는 두 값을 비교하며 비교 가능한 모든 것들에 대해 호출할 수 있습니다.
이 메소드는 비교하고 싶은 것들의 참조자를 받습니다. 여기서는 <code>guess</code>와
<code>secret_number</code>를 비교하고 있습니다. <code>cmp</code>는 <code>Ordering</code> 열거형을 돌려줍니다.
우리는 <a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> 표현문을 이용하여  <code>cmp</code>가 <code>guess</code>와
<code>secret_number</code>를 비교한 결과인 <code>Ordering</code>의 값에 따라 무엇을 할 것인지 결정할 수 있습니다.</p>
<p><code>match</code> 표현식은 <em>arm</em> 으로 이루어져 있습니다. 하나의 arm은 하나의 <em>패턴</em> 과 <code>match</code>
표현식에서 주어진 값이 패턴과 맞는다면 실행할 코드로 이루어져 있습니다.
러스트는 <code>match</code>에게 주어진 값을 arm의 패턴에 맞는지 순서대로 확인합니다. <code>match</code> 생성자와
패턴들은 여러분의 코드가 마주칠 다양한 상황을 표현할 수 있도록 하고 모든 경우의 수를
처리했음을 확신할 수 있도록 도와주는 강력한 특성들입니다. 이 기능들은 6장과 18장에서
각각 더 자세히 다뤄집니다.</p>
<p>예제서 사용된 <code>match</code> 표현식에 무엇이 일어날지 한번 따라가 봅시다. 사용자가 50을 예측했다고
하고 비밀번호가 38이라 합시다. 50과 38을 비교하면 <code>cmp</code> 메소드의 결과는 <code>Ordering::Greater</code>
입니다. <code>match</code> 표현식은 <code>Ordering::Greater</code>를 값으로 받을 것입니다. 처음으로 마주하는 arm의
패턴인 <code>Ordering::Less</code>는 <code>Ordering::Greater</code>와 매칭되지 않으므로 첫번째 arm은 무시하고 다음으로
넘어갑니다. 다음 arm의 패턴인 <code>Ordering::Greater</code>는 <em>확실히</em> <code>Ordering::Greater</code>와 매칭합니다!
arm과 연관된 코드가 실행될 것이고 <code>Too big</code>가 출력될 것입니다. 이 경우 마지막 arm은 확인할
필요가 없으므로 <code>match</code> 표현식은 끝납니다.</p>
<p>하지만 Listing 2-4의 코드는 컴파일되지 않습니다. 한번 시도해 봅시다.</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:23:21
   |
23 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |
   = note: expected type `&amp;std::string::String`
   = note:    found type `&amp;{integer}`

error: aborting due to previous error
Could not compile `guessing_game`.
</code></pre>
<p>에러의 핵심은 <em>일치하지 않는 타입</em> 이라고 있다고 알려 줍니다. 러스트는 강한 정적 타입 시스템을
가지고 있습니다. 하지만 타입 추론도 수행합니다. 만약 <code>let guess = String::new()</code>를
작성한다면 러스트는 <code>guess</code>가 <code>String</code>타입이어야 함을 추론할 수 있으므로 타입을 적으라고
하지 않습니다. 반대로 <code>secret_number</code>는 정수형입니다. 몇몇 숫자 타입들이 1과 100 사이의
값을 가질 수 있습니다. <code>i32</code>는 32비트 정수, <code>u32</code>는 32비트의 부호없는 정수, <code>i64</code>는 64비트의
정수이며 그 외에도 비슷합니다. 러스트는 기본적으로 우리가 다른 정수형임을 추론할 수 있는
다른 타입 정보를 제공하지 않는다면 숫자들은 <code>i32</code>으로 생각합니다. 이 에러의 원인은 러스트가
문자열과 정수형을 비교하지 않기 때문입니다.</p>
<p>최종적으로 우리는 추리값을 정수형으로 비교하기 위해 입력으로 받은 <code>String</code>을 정수로 바꾸고
싶을 것입니다. 이것은 <code>main</code> 함수 내에 다음 두 라인을 넣어서 할 수 있습니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse()
        .expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p>두 라인은 다음과 같습니다.</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse()
    .expect(&quot;Please type a number!&quot;);
</code></pre>
<p>우리는 <code>guess</code> 변수를 생성했습니다. 잠깐, 이미 프로그램에서 <code>guess</code>라는
이름의 변수가 생성되지 않았나요? 그렇긴 하지만 러스트는 이전에 있던
<code>guess</code>의 값을 <em>가리는(shadow)</em> 것을 허락합니다. 이 특징은 종종 하나의
값을 현재 타입에서 다른 타입으로 변환하고 싶을 경우에 사용합니다.
Shadowing은 우리들이 <code>guess_str</code>과 <code>guess</code>처럼 고유의 변수명을
만들도록 강요하는 대신 <code>guess</code>를 재사용 가능하도록 합니다.
(3장에서 더 자세한 이야기를 다룹니다)</p>
<p>우리는 <code>guess</code>를 <code>guess.trim().parse()</code> 표현식과 묶습니다. 표현식 내의
<code>guess</code>는 입력값을 가지고 있던 <code>String</code>을 참조합니다. <code>String</code> 인스턴스의
<code>trim</code> 메소드는 처음과 끝 부분의 빈칸을 제거합니다. <code>u32</code>는 정수형 글자만을
가져야 하지만 사용자들은 <code>read_line</code>을 끝내기 위해 엔터 키를 반드시 눌러야
합니다. 엔터키가 눌리는 순간 개행문자가 문자열에 추가됩니다. 만약 사용자가
5를 누르고 엔터키를 누르면 <code>guess</code>는 <code>5\n</code>처럼 됩니다. <code>\n</code>은 엔터키, 즉
개행문자를 의미합니다. <code>trim</code> 메소드는 <code>\n</code>을 제거하고 <code>5</code>만 남도록 처리합니다.</p>
<p><a href="../../std/primitive.str.html#method.parse">문자열의 <code>parse</code> 메소드</a><!-- ignore -->는 문자열을 숫자형으로 파싱합니다.
이 메소드는 다양한 종류의 정수형을 변환하므로 우리는 <code>let guess: u32</code>처럼
정확한 타입을 명시해야 합니다. <code>guess</code> 뒤의 콜론(<code>:</code>)은 변수의 타입을 명시했음을
의미합니다. 러스트는 몇몇 내장된 정수형을 가지고 있습니다. <code>u32</code>은 부호가 없는
32비트의 정수입니다. 이 타입은 작은 양수를 표현하기에는 좋은 선택입니다.
3장에서 다른 숫자형에 대해 배울 것입니다. 추가로 이 예시에서 명시했던 <code>u32</code>과
<code>secret_number</code>와의 비교는 러스트가 <code>secret_number</code>의 타입을 <code>u32</code>로 유추해야
함을 의미합니다. 이제 이 비교는 같은 타입의 두 값의 비교가 됩니다.</p>
<p><code>parse</code> 메소드의 호출은 에러가 발생하기 쉽습니다. 만약 <code>A👍%</code>과 같은 문자열이
포함되어 있다면 정수로 바꿀 방법이 없습니다. &quot;Result 타입으로 잠재된 실패 다루기&quot;에서
<code>read_line</code>와 비슷하게 <code>parse</code> 메소드는 실패할 경우를 위해 <code>Result</code> 타입을 결과로
돌려 줍니다. 만약 <code>parse</code> 메소드가 문자열에서 정수로 파싱을 실패하여 <code>Err</code> <code>Result</code>
variant를 돌려준다면 <code>expect</code> 호출은 게임을 멈추고 우리가 명시한 메세지를 출력합니다.
만약 <code>parse</code> 메소드가 성공적으로 문자열을 정수로 바꾸었다면 <code>Result</code>의 <code>Ok</code> variant를
돌려 받으므로 <code>expect</code>에서 <code>Ok</code>에서 얻고 싶었던 값을 결과로 받게 됩니다.</p>
<p>이제 프로그램을 실행해 봅시다!</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>좋습니다! 추리값 앞에 빈칸을 넣더라도 프로그램은 추리값이 76임을 파악 했습니다.
추리값이 맞을 때나 너무 클 경우, 혹은 너무 작은 경우 등 여러 종류의 입력값으로
여러 시나리오를 검증해 봅시다.</p>
<p>우리는 게임의 대부분이 동작하도록 처리 했지만 사용자는 한 번의 추리만 가능합니다.
반복문을 추가하여 변경해 봅시다!</p>
<a class="header" href="print.html#반복문을-이용하여-여러-번의-추리-허용" id="반복문을-이용하여-여러-번의-추리-허용"><h2>반복문을 이용하여 여러 번의 추리 허용</h2></a>
<p><code>loop</code> 키워드는 무한루프를 제공합니다. 이것을 이용하여 사용자들에게 숫자를
추리할 기회를 더 줍니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = guess.trim().parse()
            .expect(&quot;Please type a number!&quot;);

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
        }
    }
}
</code></pre>
<p>우리는 추리값을 입력 받는 코드부터 모든 코드들을 반복문 내로 옮겼습니다.
각각의 라인이 4간격 더 들여쓰기 되어 있음을 확실히 하고 프로그램을 다시
실행 해 보세요. 프로그램이 우리가 지시에 정확히 따르다보니 새로운 문제가
생긴 것을 확인하세요. 이제 프로그램이 영원히 다른 추리값을 요청합니다!
사용자가 이 프로그램을 종료할 수 없어요!</p>
<p>사용자는 <code>Ctrl-C</code> 단축키를 이용하여 프로그램을 멈출 수 있습니다. 하지만
&quot;비밀번호를 추리값과 비교하기&quot;에서 <code>parse</code> 메소드에 대해 논의할 때 언급한
방법으로 이 만족할 줄 모르는 괴물에게서 빠져나올 수 있습니다. 만약 사용자가
숫자가 아닌 정답을 적는다면 프로그램이 멈춥니다. 사용자는 프로그램 종료를
위해 다음처럼 이 장점을 활용할 수 있습니다.</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/guess` (exit code: 101)
</code></pre>
<p><code>quit</code>를 입력하면 게임은 확실히 끝나지만 다른 입력값들 또한 마찬가지
입니다. 하지만 이것은 최소한 차선책입니다. 우리는 정답을 입력할 경우 자동으로
게임이 끝나도록 하고 싶습니다.</p>
<a class="header" href="print.html#정답-이후에-종료하기" id="정답-이후에-종료하기"><h3>정답 이후에 종료하기</h3></a>
<p>사용자가 정답을 맞췄을 때 게임이 종료되도록 <code>break</code>문을 추가합니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = guess.trim().parse()
            .expect(&quot;Please type a number!&quot;);

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><code>break</code>문을 <code>You win!</code> 이후에 추가하여 사용자가 비밀번호를 맞췄을 때 프로그램이
반복문을 끝내도록 합니다. 반복문이 <code>main</code>의 마지막 부분이므로 반복문의 종료는
프로그램의 종료를 의미합니다.</p>
<a class="header" href="print.html#잘못된-입력값-처리하기" id="잘못된-입력값-처리하기"><h3>잘못된 입력값 처리하기</h3></a>
<p>사용자가 숫자가 아닌 값을 입력했을 때 프로그램이 종료되는 동작을 더 다듬어
숫자가 아닌 입력은 무시하여 사용자가 계속 입력할 수 있도록 해 봅시다.
<code>guess</code>가 <code>String</code>에서 <code>u32</code>로 변환되는 라인을 수정하면 됩니다.</p>
<pre><code class="language-rust ignore">let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
</code></pre>
<p><code>expect</code> 메소드 호출을 <code>match</code> 표현식으로 바꾸는 것은 에러 발생 시 종료에서 처리
로 바꾸는 일반적인 방법입니다. <code>parse</code> 메소드가 <code>Result</code> 타입을 돌려주는 것과
<code>Result</code>는 <code>Ok</code>나 <code>Err</code> variants를 가진 열거형임을 떠올리세요. <code>cmp</code> 메소드의
<code>Ordering</code> 결과를 처리했을 때처럼 여기서 <code>match</code> 표현식을 사용하고 있습니다.</p>
<p>만약 <code>parse</code>가 성공적으로 문자열에서 정수로 변환했다면 결과값을 가진 <code>Ok</code> 를
돌려줍니다. <code>Ok</code>는 첫번째 arm의 패턴과 매칭하게 되고 <code>match</code> 표현식은 <code>parse</code>
가 생성한 <code>num</code>값을 돌려줍니다. 그 값은 우리가 생성하고 있던 새로운 <code>guess</code>
과 묶이게 됩니다.</p>
<p>만약 <code>parse</code>가 문자열을 정수로 바꾸지 못했다면 에러 정보를 가진 <code>Err</code>를 돌려줍니다.
<code>Err</code>는 첫번째 arm의 패턴인  <code>Ok(num)</code>과 매칭하지 않지만 두 번째 arm의 <code>Err(_)</code>
와 매칭합니다. <code>_</code>은 모든 값과 매칭될 수 있습니다. 이 예시에서는 <code>Err</code>내에 무슨
값이 있던지에 관계없이 모든 <code>Err</code>를 매칭하도록 했습니다. 따라서 프로그램은
두 번째 arm의 코드인 <code>continue</code>를 실행하며, 이는 <code>loop</code>의 다음 반복으로 가서
또 다른 추리값을 요청하도록 합니다. 효율적으로 프로그램은 <code>parse</code>에서 가능한
모든 에러를 무시합니다.</p>
<p>이제 우리가 원하는대로 프로그램이 작동해야 합니다. <code>cargo run</code>을 실행해 봅시다.</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>멋집니다! 마지막에 조금 값을 조정하여 우리는 추리 게임을 끝냈습니다. 프로그램이
여전히 비밀번호를 출력하고 있다는 것을 떠올리세요. 테스트 때는 괜찮지만 게임을
망치게 됩니다. 비밀번호를 출력하는 <code>println!</code>을 삭제합니다. Listing 2-5는 최종 코드를
보여줍니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listing 2-5: 추리 게임의 완성된 코드<span></p>
<a class="header" href="print.html#요약" id="요약"><h2>요약</h2></a>
<p>이 시점에서 여러분은 성공적으로 추리 게임을 만들었습니다! 축하합니다!</p>
<p>이 프로젝트는 <code>let</code>, <code>match</code>, 메소드, 연관함수, 외부 크레이트 사용과 같은 많은
새로운 러스트 개념들을 소개하기 위한 실습이었습니다. 다음 장들에서는 이 개념들의
세부적인 내용을 배울 것입니다. 3장은 대부분의 프로그래밍 언어들이 가지고 있는 변수,
데이터 타입, 함수를 소개하고 러스트에서의 사용법을 다룹니다. 4장에서는 다른
프로그래밍 언어와 차별화된 러스트의 특성인 소유권을 다룹니다. 5장에서는 구조체와
메소드 문법을 다루며 6장에서는 열거형에 대해 다룹니다.</p>
<a class="header" href="print.html#보편적인-프로그래밍-개념" id="보편적인-프로그래밍-개념"><h1>보편적인 프로그래밍 개념</h1></a>
<p>이번 챕터에서는 모든 프로그래밍 언어가 대부분 가진 개념이 Rust에서는 어떻게 다루어지는지 알아보고자 합니다.
많은 프로그래밍 언어가 보편적인 핵심요소를 갖습니다. 이번 챕터에서 Rust 고유의 개념은 다루지 않을테지만,
보편적인 프로그래밍 개념을 Rust의 문법을 설명하는 과정에서 토의하고자 합니다.</p>
<p>특히 변수, 기본 타입들, 함수, 주석, 그리고 제어문에 대해서 배울 수 있을 것 입니다. 이 기본 사항들은
모든 Rust 프로그램에서 사용되며 이들을 조기에 숙지하는 것은 Rust를 시작하는데 큰 바탕이 되줄 겁니다.</p>
<blockquote>
<a class="header" href="print.html#keywords" id="keywords"><h3>Keywords</h3></a>
<p>다른 언어들과 마찬가지로 Rust에도 고정된 의미를 갖는 <em>Keywords</em>가 있습니다. 이들은 변수나 함수명으로
사용될 수 없다는 점을 명심하세요. 대부분의 keywords가 특별한 의미를 갖고, 이들을 통해 다양한 작업을
Rust를 통해 수행할 수 있습니다; 소수의 keywords는 현재는 아무 기능도 없지만 향후 추가될 기능을 위해
예약되어 있습니다. 이들은 목록은 Appendix A에서 찾아볼 수 있습니다.</p>
</blockquote>
<a class="header" href="print.html#변수와-가변성" id="변수와-가변성"><h2>변수와 가변성</h2></a>
<p>2 장에서 언급했듯이, 기본 변수는 <em>불변성</em> 입니다. 이것은 Rust가 제공하는 안전성과 손쉬운 동시성이라는 장점을
취할 수 있도록 코드를 작성하게끔 강제하는 요소 중 하나 입니다. 하지만 여전히 당신은 가변 변수를 사용하고 싶을테죠.
어떻게 그리고 왜 Rust에서 불변성을 애호해주길 권장하는지 알아보면 그런 생각을 포기할 수 있을지도 모르겠습니다.</p>
<p>변수가 불변성인 경우, 일단 값이 이름에 bound되면 해당 값을 변경할 수 없습니다. 시험 삼아
<code>cargo new --bin variables</code>을 실행해서 * projects * 디렉토리에 * variables *라는 새 프로젝트를
생성 해 봅시다. 그런 다음 새 * variables * 디렉토리에서 * src / main.rs *를 열고 코드를 다음과 같이
바꿉니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>저장하고 <code>cargo run</code> 명령을 통해 실행시켜 봅시다. 당신은 다음과 같이 출력되는 에러를 확인하게 될 겁니다.</p>
<pre><code class="language-text">error[E0384]: re-assignment of immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!(&quot;The value of x is: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ re-assignment of immutable variable
</code></pre>
<p>위의 예제는 컴파일러가 당신이 만든 프로그램에서 당신을 도와 에러를 찾아주는 방법에 대해 보여주고 있습니다.
컴파일러 에러가 힘빠지게 만들 수도 있지만, 단지 당신의 프로그램이 아직 안전하게 수행되긴 미흡하다는 뜻이지,
당신의 소양이 부족함을 의미하는건 아닙니다. 숙련된 Rustacean들도 여전히 에러를 발생시키니까요. 에러가
나타내는 것은 <code>불변성 변수에 재할당</code>이고, 원인은 우리가 불변성 변수 <code>x</code>에 두 번째로 값을 할당했기 때문입니다.</p>
<p>우리가 이전에 불변성으로 선언한 것의 값을 변경하고자 하는 시도를 하면 컴파일 타임의 에러를 얻게 되고 이로 인해
버그가 발생할 수 있기 때문에 중요합니다. 만약 우리 코드의 일부는 값이 변경되지 않는다는 것을 가정하는데 다른 코드는
이와 다르게 값을 변경한다면, 전자에 해당하는 코드는 우리가 의도한 대로 수행되지 않을 수 있습니다. 특히 후자에
해당되는 코드가 항상 그렇지 않고 <em>가끔</em> 값을 변경하는 경우 나중에 버그의 원인을 추적하기가 매우 어렵습니다.</p>
<p>Rust에서는 컴파일러가 변경되지 않은 값에 대한 보증을 해주고, 실제로 이는 바뀌지 않습니다. 이것이 의미하는
바는 당신이 코드를 작성하거나 분석할 시에 변수의 값이 어떻게 변경되는지 추적할 필요가 없기 때문에 코드를 더
합리적으로 만들어줍니다.</p>
<p>하지만 가변성은 매우 유용하게 사용될 수 있습니다. 변수는 기본적으로 불변성이지만 우리는 변수명의 접두어로
<code>mut</code>을 추가하는 것을 통해 가변성 변수를 선언할 수 있습니다. 이 변수의 값이 변경을 허용하는 것에 추가로
향후 코드를 보는 사람에게 코드의 다른 부분에서 해당 변수의 값을 변경할 것이라는 의도를 주지시킵니다.</p>
<p>예를 들어, <em>src/main.rs</em>를 다음과 같이 변경해보도록 합니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>위의 프로그램을 수행하면 다음과 같은 결과를 얻게 됩니다:</p>
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
</code></pre>
<p><code>mut</code>를 사용하여, <code>x</code>에 bind된 값을 <code>5</code>에서 <code>6</code>으로 변경할 수 있습니다. 불변성 변수만을 사용하는 것보다
가변성 변수를 사용하여 보다 쉽게 구현할 수 있을 경우 가변성 변수를 만들어 사용할 수도 있습니다.</p>
<p>이런 의사 결정에 있어서 버그를 예방하는 것 외에도 고려해야 할 요소들이 있습니다. 예를 들어, 대규모 데이터 구조체를
다루는 경우 가변한 인스턴스를 사용하는 것이 새로 인스턴스를 할당하고 반환하는 것보다 빠를 수 있습니다. 데이터 규모가
작을수록 새 인스턴스를 생성하고 함수적 프로그래밍 스타일로 작성하는 것이 더 합리적이고, 그렇기에 약간의 성능 하락을
통해 가독성을 확보할 수 있다면 더 가치있는 선택입니다.</p>
<a class="header" href="print.html#변수와-상수-간의-차이점들" id="변수와-상수-간의-차이점들"><h3>변수와 상수 간의 차이점들</h3></a>
<p>변수의 값을 변경할 수 없다는 사항이 아마 당신에게 다른 언어가 가진 프로그래밍 개념을 떠오르게 하지 않나요: <em>상수</em>
불변성 변수와 마찬가지로 상수 또한 이름으로 bound된 후에는 값의 변경이 허용되지 않지만, 상수와 변수는 조금
다릅니다.</p>
<p>첫 째로, 상수에 대해서는 <code>mut</code>을 사용하는 것이 허용되지 않습니다: 상수는 기본 설정이 불변성인 것이 아니고
불변성 그 자체 입니다.</p>
<p>우리가 상수를 사용하고자 하면 <code>let</code>키워드 대신 <code>const</code>키워드를 사용해야 하고, 값의 유형을 선언해야
합니다. 우리가 사용할 수 있는 유형들과 유형의 선언을 챕터 “Data Types,”에서 다루게 될 것이므로 자세한
사항은 지금 걱정하지 말고, 우리는 반드시 값의 유형을 선언해야 한다는 것을 알고 지나갑시다.</p>
<p>상수는 전체 영역을 포함하여 어떤 영역에서도 선언될 수 있습니다. 이는 코드의 많은 부분에서 사용될 필요가 있는
값을 다루는데 유용합니다.</p>
<p>마지막 차이점은 상수는 오직 상수 표현식만 설정될 수 있지, 함수 호출의 결과값이나 그 외에 실행 시간에 결정되는
값이 설정될 수는 없다는 점 입니다.</p>
<p>아래의 <code>MAX_POINTS</code>라는 이름을 갖는 상수를 선언하는 예제에서는 값을 100,000으로 설정합니다. (Rust의
상수 명명 규칙에 따라 모든 단어를 대문자로 사용합니다.)</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const MAX_POINTS: u32 = 100_000;
#}</code></pre></pre>
<p>상수는 자신이 선언되어 있는 영역 내에서 프로그램이 실행되는 시간 동안 항상 유효하기에, 당신의 어플리케이션 도메인 전체에
걸쳐 프로그램의 다양한 곳에서 사용되는 값을 상수로 하면 유용합니다. 사용자가 한 게임에서 획득할 수 있는 최대 포인트,
빛의 속도 같은 값 등등...</p>
<p>당신의 프로그램 전체에 걸쳐 하드코드 해야 하는 값을 이름지어 상수로 사용하면 향후 코드를 유지보수 하게 될 사람에게
그 의미를 전달할 수 있으므로 유용합니다. 또한 향후 해당 값을 변경해야 하는 경우에 상수로 선언된 값 한 곳만 변경하면
되므로 도움이 될 겁니다.</p>
<a class="header" href="print.html#shadowing" id="shadowing"><h3>Shadowing</h3></a>
<p>앞서 우리가 2장에서 추측 게임 예제를 통해 봤듯이, 이전에 선언한 변수와 같은 이름의 새 변수를 선언할 수 있고,
새 변수는 이전 변수를 <em>shadows</em>하게 됩니다. Rustaceans들은 이를 첫 변수가 두 번째에 의해 <em>shadowed</em>
됐다고 표현하게 됩니다. 해당 변수명은 두 번째 변수의 값을 갖게 된다는 뜻이죠. <code>let</code>키워드를 사용해서 다음처럼
반복하여 같은 변수 명으로 변수를 shadow 할 수 있습니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>이 프로그램은 처음 <code>x</code>에 값 <code>5</code>를 bind 합니다. 이후 반복된 <code>let x =</code> 구문으로 <code>x</code>를 shadow하고
원본 값에 <code>1</code>을 더해서 <code>x</code>의 값은 <code>6</code>이 됩니다. 세 번째 <code>let</code> 문으로 또 <code>x</code>를 shadow하고, 이전
값에 <code>2</code>를 곱하여 <code>x</code>의 최종값은 <code>12</code>가 됩니다. 이 프로그램을 실행하면 다음과 같은 결과를 볼 수 있습니다.</p>
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
     Running `target/debug/variables`
The value of x is: 12
</code></pre>
<p>이와 같은 사용은 변수를 <code>mut</code>으로 선언하는 것과는 차이가 있게 됩니다. 왜냐면 <code>let</code>키워드를 사용하지 않고 변수에
새로 값을 대입하려고 하면 컴파일-시에 에러를 얻게 되기 때문이죠. 우리가 몇 번 값을 변경할 수는 있지만 그 이후에
변수는 불변성을 갖게 됩니다.</p>
<p>또 다른 <code>mut</code>과 shadowing의 차이는 <code>let</code>키워드를 다시 사용하여 효과적으로 새 변수를 선언하고, 값의 유형을
변경할 수 있으면서도 동일 이름을 사용할 수 있다는 점 입니다. 예를 들어, 공백 문자들을 입력받아 얼마나 많은 공백
문자가 있는지 보여주고자 할 때, 실제로는 저장하고자 하는 것은 공백의 갯수일테죠.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let spaces = &quot;   &quot;;
let spaces = spaces.len();
#}</code></pre></pre>
<p>이와 같은 구조가 허용되는 이유는 첫 <code>spaces</code> 변수가 문자열 유형이고 두 번째 <code>spaces</code> 변수는 첫 번째 것과
동일한 이름을 가진 새롭게 정의된 숫자 유형의 변수이기 때문입니다. Shadowing은 <code>space_str</code>이나 <code>space_num</code>
과 같이 대체된 이름을 사용는 대신 간단히 <code>spaces</code> 이름을 사용할 수 있게 해줍니다. 그러나 우리가 <code>mut</code>을 사용하려고
했다면:</p>
<pre><code class="language-rust ignore">let mut spaces = &quot;   &quot;;
spaces = spaces.len();
</code></pre>
<p>우리는 다음처럼 변수의 유형을 변경할 수 없다는 컴파일-시의 에러를 얻게 될 겁니다:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &amp;str, found usize
  |
  = note: expected type `&amp;str`
             found type `usize`
</code></pre>
<p>변수가 어떻게 동작하는지 탐구했으니, 더 많은 데이터 유형을 사용 살펴보도록 합시다.</p>
<a class="header" href="print.html#데이터-타입들" id="데이터-타입들"><h2>데이터 타입들</h2></a>
<p>Rust에서 사용되는 모든 값들은 어떤 <em>타입</em>을 갖습니다. 그러니 어떤 형태의 데이터인지 명시하여 Rust에게 알려줘서
이를 통해 데이터를 어떻게 다룰지 알 수 있도록 해야 합니다. 이번 장에서, 우리는 언어에 포함되어 있는 여러 타입들을
살펴보고자 합니다. 타입은 크게 스칼라와 컴파운드, 둘로 나눌 수 있습니다.</p>
<p>이번 장의 전체에 걸쳐 주지해야 할 점은 Rust는 <em>타입이 고정된</em> 언어라는 점 입니다. 이게 의미하는 바는 모든 변수의
타입이 컴파일 시에 반드시 정해져 있어야 한다는 겁니다. 보통 컴파일러는 우리가 값을 사용하는 지에 따라 타입을 추측할
수 있습니다. 2장에서 <code>String</code>을 <code>parse</code>를 사용하여 숫자로 변환했던 경우처럼 타입의 선택 폭이 넓은 경우는
반드시 타입의 명시를 첨가해야 합니다. 다음처럼:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
#}</code></pre></pre>
<p>여기에 타입 명시를 첨가하지 않은 경우, Rust는 다음과 같은 에러를 발생시킵니다.<br />
이와 같은 에러는 컴파일러가 우리에게 사용하고 싶은 타입이 무엇인지 추가적인 정보를 요구하는 겁니다.</p>
<pre><code class="language-text">error[E0282]: unable to infer enough type information about `_`
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^ cannot infer type for `_`
  |
  = note: type annotations or generic parameter binding required
</code></pre>
<p>우리가 다루고자 하는 다양한 데이터 타입들 각각의 타입 명시를 살펴보겠습니다.</p>
<a class="header" href="print.html#스칼라-타입들" id="스칼라-타입들"><h3>스칼라 타입들</h3></a>
<p><em>스칼라</em>는 하나의 값으로 표현되는 타입입니다. Rust는 정수형, 부동소수점 숫자, boolean, 그리고 문자, 네 가지
스칼라 타입을 보유하고 있습니다. 아마 다른 프로그래밍 언어에서도 본 적이 있겠지만, Rust에서 이들이 어떻게 동작하
는지 살펴보도록 합시다.</p>
<a class="header" href="print.html#정수형" id="정수형"><h4>정수형</h4></a>
<p><em>정수형</em>은 소수점이 없는 숫자 입니다. 우리는 이번 장의 앞부분에서 <code>i32</code>타입인 정수형을 사용했었습니다. 해당 타입의
선언은 부호를 갖는 32비트 변수임을 나타냅니다.(따라서 <code>i</code>는 부호가 없는 <code>u</code>와 반대입니다.) 표 3-1은 Rust에서
사용되는 정수형들을 보여줍니다. 부호, 미부호로 나뉜 다른 열의 타입을 사용하여(<em>i32</em>처럼) 정수 값의 타입을 선언할
수 있습니다.</p>
<p><span class="caption">Table 3-1: Rust에서의 정수 타입 </span></p>
<table><thead><tr><th> Length </th><th> Signed </th><th> Unsigned </th></tr></thead><tbody>
<tr><td> 8-bit  </td><td> i8     </td><td> u8       </td></tr>
<tr><td> 16-bit </td><td> i16    </td><td> u16      </td></tr>
<tr><td> 32-bit </td><td> i32    </td><td> u32      </td></tr>
<tr><td> 64-bit </td><td> i64    </td><td> u64      </td></tr>
<tr><td> arch   </td><td> isize  </td><td> usize    </td></tr>
</tbody></table>
<p>각각의 타입은 부호 혹은 미부호이며 명시된 크기를 갖습니다. 부호 혹은 미부호의 의미는, 숫자가 양수 혹은 음수를 다룰 수
있는지 혹은 없는지를 나타냅니다. 다르게 말하면, 숫자가 부호를 가져야 하는 경우(부호) 혹은 오직 양수만을 가질 것이기에
부호가 없이도 표현할 수 있는가(미부호)를 나타냅니다. 종이에 숫자 기재하는 것과 같죠: 부호와 함께 다뤄야 하는 경우에
숫자는 더하기 혹은 빼기 기호와 함께 표시하죠. 숫자가 양수라고 가정되도 문제 없는 상황에는 부호가 없이 표시하게 됩니다.
부호된 숫자는 2의 보수 형태를 사용하여 저장됩니다. (2의 보수가 모른다면 검색해보세요. 이 책에서 다루는 내용이 아닙니다.)</p>
<p>각 부호 변수는 -(2<sup>n - 1</sup>) 부터 2<sup>n - 1</sup> - 1 까지의 값을 포괄합니다. 여기서
<code>n</code>은 사용되는 타입의 비트 수 입니다. 즉, <code>i8</code>은 -(2<sup>7</sup>) 에서 2<sup>7</sup> - 1
까지의 값, 즉 -128 에서 127 사이의 값을 저장할 수 있습니다. 미부호 타입은 0 에서 2<sup>n</sup> - 1
까지의 값을 저장할 수 있습니다. 즉, <code>u8</code> 타입은 0 에서 2<sup>8</sup> - 1 다시 말해, 0 에서 255
까지의 값을 저장할 수 있습니다.</p>
<p>추가로, <code>isize</code>와 <code>usize</code>타입은 당신의 프로그램이 동작하는 컴퓨터 환경이 64-bits인지 아닌지에 따라 결정됩니다.
64-bit 아키텍처이면 64bit를, 32-bit 아키텍처이면 32bit를 갖게 됩니다.</p>
<p>당신은 테이블 3-2에서 보여주는 형태들처럼 정수형 리터럴을 사용할 수 있습니다. byte 리터럴을 제외하고 모든 정수형
리터럴은 <code>57u8</code>과 같은 타입 접미사와 <code>1_000</code>과 같이 시각적인 구분을 위한 <code>_</code>의 사용을 허용합니다.</p>
<p><span class="caption">Table 3-2: Rust의 정수형 리터럴들</span></p>
<table><thead><tr><th> Number literals  </th><th> Example       </th></tr></thead><tbody>
<tr><td> Decimal          </td><td> <code>98_222</code>      </td></tr>
<tr><td> Hex              </td><td> <code>0xff</code>        </td></tr>
<tr><td> Octal            </td><td> <code>0o77</code>        </td></tr>
<tr><td> Binary           </td><td> <code>0b1111_0000</code> </td></tr>
<tr><td> Byte (<code>u8</code> only) </td><td> <code>b'A'</code>        </td></tr>
</tbody></table>
<p>그렇다면 어떤 타입의 정수를 사용해야 할까요? 확실하게 정해진 경우가 아니면 Rust의 기본 값인 <code>i32</code>가 일반적으로
는 좋은 선택입니다. 이는 일반적으로 가장 빠르기 때문이죠. 심지어 64-bit 시스템에서도요. <code>isize</code>나 <code>usize</code>는
주로 콜렉션의 정렬을 색인할 때 사용됩니다.</p>
<a class="header" href="print.html#부동-소수점-타입" id="부동-소수점-타입"><h4>부동 소수점 타입</h4></a>
<p>Rust에는 소수점을 갖는 숫자인 <em>부동소수점 숫자</em>를 위한 두 가지 기본 타입도 있습니다. Rust의 부동소수점 타입은
<code>f32</code>와 <code>f64</code>로, 예상하신 대로 각기 32bit와 64bit의 크기를 갖습니다. 기본 타입이 <code>f64</code>인 이유는 대략
<code>f32</code>와 비슷한 속도이면서 더 정밀한 표현이 가능하기 때문입니다. <code>f64</code>타입을 32bit 환경에서 사용하는 것도
가능하지만 해당 시스템에서 <code>f32</code>를 사용하는 것 보다는 느려질 겁니다. 대부분의 경우 보다 높은 정밀성을 위한
성능 하락이 합리적인 초기 선택안이기에 만약 당신이 당면한 상황에 부동소수점의 크기로 인한 문제가 의심된다면 벤치마킹을
해보셔야 합니다.</p>
<p>다음은 부동소수점 숫자가 활용되는 예제입니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>부동소수점 숫자는 IEEE-754 표준에 따라 표현됩니다. <code>f32</code> 타입은 1배수의 정밀도인 부동소수점이고,
<code>f64</code>는 2배수의 정밀도인 부동소수점 입니다.</p>
<a class="header" href="print.html#수학적-연산들" id="수학적-연산들"><h4>수학적 연산들.</h4></a>
<p>Rust가 지원하는 일반적인 기본 수학적 연산은 기대하신 것처럼 모든 숫자 타입에 적용됩니다: 더하기, 빼기, 곱하기,
나누기 등등. 다음의 코드로 보여주려는 것은 각 경우를 <code>let</code>문 내에서 사용할 수 있는 방법입니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;
}
</code></pre></pre>
<p>위의 문장에서 각 표현식들은 수학 연산자를 사용하여 산출된 값을 변수로 bound 합니다. 부록 B에 Rust에서
제공하는 모든 연산자 목록이 들어있습니다.</p>
<a class="header" href="print.html#boolean-타입" id="boolean-타입"><h4>Boolean 타입</h4></a>
<p>대부분의 다른 언어들처럼, boolean 타입은 Rust에서 둘 중 하나의 값만 갖을 수 있습니다:
<code>true</code>와 <code>false</code>. boolean 타입은 러스트에서 <code>bool</code>로 명시됩니다.</p>
<p>예제:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
</code></pre></pre>
<p>boolean 값을 사용하는 주된 방법은 <code>if</code>문과 같은 조건문에서 조건으로 사용하는 것입니다. 우리는 <code>if</code>문이
Rust에서 동작하는 방식을 “제어 흐름” 장에서 다루게 될 겁니다.</p>
<a class="header" href="print.html#문자-타입" id="문자-타입"><h4>문자 타입</h4></a>
<p>지금까지 숫자 타입만을 살펴봤는데, Rust는 문자 또한 지원합니다. Rust의 <code>char</code>는 이 언어의 가장 근본적인
알파벳 타입이고, 다음의 코드는 이를 사용하는 하나의 방법입니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
   let c = 'z';
   let z = 'ℤ';
   let heart_eyed_cat = '😻';
}
</code></pre></pre>
<p>Rust의 <code>char</code>타입은 Unicode Scalar를 표현하는 값이고 이는 ASCII 보다 많은 표현을 가능하게 합니다.
억양 표시가 있는 문자, 한국어/중국어/일본어 표의 문자, 이모티콘, 넓이가 0인 공백문자 모두가 Rust에서는
<code>char</code>타입으로 사용할 수 있습니다. Unicode Scalar 값의 범위는 <code>U+0000</code>에서 <code>U+D7FF</code> 그리고
<code>U+E000</code>에서 <code>U+10FFFF</code> 를 포괄합니다. 그럼에도 불구하고 “문자”는 Unicode을 위한 개념이 아니기
때문에, 당신의 인간적 직관에 따른 “문자”와 Rust의 <code>char</code>가 동일하지 않을 수 있습니다. 우리는 8장
“Strings” 부에서 이 주제에 대해 상세히 다루게 될 겁니다.</p>
<a class="header" href="print.html#복합-타입들" id="복합-타입들"><h3>복합 타입들</h3></a>
<p><em>복합 타입들</em>은 다른 타입의 다양한 값들을 하나의 타입으로 묶을 수 있습니다. Rust는 두 개의 기본 타입들을 갖고
있습니다: 튜플과 배열.</p>
<a class="header" href="print.html#값들을-집합시켜서-튜플화하기" id="값들을-집합시켜서-튜플화하기"><h4>값들을 집합시켜서 튜플화하기.</h4></a>
<p>튜플은 다양한 타입의 몇 개의 숫자를 집합시켜 하나의 복합 타입으로 만드는 일반적인 방법입니다.</p>
<p>우리는 괄호 안에 콤마로 구분되는 값들의 목록을 작성하여 튜플을 만듭니다. 튜플에 포함되는 각 값의 타입이 동일할
필요없이 서로 달라도 됩니다. 다음의 예제에 우리는 선택 사항인 타입 명시를 추가했습니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p>튜플은 단일 요소를 위한 복합계로 고려되었기에 변수 <code>tup</code>에는 튜플 전체가 bind 됩니다. 개별 값을 튜플의 밖으로
빼내오기 위해서는, 패턴 매칭을 사용하여 튜플의 값을 구조해체 시키면 됩니다. 다음을 봅시다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>해당 프로그램은 처음에 튜플을 만들고 변수 <code>tup</code>에 bind 시킵니다. 이후 패턴과 <code>let</code>을 통해 <code>tup</code>을 세개의
분리된 변수 <code>x</code>, <code>y</code>, 그리고 <code>z</code>에 이동시킵니다. 이것을 <em>구조해체</em>라고 부르는 이유는 하나의 튜플을 세 부분으로
나누기 때문입니다. 최종적으로 프로그램은 <code>y</code>의 값을 출력할 것이고 이는 <code>6.4</code>입니다.</p>
<p>패턴 매칭을 통한 구조해체에 추가로, 우리는 마침표(<code>.</code>) 뒤에 우리가 접근하길 원하는 값의 색인을 넣는 것을 통해
튜플의 요소에 직접적으로 접근할 수 있습니다. 예제를 봅시다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<p>위의 프로그램은 튜플 <code>x</code>를 만들고, 이의 각 요소들을 그들의 색인을 통해 접근하여 새 변수를 만듭니다. 대부분의
언어가 그렇듯이, 튜플의 첫 번째 색인은 0 입니다.</p>
<a class="header" href="print.html#배열" id="배열"><h4>배열</h4></a>
<p>여러 값들의 집합체를 만드는 다른 방법은 <em>배열</em>입니다. 튜플과는 다르게, 배열의 모든 요소는 모두 같은 타입이여야
합니다. Rust의 배열이 몇 다른 언어들의 배열과 다른 점은 Rust에서는 배열은 고정된 길이를 갖는다는 점입니다:
한번 선언되면, 이들은 크기는 커지거나 작아지지 않습니다.</p>
<p>Rust에서는 대괄호 안에 값들을 콤마로 구분하여 나열해서 배열을 만듭니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>배열이 유용할 때는 당신의 데이터를 heap보다 stack에 할당하는 것을 원하거나(stack 과 heap에 대해서는 4장에서
다루게 될 것입니다), 당신이 항상 고정된 숫자의 요소를 갖는다고 확신하고 싶을 때 입니다. 이들은 벡터 타입처럼 가변적
이지 않습니다. 벡터 타입은 유사 집합체로 표준 라이브러리에서 제공되며 확장 혹은 축소가 가능합니다. 배열이나 벡터 중에
뭘 선택해야 할지 확실하지 않은 상황이라면 벡터를 사용하도록 하세요. 8장에서 벡터에 대해 더 자세히 다룹니다.</p>
<p>벡터가 아닌 배열을 선택하게 되는 경우의 예로, 프로그램이 올해의 달 이름을 알고자 할 경우 입니다. 프로그램이 달을
추가하거나 삭제하는 경우는 거의 없을 것이므로, 고정적으로 12개의 아이템을 가질테니 배열을 사용하면 됩니다.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
#}</code></pre></pre>
<a class="header" href="print.html#배열-요소에-접근하기" id="배열-요소에-접근하기"><h5>배열 요소에 접근하기</h5></a>
<p>배열은 stack에 단일 메모리 뭉치로 할당됩니다. 우리는 색인을 통해 배열의 요소에 접근할 수 있습니다. 이렇게요:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre></pre>
<p>이번 예제에서, <code>first</code>로 명명된 변수는 값 <code>1</code>이 될텐데, 왜냐면 배열 색인 <code>[0]</code>에 들어있는 값이기 때문이죠.
<code>second</code>로 명명된 변수는 배열의 색인 <code>[1]</code>의 값인 <code>2</code>가 되겠죠.</p>
<a class="header" href="print.html#유효하지-않은-배열-요소에-대한-접근" id="유효하지-않은-배열-요소에-대한-접근"><h5>유효하지 않은 배열 요소에 대한 접근</h5></a>
<p>만약 우리가 배열의 끝을 넘어선 요소에 접근하려고 하면 어떻게 될까요? 예제를 다음처럼 변경해봤습니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!(&quot;The value of element is: {}&quot;, element);
}
</code></pre>
<p>이번 코드를 <code>cargo run</code>을 통해 동작시키면 다음의 결과를 얻게 됩니다:</p>
<pre><code class="language-text">$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
     Running `target/debug/arrays`
thread '&lt;main&gt;' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>컴파일 시에는 아무런 에러도 발생시키지 않습니다만, 프로그램의 결과는 <em>실행간에</em> 에러가 발생했고 성공적으로 종료되지
못했다고 나옵니다.</p>
<p>색인을 사용하여 요소에 접근하려고 하면 Rust는 지정한 색인이 배열 길이보다 작은지 확인합니다. 색인이 길이보다 길면
Rust는 프로그램이 오류와 함께 종료 될 때 Rust가 사용하는 용어인 *패닉(panic)*합니다.</p>
<p>이것은 Rust의 안전 원칙이 동작하는 첫 번째 예입니다. 많은 저수준 언어에서 이러한 타입의 검사는 수행되지 않으며 잘못된
색인을 제공하면 유효하지 않은 메모리에 액세스 할 수 있습니다. Rust는 메모리 접근을 허용하고 계속 진행하는 대신 즉시
종료하여 이러한 종류의 오류로부터 사용자를 보호합니다. 9 장에서는 Rust의 오류 처리에 대해 자세히 설명합니다.</p>
<a class="header" href="print.html#함수-동작-원리" id="함수-동작-원리"><h2>함수 동작 원리</h2></a>
<p>함수는 Rust에 녹아들어 있습니다. 여러분은 이미 언어에서 가장 중요하게 생각하는 <code>main</code>함수를 보셨습니다.
이는 다수의 프로그램에서 실행 지점입니다. 여러분은 또한 <code>fn</code> 키워드도 보셨을텐데, 이는 새로운 함수의 선언을
가용하게 합니다.</p>
<p>Rust 코드는 <em>뱀 형태</em>를 변수나 함수 이름의 형식 규칙으로 사용합니다. 뱀 형태에서, 모든 문자는 소문자를 사용하며
밑줄 표시로 단어를 구분합니다. 다음은 예제로 함수를 선언하는 프로그램 입니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Another function.&quot;);
}
</code></pre></pre>
<p>Rust 에서의 함수 선언은 <code>fn</code>으로 시작하며 함수 이름 뒤에 괄호의 형식으로 되어 있습니다. 중괄호는 컴파일러에게
함수의 시작과 종료 지점을 알려주게 됩니다.</p>
<p>우리는 함수의 이름과 괄호 형식을 기입하는 것을 통해 우리가 선언했던 어떤 함수든 호출할 수 있습니다.
<code>another_function</code>이 프로그램 내에 정의되어 있으므로, <code>main</code> 함수에서 해당 함수를 호출할 수 있습니다.
주의할 점은, 소스 코드 내에서 <code>another_function</code>이 <code>main</code> 함수 <em>이후에</em> 정의했다는 점 입니다. 우리는
이를 이전에도 정의할 수 있습니다. Rust는 당신의 함수의 위치를 신경쓰지 않습니다, 어디든 정의만 되어 있으면 됩니다.</p>
<p>함수를 추가로 탐색하기 위해 <em>functions</em> 이라는 이름의 새로운 바이너리 프로젝트를 시작합시다.
<code>another_function</code> 예제를 * src / main.rs *에 넣고 실행해보세요.
다음과 같은 결과가 나타납니다:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
     Running `target/debug/functions`
Hello, world!
Another function.
</code></pre>
<p><code>main</code> 함수 안의 내용이 줄의 순서대로 수행됩니다. 처음으로, &quot;Hello, world!&quot; 메시지가 출력되고,
<code>another_function</code>이 호출되고 그의 메시지를 출력합니다.</p>
<a class="header" href="print.html#함수-매개변수" id="함수-매개변수"><h3>함수 매개변수</h3></a>
<p>함수는 함수 고유한 부분인 특별한 변수 <em>매개변수</em>를 갖는 형식으로 선언될 수 있습니다. 함수가 매개변수를 취할 때, 우리는
상수를 그들의 전달인자로 제공할 수 있습니다. 기술적으로, 여기서 전달되는 상수를 <em>전달인자</em>라고 부릅니다만, 사람들은 보통
“전달인자”와 “매개변수”를 혼용해서 사용하는 경향이 있습니다.</p>
<p>다음의 재작성 된 <code>another_function</code>은 Rust에서 매개변수가 어떤 것이지 보여줍니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>이 프로그램을 실행해보시면 다음과 같은 결과가 출력되는 것을 보게 될 겁니다:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p><code>another_function</code>의 선언은 <code>x</code>로 명명된 하나의 매개변수를 갖습니다. <code>x</code>의 타입은 <code>i32</code>로 정의됩니다.
<code>5</code>가 <code>another_function</code>으로 전달되면, <code>println!</code> 매크로는 중괄호 짝으로 된 형식 문자열에 <code>5</code>를
전달합니다. 함수의 선언부에서, 여러분은 <em>반드시</em> 각 매개변수의 타입을 정의해야 합니다. 이 사항은 Rust를 설계하며
내린 신중한 결정사항 입니다: 함수의 정의에 타입을 명시하여 코드내 다른 부분에서 이들을 사용하는 것을 통해 당신의 의도를
추측하지 않아도 되게 됩니다.</p>
<p>여러분의 함수에 여러 개의 매개변수를 사용하고 싶으면, 매개변수들을 다음처럼 쉼표와 함께 구분해서 사용할 수 있습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>이 예제는 각각 <code>i32</code> 타입인 두 개의 매개변수를 갖는 함수를 생성합니다. 함수는 그의 두 매개변수의 값을 출력합니다.
주의할 점은, 함수 매개변수는 이번 예제처럼 굳이 같은 타입이 아니여도 된다는 점 입니다. 한번 코드를 실행해봅시다.
여러분의 <em>function</em> 프로젝트의 <em>src/main.rs</em> 내용을 위의 예제로 변경한 뒤에,
<code>cargo run</code>을 통해 수행시키면 됩니다:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
     Running `target/debug/functions`
The value of x is: 5
The value of y is: 6
</code></pre>
<p>우리는 값 <code>5</code>와 <code>6</code>을 <code>x</code>와 <code>y</code>로 전달했기 때문에, 이 값들이 담긴 두 문장을 출력합니다.</p>
<a class="header" href="print.html#함수-본문" id="함수-본문"><h3>함수 본문</h3></a>
<p>함수 본문은 필요에 따라 표현식으로 종결되는 구문의 나열로 구성됩니다. 지금까지 우리는 종결 표현식이 없는 함수만
다뤘기에, 표현식이 구문의 일부처럼 여겨질지 모르겠습니다. Rust가 표현식에 기반한 언어기 때문에, 이것은 이해하셔야
하는 중요한 차이점 입니다. 다른 언어들은 이와 같은 차이가 없으니, 구문과 표현식이 함수의 본문에 어떤 식으로 차이나게
적용되는지 살펴보도록 하겠습니다.</p>
<a class="header" href="print.html#구문과-표현식" id="구문과-표현식"><h3>구문과 표현식</h3></a>
<p>사실 우리는 이미 구문과 표현식을 사용했습니다. <em>구문</em>은 어떤 명령들의 나열로 값을 반환하지 않는 어떤 동작을 수행
합니다. <em>포현식</em>은 결과 값을 산출해냅니다. 다음 몇 개의 예제를 살펴보도록 합시다. <code>let</code> 키워드를 통해 변수를
만들고 값을 할당하는 구문을 만듭니다. 항목 3-3의, <code>let y = 6;</code>은 구문 입니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<p><span class="caption">항목 3-3: 하나의 구문을 갖는 <code>main</code> 함수를 선언하였다. </span></p>
<p>함수 정의는 또 하나의 구문입니다; 상기 예제는 자신 그 자체가 구문 입니다. 구문은 값을 반환하지 않습니다.
그러니, 여러분은 다음처럼 <code>let</code> 구문을 사용해서는 다른 변수에 값을 대입할 수 없습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>여러분이 이 프로그램을 수행하면, 다음과 같은 에러를 보게 될 겁니다:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
</code></pre>
<p><code>let y = 6</code> 구문은 반환 값이 없으므로, <code>x</code>에 bind 시킬 것이 없습니다. 이것이 다른 언어인 C나
Ruby와의 차이점 입니다. 이들 언어들은 <code>x = y = 6</code>와 같은 코드가 <code>x</code>와 <code>y</code>에 모두 <code>6</code>의 값을
대입할 수 있습니다; Rust에서는 허용되지 않습니다. 여러분이 작성하는 Rust 코드의 대부분은 표현식이며
이는 어떤 값을 산출합니다. <code>5 + 6</code>과 같은 간단한 수학 연산을 살펴보면, 이는 <code>11</code>이란 값을 산출하는
표현식입니다.</p>
<p>표현식은 구문의 부분일 수 있습니다: 항목 3-3은 <code>let y = 6;</code>이란 구문을 갖는데, <code>6</code>은 <code>6</code>이란 값을
산출하는 표현식입니다. 함수를 호출하는 것은 표현식입니다. 매크로를 호출하는 것은 표현식입니다. 예제처럼 새로운
범위를 생성하는데 사용하는 block, <code>{}</code>, 은 표현식입니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>표현식 부:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<p>이번 경우에 해당 block은 <code>4</code>를 산출합니다. 이 값은 <code>let</code> 구문의 일부로 <code>y</code>에 bound됩니다.
여러분이 앞서 봐온 것과 다르게 줄의 마지막이 세미콜론으로 끝나지 않은 점을 주목하세요. 표현식은 종결을
나타내는 세미콜론을 사용하지 않습니다. 만약 세미콜론을 표현식 마지막에 추가하면, 이는 구문으로 변경되고
반환 값이 아니게 됩니다. 이후부터 함수의 반환 값과 표현식을 살펴보실때 이 점을 유의하세요.</p>
<a class="header" href="print.html#반환-값을-갖는-함수" id="반환-값을-갖는-함수"><h3>반환 값을 갖는 함수</h3></a>
<p>함수는 그들을 호출한 코드에 값을 반환할 수 있습니다. 우리는 반환되는 값을 명명해야 할 필요는 없지만, 그들의
타입은 화살표(<code>-&gt;</code>) 뒤에 선언해야 합니다. Rust에서 반환 값은 함수 본문의 마지막 표현식의 값과 동일합니다.
여기 반환 값에 대한 예제가 있습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p><code>five</code> 함수에는 함수 호출, 매크로, 심지어 <code>let</code> 구문도 없이 그저 <code>5</code>란 숫자 하나가 있습니다.
이는 Rust에서 완벽하게 함수로 허용됩니다. 함수 반환 값의 타입이 <code>-&gt; i32</code>로 명시되어 있다는 점
또한 주목하세요. 해당 코드를 수행하면 다음과 같은 결과를 얻게 될 겁니다:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p><code>5</code>는 <code>five</code> 함수가 반환한 값이고, 이 때문에 반환 타입을 <code>i32</code>으로 한 것이지요. 좀더 자세히
설명해보겠습니다. 중요한 지점이 두 곳 있습니다: 첫 째, <code>let x = five();</code> 줄은 우리가 반환 값을
변수의 초기 값으로 사용하는 것을 보여줍니다. <code>five</code>의 반환 값이 <code>5</code>이기 때문에, 해당 줄은 다음과
동일합니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
#}</code></pre></pre>
<p>둘 째, <code>five</code> 함수는 매개변수 없이 반환 값에 대한 타입만 정의되어 있지만, 본문에는 <code>5</code>만이 세미콜론 없이
외로이 있는 이유는 이것이 우리가 값을 반환하고자 할때 사용하는 하는 표현식이기 때문입니다. 다른 예제를 통해
살펴보겠습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<p>이 코드를 수행하면 <code>The value of x is: 6</code>를 출력하게 됩니다. 우리가 <code>x + 1</code> 끝에 세미콜론을
추가하여 표현식을 구문으로 변경하면 어떤 일이 일어날까요?</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>이 코드를 실행하면 다음과 같은 에러를 얻게 됩니다:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:7:28
  |
7 |   fn plus_one(x: i32) -&gt; i32 {
  |  ____________________________^
8 | |     x + 1;
9 | | }
  | |_^ expected i32, found ()
  |
  = note: expected type `i32`
             found type `()`
help: consider removing this semicolon:
 --&gt; src/main.rs:8:10
  |
8 |     x + 1;
  |          ^
</code></pre>
<p>에러 메시지의 중요 포인트는 “mismatched types,”으로 이 코드의 주요 문제를 보여줍니다.
<code>plus_one</code> 함수의 정의는 <code>i32</code> 값을 반환하겠다고 하였으나, 구문은 값을 산출하지 않기에 <code>()</code>처럼
비어있는 튜플로 표현됩니다. 이런 이유로, 반환할 것이 없어서 함수가 정의된 내용과 상충하게 되고 이는 에러를
발생시킵니다. 이번 결과에서는, Rust가 문제를 해결할 수 있도록 도와주는 메시지를 제공합니다: 세미콜론을
제거하면 에러가 교정될 수도 있다고 제안하네요.</p>
<a class="header" href="print.html#주석" id="주석"><h2>주석</h2></a>
<p>모든 프로그래머들은 되도록 이해하기 쉽게 이해되는 코드를 작성하기 위해 노력하지만, 자주 부연 설명이
필요합니다. 이런 경우, 프로그래머들은 메모를 남기거나 소스코드에 컴파일러는 무시하도록 되어 있는 <em>주석</em>
을 남겨 소스코드를 읽는 사람이 혜택을 받을 수 있게 합니다.</p>
<p>여기에 간단한 주석이 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Hello, world.
#}</code></pre></pre>
<p>Rust에서 주석은 두개의 슬래쉬로 시작해야 하고 해당 줄의 끝까지 계속됩니다. 한 줄을 넘는 주석을 작성할 경우,
<code>//</code>를 각 줄에 포함시켜 사용하면 됩니다, 이런 식으로요:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 우리는 여기에 뭔가 복잡한 것을 적어놓고자 하는데, 그를 위해 충분히 긴 여러 줄의 주석이 필요합니다. 
// 휴! 다행입니다.
// 이 주석은 그에 대해 설명할테니까요.
#}</code></pre></pre>
<p>주석은 코드의 뒷 부분에 위치할 수도 있습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let lucky_number = 7; // I’m feeling lucky today.
}
</code></pre></pre>
<p>하지만 주석을 코드와 나눠 앞 줄에 기재되는 형식을 더 자주 보게 될 겁니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // I’m feeling lucky today.
    let lucky_number = 7;
}
</code></pre></pre>
<p>이게 전부입니다. 특별히 복잡하지 않죠.</p>
<a class="header" href="print.html#제어문" id="제어문"><h2>제어문</h2></a>
<p>조건의 상태가 참인지에 따라 어떤 코드의 실행 여부를 결정하거나 조건이 만족되는 동안 반복 수행을 하는 것은
대부분의 프로그래밍 언어의 기초 문법입니다. 우리가 실행 흐름을 제어할 수 있는 가장 보편적인 작성 방식은
<code>if</code>표현식과 반복문 입니다.</p>
<a class="header" href="print.html#if표현식" id="if표현식"><h3><code>if</code>표현식</h3></a>
<p><code>if</code>표현식은 우리의 코드가 조건에 따라 분기할 수 있게 합니다. 우리가 조건을 제공하는 것은 다음 서술과 같죠.
“만약 조건이 충족되면, 이 코드 블럭을 실행하세요. 만약 충족되지 않았다면 코드 블럭을 실행하지 마세요.&quot;</p>
<p><em>branches</em>로 명명된 새 프로젝트를 우리의 <em>projects</em> 디렉토리에 생성하고 <code>if</code>식을 탐구합시다.
<em>src/main.rs</em> 파일에 다음의 내용을 기입하세요:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;condition was true&quot;);
    } else {
        println!(&quot;condition was false&quot;);
    }
}
</code></pre></pre>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>모든 <code>if</code>표현식은 <code>if</code>란 키워드로 시작하며 뒤이어 조건이 옵니다. 이번 경우에 조건은 변수 <code>number</code>가
5보다 작은 값을 가지는지 여부가 됩니다. 조건이 참일 때 실행하는 코드 블록은 조건 바로 뒤 중괄호로 된 블록에
배치됩니다. <code>if</code>식의 조건과 관련된 코드 블럭은 우리가 2장의 “비밀번호 추리 게임”에서 다뤘던 <code>match</code>식의
갈래(arms)와 마찬가지로 *갈래(arms)*로 불립니다. 선택적으로, 우리는 이번 경우에서 처럼 <code>else</code>식을
포함시킬 수 있는데, 이는 조건이 거짓으로 산출될 경우 실행시킬 코드 블럭을 프로그램에 제공합니다. 당신이
<code>else</code>식을 제공하지 않는데 조건이 거짓이 되면, 프로그램은 <code>if</code>블록을 생략하고 다음 순서의 코드를 실행하게
될 겁니다.</p>
<p>이 코드를 실행해보세요; 다음과 같은 결과를 얻을 수 있을 겁니다:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
     Running `target/debug/branches`
condition was true
</code></pre>
<p><code>number</code>의 값을 조건을 <code>거짓</code>으로 만들 값으로 변경하면 무슨 일이 일어날지 살펴보도록 합시다:</p>
<pre><code class="language-rust ignore">let number = 7;
</code></pre>
<p>프로그램을 다시 실행시키면, 다음과 같은 결과를 보게 됩니다:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
     Running `target/debug/branches`
condition was false
</code></pre>
<p>주의해야 할 중요한 점은 이번 코드의 조건은 <em>반드시</em> <code>bool</code>이어야 합니다. 만약 <code>bool</code>이 아닐 경우
어떤 일이 일어나는지는 다음의 코드를 실행하면 알 수 있을 겁니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let number = 3;

    if number {
        println!(&quot;number was three&quot;);
    }
}
</code></pre>
<p><code>if</code>의 조건이 <code>3</code>으로 산출되고, Rust는 에러를 발생시킵니다.</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected bool, found integral variable
  |
  = note: expected type `bool`
             found type `{integer}`
</code></pre>
<p>이 에러가 나타내는 것은 Rust가 <code>bool</code>을 기대하였으나 정수형이 왔다는 겁니다. Rust는 boolean 타입이
아닌 것을 boolean 타입으로 자동 변환하지 않습니다. Ruby나 Javascript와는 다르죠. 우리는 반드시
명시적으로 <code>boolean</code>을 <code>if</code>의 조건으로 사용해야 합니다. 만약 우리가 <code>if</code>표현식의 코드 블록을 숫자가
<code>0</code>이 아닐 시에 실행하고 싶다면, 다음처럼, 우리는 <code>if</code>표현식을 변경할 수 있습니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;number was something other than zero&quot;);
    }
}
</code></pre></pre>
<p>이번 코드를 실행시키면 <code>number was something other than zero</code>가 출력 될 겁니다.</p>
<a class="header" href="print.html#else-if와-다수-조건" id="else-if와-다수-조건"><h4><code>else if</code>와 다수 조건</h4></a>
<p>우리는 <code>if</code>와 <code>else</code> 사이에 <code>else if</code>식을 추가 결합하여 다양한 조건을 다룰 수 있습니다.
예제를 보시죠:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre></pre>
<p>이번 프로그램은 분기할 수 있는 네 개의 경로를 갖습니다. 이를 수행하면, 다음과 같은 결과를 얻게 될 겁니다:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<p>이 프로그램이 실행될 때, <code>if</code>식을 차례대로 검사하고 검사 조건이 참일 때의 첫 번째 본문을 실행합니다. 주목할 점은
6을 2로 나누어 떨어짐에도 불구하고 <code>number is divisible by 2</code>이 출력되지 않는데, <code>else</code>의
블럭에 위치한 <code>number is not divisible by 4, 3, or 2</code>도 마찬가지입니다. 이렇게 되는 이유는
Rust가 첫 번째로 조건이 참이 되는 블록만 찾아 실행하고, 한번 찾게 되면 나머지는 검사하지 않기 때문입니다.</p>
<p>너무 많은 <code>else if</code>식의 사용은 당신의 코드를 이해하기 어렵게 하므로, 둘 이상일 경우 코드를 리팩토링하게
될 수도 있습니다. 이런 경우를 위해 6장에서 <code>match</code>라 불리는 강력한 분기 생성자를 다룹니다.</p>
<a class="header" href="print.html#let구문에서-if-사용하기" id="let구문에서-if-사용하기"><h4><code>let</code>구문에서 <code>if</code> 사용하기</h4></a>
<p><code>if</code>가 표현식이기 때문에, 항목 3-4에서 처럼, 우리는 이를 <code>let</code> 구문의 우측에 사용할 수 있죠.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre></pre>
<p><span class="caption">Listing 3-4: Assigning the result of an <code>if</code> expression
to a variable</span></p>
<p>변수 <code>number</code>에는 <code>if</code>식에서 산출된 값이 bound되게 됩니다. 어떤 일이 일어날지 코드를 실행해보죠:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<p>기억하세요! 코드 블록은 그들의 마지막에 위치한 표현식을 산출하며 숫자는 그 자체로 표현식이라는 것을요. 이 경우
전체 <code>if</code>식의 값은 실행되는 코드 블럭에 따라 다릅니다. 그렇기에 <code>if</code>식에 속한 각 갈래의 결과는 반드시 같은
타입이여야 합니다. 항목 3-4에서 <code>if</code>갈래와 <code>else</code>갈래는 모두 <code>i32</code> 정수형을 결과 값으로 가집니다.
하지만 만약 다음 예제처럼 유형이 다르면 어떻게 될까요?</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let condition = true;

    let number = if condition {
        5
    } else {
        &quot;six&quot;
    };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre>
<p>우리가 이번 코드를 실행시키려고 하면 에러를 얻게 됩니다. <code>if</code>와 <code>else</code> 갈래의 값 타입이 호환되지 않고,
Rust는 정확히 프로그램의 어느 지점에 문제가 있는지 보여줍니다.</p>
<pre><code class="language-text">error[E0308]: if and else have incompatible types
 --&gt; src/main.rs:4:18
  |
4 |       let number = if condition {
  |  __________________^
5 | |         5
6 | |     } else {
7 | |         &quot;six&quot;
8 | |     };
  | |_____^ expected integral variable, found reference
  |
  = note: expected type `{integer}`
             found type `&amp;'static str`
</code></pre>
<p><code>if</code> 블록이 정수형을 산출하는 식이고 <code>else</code> 블록은 문자열을 산출하는 식 입니다. 이런 경우가 성립하지 않는
이유는 변수가 가질 수 있는 타입이 오직 하나이기 때문입니다. Rust는 컴파일 시에 <code>number</code> 변수의 타입이 뭔지
확실히! 정의해야 합니다. 그래야 <code>number</code>가 사용되는 모든 곳에서 유효한지 검증할 수 있으니까요. Rust는
<code>number</code>의 타입을 실행 시에 정의되도록 할 수 없습니다. 컴파일러가 모든 변수의 다양한 타입을 추적해서 알아내야<br />
한다면 컴파일러는 보다 복잡해지고 보증할 수 있는 것은 적어지게 됩니다.</p>
<a class="header" href="print.html#반복문과-반복" id="반복문과-반복"><h3>반복문과 반복</h3></a>
<p>코드 블록을 한 번 이상 수행하는 것은 자주 유용합니다. 반복 작업을 위해서, Rust는 몇 가지 <em>반복문</em>을 제공합니다.
반복문은 반복문 시작부터 끝까지 수행하고 다시 처음부터 수행합니다. 반복문의 실험해보기 위해 <em>loops</em>으로 명명된
새 프로젝트를 작성해 봅시다.</p>
<p>Rust가 제공하는 세 가지 반복문: <code>loop</code>, <code>while</code>, 그리고 <code>for</code>을 모두 사용해 봅시다.</p>
<a class="header" href="print.html#loop와-함께-코드의-반복-수행" id="loop와-함께-코드의-반복-수행"><h4><code>loop</code>와 함께 코드의 반복 수행</h4></a>
<p><code>loop</code> keyword는 Rust에게 그만두라고 명시하여 알려주기 전까지 코드 블럭을 반복 수행합니다.
예제로, 우리의 <em>loops</em>디렉토리에 <em>src/main.rs</em>를 다음처럼 변경하세요:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;again!&quot;);
    }
}
</code></pre>
<p>이 프로그램을 실행시키면, 우리는 프로그램을 강제 정지하기 전까지 <code>again!</code>이 반복 출력되는 것을 보게 됩니다.
대부분의 터미널은 ctrl-C를 통해 프로그램을 정지시키는 기능을 지원하니 이를 시도해 보세요:</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p>기호 <code>^C</code>는 우리가 ctrl-C를 눌렀을 때의 위치입니다. 코드가 정지 신호를 받은 시점에 따라 <code>^C</code> 이후에
<code>again!</code>이 출력될 수도 아닐 수도 있습니다.</p>
<p>다행스럽게도, Rust는 보다 안정적으로 루프에서 벗어날 수 있는 방법을 제공합니다. 우리는 <code>break</code> keyword
를 위치시켜 프로그램이 언제 루프를 멈춰야 하는지 알려줄 수 있습니다. 상기시켜 드리자면 2장 “추리 게임”에서
사용자가 모든 숫자를 정확히 추리했을 경우 프로그램을 종료시키기 위해 사용했었습니다.</p>
<a class="header" href="print.html#while와-함께하는-조건부-반복" id="while와-함께하는-조건부-반복"><h4><code>while</code>와 함께하는 조건부 반복</h4></a>
<p>반복문 내에서 조건을 산출하는 것은 자주 유용합니다. 조건이 참인 동안 반복문을 수행합니다. 조건이 참이 아니게 된 경우에
<code>break</code>을 호출하여 반복을 정지시킵니다. 이런 패턴의 반복문을 구현하자면 <code>loop</code>, <code>if</code>, <code>else</code>, 그리고
<code>break</code>를 혼합해야 합니다; 원한다면 이렇게 사용해도 됩니다.</p>
<p>하지만, 이런 패턴은 매우 보편적이기 때문에 이와 동일한 구조자가 Rust에는 내장되어 있으며, 이를 <code>while</code>
반복문이라 부릅니다. 다음의 예제를 통해 <code>while</code>을 사용해 봅시다: 프로그램은 세 번 반복되고, 반복 때마다
카운트 다운됩니다. 마침내 반복이 끝나면 다른 메시지를 출력하고 종료됩니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{}!&quot;, number);

        number = number - 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p>이 구조자는 loop, if, else 및 break를 사용하는 경우 필요한 많은 중첩을 제거하며, 더 깔끔합니다.
조건이 true인 동안 코드가 실행되고; 그렇지 않으면 루프에서 벗어납니다.</p>
<a class="header" href="print.html#for와-함께하는-콜렉션-반복하기" id="for와-함께하는-콜렉션-반복하기"><h4><code>for</code>와 함께하는 콜렉션 반복하기</h4></a>
<p>우리는 <code>while</code> 구조자를 통해 배열과 같은, 콜렉션의 각 요소에 걸쳐 반복 수행 할 수 있습니다. 예:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;the value is: {}&quot;, a[index]);

        index = index + 1;
    }
}
</code></pre></pre>
<p><span class="caption">Listing 3-5: Looping through each element of a collection
using a <code>while</code> loop</span></p>
<p>여기서, 코드는 배열의 요소에 걸쳐 카운트를 증가시킵니다. 이 색인은 <code>0</code>에서 시작하고, 배열의 마지막 순서까지 반복됩니다
(즉, <code>index &lt; 5</code>가 참이 아닐 때까지). 이 코드를 수행하면 배열의 모든 요소가 출력되게 됩니다.</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>예상했던 대로, 5개인 배열 모든 값이 터미널에 표시됩니다. <code>index</code> 값이 <code>5</code>에 오는 시점에,
그러니까 배열의 6번째 값에 접근하기 전에 반복은 중지되어야 합니다.</p>
<p>그러나 이런 방식은 에러가 발생하기 쉽습니다; 우리가 정확한 길이의 색인을 사용하지 못하면 프로그램은 패닉을 발생합니다.
또한 느린데, 이유는 컴파일러가 실행 간에 반복문을 통해 반복될 때마다 요소에 대한 조건 검사를 수행하는 런타임 코드를
추가하기 때문입니다.</p>
<p>보다 효율적은 대안으로, 우리는 <code>for</code> 반복문을 사용하여 콜렉션의 각 요소에 대한 코드를 수행할 수 있습니다.
<code>for</code>반복문은 다음과 같습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!(&quot;the value is: {}&quot;, element);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 3-6: Looping through each element of a collection
using a <code>for</code> loop</span></p>
<p>우리가 이 코드를 수행하면, 항목 3-5와 같은 결과를 볼 수 있습니다. 더 중요한 것은, 우리는 이제 코드의 안전성을 높이고
배열의 끝을 넘어가거나 충분한 길이를 지정하지 못해 일부 아이템이 누락되어 발생할 수있는 버그의 가능성을 제거했습니다.</p>
<p>예를 들어, 코드 3-5의 코드에서 a 배열 에서 항목을 제거 했지만 조건을 <code>while index &lt; 4</code>로 업데이트하지
않으면 코드는 패닉을 발생합니다. for루프를 사용하면, 당신이 배열의 수를 변경 한 경우에도 다른 코드를 변경해야
할 필요가 없습니다. (역주 : 당신은 살면서 변경한 배열의 수를 기억하고 있는가?)</p>
<p><code>for</code>반복문이 안전하고 간결하기 때문에 이들은 가장 보편적으로 사용되는 반복문 구조자입니다. 항목 3-5에서처럼
<code>while</code>반복문을 사용하여 특정 횟수만큼 코드를 반복하려는 경우에도, 대부분의 Rust 사용자들은 <code>for</code>반복문
을 사용하고자 할 것 입니다. 이런 사용을 위해 Rust에서 기본 라이브러리로 제공하는 <code>Range</code>를 사용하게 됩니다.
<code>Range</code>는 한 숫자에서 다른 숫자 전까지 모든 숫자를 차례로 생성합니다.</p>
<p>여기 <code>for</code>반복문과 아직 설명하지 않은 range를 역순하는 <code>rev</code>메소드를 사용하는 카운트다운 프로그램이 있습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{}!&quot;, number);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p>꽤 괜찮은 코드인것 같죠?</p>
<a class="header" href="print.html#결론" id="결론"><h2>결론</h2></a>
<p>해냈어요! 무지 긴 장이었어: 우리는 변수, 스칼라, <code>if</code>식과 반복문까지 배웠어요! 혹시 이번 장에서 나온 내용을
연습해보고 싶으면 다음을 수행하는 프로그램을 만들어 보세요.</p>
<ul>
<li>화씨와 섭씨를 상호 변환.</li>
<li>n번째 피보나치 수열 생성.</li>
<li>크리스마스 캐롤 “The Twelve Days of Christmas”의 가사를 반복문을 활용해 출력.</li>
</ul>
<p>다음으로 넘어갈 준비가 되셨습니까? 우리는 이제 일반적인 다른 언어에는 존재하지 않는 개념에 대해서 다루고자 합니다
: 소유권.</p>
<a class="header" href="print.html#소유권-이해하기" id="소유권-이해하기"><h1>소유권 이해하기</h1></a>
<p>소유권(Ownership)은 러스트의 가장 유니크한 특성이며, 러스트가 가비지 콜렉터 없이 메모리 안정성 보장을
하게 해줍니다. 그러므로, 소유권이 러스트 내에서 어떻게 동작하는지 이해하는 것은 중요합니다. 이 장에서는
소유권 뿐만 아니라 이와 관련된 특성들: 빌림, 슬라이스, 그리고 러스트가 메모리에 데이터를 저장하는지 등을
알아보겠습니다.</p>
<a class="header" href="print.html#소유권이-뭔가요" id="소유권이-뭔가요"><h2>소유권이 뭔가요?</h2></a>
<p>러스트의 핵심 기능은 바로 소유권입니다. 이 기능은 직관적으로 설명할 수 있지만, 언어의 나머지 부분에
깊은 영향을 끼칩니다.</p>
<p>모든 프로그램은 실행하는 동안 컴퓨터의 메모리를 사용하는 방법을 관리해야 합니다. 몇몇 언어들은 프로그램이
실행될 때 더이상 사용하지 않는 메모리를 끊임없이 찾는 가비지 콜렉션을 갖고 있습니다; 다른 언어들에서는
프로그래머가 직접 명시적으로 메모리를 할당하고 해제해야 합니다. 러스트는 제 3의 접근법을 이용합니다:
메모리는 컴파일 타임에 컴파일러가 체크할 규칙들로 구성된 소유권 시스템을 통해 관리됩니다. 소유권 기능들의
어떤 것도 런타임 비용이 발생하지 않습니다.</p>
<p>소유권이란 개념이 많은 프로그래머들에게 새로운 것이기 때문에, 이해하고 사용하는 데에는 약간의 시간이
걸립니다만, 좋은 소식은 여러분이 러스트와 소유권 시스템의 규칙에 더 많은 경험을 할수록, 여러분은 더
안전하고 더 효율적인 코드를 자연스럽게 개발할 수 있게될 것이라는 거죠. 견뎌내세요!</p>
<p>여러분이 소유권을 이해했을 때, 여러분은 러스트를 유니크하게 만드는 기능들을 이해하기 위한 견고한 기초를
가지게 될 것입니다. 이 장에서, 여러분은 매우 흔한 데이터 구조인 문자열에 집중된 몇가지 예제를 통해
소유권에 대해 배우게 될 것입니다.</p>
<!-- PROD: START BOX -->
<blockquote>
<a class="header" href="print.html#스택과-힙" id="스택과-힙"><h3>스택과 힙</h3></a>
<p>많은 프로그래밍 언어들 안에서, 우리는 그렇게 자주 스택과 힙에 대한 생각을 할 필요가 없습니다. 그렇지만
러스트와 같은 시스템 프로그래밍 언어에서는, 값이 스택에 있는지 힙에 있는지의 여부가 언어의 동작 방식과
우리의 결단에 더 큰 영향을 줍니다. 우리는 이 장의 뒤쪽에서 스택과 힙에 관계된 소유권의 일부분을 기술할
것이기에, 여기서는 준비 삼아 간략한 설명만 하겠습니다.</p>
<p>스택과 힙 둘다 여러분의 코드상에서 런타임에 사용할 수 있는 메모리의 부분입니다만, 이들은 각기 다른
방식으로 구조화 되어 있습니다. 스택은 값을 받아들인 순서대로 값을 저장하고 반대 방향으로 값을 지웁니다.
이것을 <em>last in, first out</em>이라고 하죠. 쌓여있는 접시를 생각해보세요; 여러분이 접시를 더 추가하려면
접시더미의 꼭대기에 쌓아올리고, 여러분이 접시가 필요해지면 꼭대기에서부터 한장 꺼내게 됩니다. 중간이나
밑에서부터 접시를 추가하거나 제거하는 건 잘 안될겁니다! 데이터를 추가하는 것을 <em>스택에 푸시하기</em>
(<em>pushing on the stack</em>)라고 부르고, 데이터를 제거하는 것을 <em>스택을 팝하기</em> (<em>popping off
the stack</em>)라고 부릅니다.</p>
<p>스택은 데이터에 접근하는 방식 덕택에 빠릅니다: 이 방식은 새로운 데이터를 넣어두기 위한 공간 혹은 데이터를
가져올 공간을 검색할 필요가 전혀 없는데, 바로 그 공간이 항상 스택의 꼭대기(top)이기 때문입니다. 스택을
빠르게 해주는 또다른 특성은 스택에 담긴 모든 데이터가 결정되어 있는 고정된 크기를 갖고 있어야 한다는
점입니다.</p>
<p>컴파일 타임에 크기가 결정되어 있지 않거나 크기가 변경될 수 있는 데이터를 위해서는, 힙에 데이터를 저장할
수 있습니다. 힙은 조금 더 복잡합니다: 데이터를 힙에 넣을때, 먼저 저장할 공간이 있는지 물어봅니다. 그러면
운영체제가 충분히 커다란 힙 안의 빈 어떤 지점을 찾아서 이 곳을 사용중이라고 표시하고, 해당 지점의 포인터를
우리에게 돌려주죠. 이 절차를 <em>힙 공간 할당하기</em>(<em>allocating on the heap</em>)라고 부르고, 종종 그냥
&quot;할당(allocating)&quot;으로 줄여 부릅니다. 스택에 포인터를 푸싱하는 것은 할당에 해당되지 않습니다. 포인터는
결정되어 있는 고정된 크기의 값이므로, 우리는 스택에 포인터를 저장할 수 있지만, 실제 데이터를 사용하고자
할 때는 포인터를 따라가야 합니다.</p>
<p>힙에 저장된 데이터에 접근하는 것은 스택에 저장된 데이터에 접근하는 것보다 느린데, 그 이유는 포인터가
가리킨 곳을 따라가야 하기 때문입니다. 현대 프로세서들은 메모리 내부를 덜 뛰어다닐 때 더 빨라집니다. 유사한
예로, 여러 테이블로부터 주문을 받는 레스토랑의 웨이터를 생각해보세요. 다음 테이블로 움직이기 전에 지금
테이블에서 모든 주문을 다 받는 것이 가장 효율적이겠죠. A 테이블에서 하나 주문 받고, 다시 B 테이블로
가서 하나 주문 받고, 다시 A로, 다시 B로 가며 하나씩 주문을 받으면 훨씬 느려질 겁니다. 이와 마찬가지로,
프로세서는 (힙에 있는 데이터와 같이) 멀리 떨어져 있는 데이터들 보다는 (스택에 있는 것과 같이) 붙어있는
데이터들에 대한 작업을 하면 더 빨라집니다. 힙으로부터 큰 공간을 할당받는것 또한 시간이 걸릴 수 있습니다.</p>
<p>코드의 어느 부분이 힙의 어떤 데이터를 사용하는지 추적하는 것, 힙의 중복된 데이터의 양을 최소화하는 것,
그리고 힙 내에 사용하지 않는 데이터를 제거하여 공간이 모자라지 않게 하는 것은 모두 소유권과 관계된
문제들입니다. 여러분이 소유권을 이해하고 나면, 여러분은 더이상 스택과 힙에 대한 생각이 자주 필요치 않게
될겁니다만, 힙 데이터를 관리하는 것이 곧 소유권의 존재 이유임을 알게 되는 것은 이것이 어떤 방식으로
작동하는지 설명하는데 도움을 줄 수 있습니다.</p>
</blockquote>
<!-- PROD: END BOX -->
<a class="header" href="print.html#소유권-규칙" id="소유권-규칙"><h3>소유권 규칙</h3></a>
<p>먼저, 소유권 규칙을 알아봅시다. 이것들을 설명할 예제들을 보는 내내 다음의 소유권 규칙들을 명심하세요:</p>
<blockquote>
<ol>
<li>러스트의 각각의 값은 해당값의 <em>오너</em>(<em>owner</em>)라고 불리우는 변수를 갖고 있다.</li>
<li>한번에 딱 하나의 오너만 존재할 수 있다.</li>
<li>오너가 스코프 밖으로 벗어나는 때, 값은 내려간다(dropped).</li>
</ol>
</blockquote>
<a class="header" href="print.html#변수의-스코프" id="변수의-스코프"><h3>변수의 스코프</h3></a>
<p>우리는 이미 2장에서 완성된 형태의 러스트 프로그램 예제를 살펴봤습니다. 이제 과거의 기초 문법 형태로
돌아가서, <code>fn main() {</code> 코드를 예제에 붙이지 않을테니, 여러분들이 코드를 따라하려면 <code>main</code> 함수에
직접 예제들을 넣어야 할 겁니다. 결과적으로, 우리의 예제들은 좀더 간략해저셔 보일러 플레이트 코드에 비해
실제 디테일에 초점을 맞출 수 있도록 해줄 것입니다.</p>
<p>소유권에 대한 첫 예제로서, 변수들의 스코프를 보겠습니다. 스코프란 프로그램 내에서 아이템이 유효함을
표시하기 위한 범위입니다. 아래처럼 생긴 변수가 있다고 해봅시다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;hello&quot;;
#}</code></pre></pre>
<p>변수 <code>s</code>는 스트링 리터럴을 나타내는데, 스트링 리터럴의 값은 우리의 프로그램의 텍스트 내에 하드코딩되어
있습니다. 변수는 선언된 시점부터 현재의 <em>스코프</em>가 끝날 때까지 유효합니다. 아래 예제 Listing 4-1은
변수 <code>s</code>가 유효한 지점을 주석으로 표시했습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{                      // s는 유효하지 않습니다. 아직 선언이 안됐거든요.
    let s = &quot;hello&quot;;   // s는 이 지점부터 유효합니다.

    // s를 가지고 뭔가 합니다.
}                      // 이 스코프는 이제 끝이므로, s는 더이상 유효하지 않습니다.
#}</code></pre></pre>
<p><span class="caption">Listing 4-1: 변수와 이 변수가 유효한 스코프</span></p>
<p>바꿔 말하면, 두가지 중요한 지점이 있습니다:</p>
<ol>
<li>스코프 <em>안에서</em> <code>s</code>가 등장하면, 유효합니다.</li>
<li>이 유효기간은 스코프 <em>밖으로</em> 벗어날 때까지 지속됩니다.</li>
</ol>
<p>이 지점에서, 스코프와 변수가 유효한 시점 간의 관계는 다른 프로그래밍 언어와 비슷합니다. 이제 우리는
이에 대한 이해를 기초로 하여 <code>String</code> 타입을 소개함으로써 계속 쌓아나갈 것입니다.</p>
<a class="header" href="print.html#string-타입" id="string-타입"><h3><code>String</code> 타입</h3></a>
<p>소유권 규칙을 설명하기 위하여, 우리는 3장에서 다룬 바 있는 타입보다 더 복잡한 데이터 타입이
필요합니다. 우리가 이전에 봐온 모든 데이터 타입들은 스텍에 저장되었다가 스코프를 벗어날 때
스택으로부터 팝 됩니다만, 우리는 이제 힙에 저장되는 데이터를 관찰하고 러스트는 과연 어떻게 이
데이터를 비워내는지 설명할 필요가 있습니다.</p>
<p>우리는 여기서 <code>String</code>을 예제로 활용하되, 소유권과 관련된 <code>String</code> 내용의 일부분에 집중할
것입니다. 이러한 관점은 표준 라이브러리나 여러분들이 만들 다른 복잡한 데이터 타입에도 적용됩니다.
<code>String</code>에 대해서는 8장에서 더 자세히 다루겠습니다.</p>
<p>스트링 리터럴을 이미 봤는데, 이 값은 프로그램 안에 하드코딩 되어 있습니다. 문자열 값은 편리하지만,
여러분이 텍스트를 필요로 하는 모든 경우에 대해 항상 적절하진 않습니다. 그 중 한가지 이유로, 문자열
값은 불변입니다(immutable). 또다른 이유는 모든 문자열이 우리가 프로그래밍 하는 시점에서 다 알수
있는 것이 아니란 점입니다: 예를 들면, 사용자의 입력을 받아 저장하고 싶다면요? 이러한 경우들에 대해서,
러스트는 두번째 문자열 타입인 <code>String</code>을 제공합니다. 이 타입은 힙에 할당되고 그런고로 컴파일 타임에는
우리가 알 수 없는 양의 텍스트를 저장할 수 있습니다. 여러분은 스트링 리터럴로부터 <code>from</code>이라는 함수를
이용해서 <code>String</code>을 아래처럼 만들 수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);
#}</code></pre></pre>
<p>더블 콜론(<code>::</code>)은 우리가 <code>string_from</code>과 같은 이름을 쓰기 보다는 <code>String</code> 타입 아래의
<code>from</code> 함수를 특정지을 수 있도록 해주는 네임스페이스 연산자입니다. 우리는 이러한 문접에 대해 5장의
&quot;메소드 문법&quot; 부분에서 더 자세히 다룰 것이고, 모듈에서의 네임스페이스와 관련한 이야기는 7장에서 할
것입니다.</p>
<p>이러한 종류의 문자열은 변경 가능합니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;hello&quot;);

s.push_str(&quot;, world!&quot;); // push_str()은 해당 스트링 리터럴을 스트링에 붙여줍니다.

println!(&quot;{}&quot;, s); // 이 부분이 `hello, world!`를 출력할 겁니다.
#}</code></pre></pre>
<p>그러니까, 여기서 어떤게 달라졌나요?, 왜 <code>String</code>은 변할 수 있는데 스트링 리터럴은 안될까요?
차이점은 두 타입이 메모리를 쓰는 방식에 있습니다.</p>
<a class="header" href="print.html#메모리와-할당" id="메모리와-할당"><h3>메모리와 할당</h3></a>
<p>스트링 리터럴의 경우, 우리는 내용물을 컴파일 타임에 알 수 있으므로 텍스트가 최종
실행파일에 직접 하드코딩 되었고, 이렇게 하면 스트링 리터럴이 빠르고 효율적이 됩니다.
그러나 이는 문자열이 변경되지 않는 것을 전재로 하는 특성입니다. 불행하게도, 우리는
컴파일 타임에 크기를 알 수 없는 경우 및 실행 중 크기가 변할 수도 있는 경우의 텍스트
조각을 바이너리 파일에 집어넣을 수 없습니다.</p>
<p><code>String</code> 타입은 변경 가능하고 커질 수 있는 텍스트를 지원하기 위해 만들어졌고, 우리는
힙에서 컴파일 타임에는 알 수 없는 어느 정도 크기의 메모리 공간을 할당받아 내용물을
저장할 필요가 있습니다. 이는 즉 다음을 의미합니다:</p>
<ol>
<li>런타임에 운영체제로부터 메모리가 요정되어야 한다.</li>
<li><code>String</code>의 사용이 끝났을 때 운영체제에게 메모리를 반납할 방법이 필요하다.</li>
</ol>
<p>첫번째는 우리가 직접 수행합니다: 우리가 <code>String::from</code>을 호출하면, 구현부분에서
필요한 만큼의 메모리를 요청합니다. 이는 프로그래밍 언어들 사이에서 매우 일반적입니다.</p>
<p>하지만, 두번째는 다릅니다. *가비지 콜렉터(GC)*를 갖고 있는 언어들의 경우, GC가
더이상 사용하지 않는 메모리 조각을 계속해서 찾고 지워주며, 우리는 프로그래머로서
이와 관련한 생각을 안해도 됩니다. GC가 없을 경우, 할당받은 메모리가 더 필요없는
시점을 알아서 명시적으로 이를 반납하는 코드를 호출하는 것은 프로그래머의 책임입니다.
이를 올바르게 하는 것은 역사적으로 어려운 문제로 취급받았습니다. 우리가 잊어먹으면?
메모리를 낭비하는 것이죠. 너무 빨리 반납해버리면? 유효하지 않은 변수를 갖게 될 겁니다.
만일 반납을 두번하면? 이것도 버그죠. 우리는 딱 한번의 <code>allocate</code>와 한번의 <code>free</code> 쌍을
사용해야 합니다.</p>
<p>러스트는 다른 방식으로 이 문제를 다룹니다: 메모리는 변수가 소속되어 있는 스코프 밖으로
벗어나는 순간 자동으로 반납됩니다. 여기 스트링 리터럴 대신 <code>String</code>을 사용한 Listing
4-1의 스코프 예제가 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let s = String::from(&quot;hello&quot;); // s는 여기서부터 유효합니다

    // s를 가지고 뭔가 합니다
}                                  // 이 스코프는 끝났고, s는 더 이상 
                                   // 유효하지 않습니다
#}</code></pre></pre>
<p><code>String</code>이 요구한 메모리를 운영체제에게 반납하는 자연스러운 지점이 있죠: <code>s</code>가 스코프
밖으로 벗어날 때입니다. 변수가 스코프 밖으로 벗어나면, 러스트는 우리를 위해 특별한 함수를
호출합니다. 이 함수를 <code>drop</code>이라고 부르고, <code>String</code>의 개발자가 메모리를 반환하도록 하는
를 집어넣을 수 있습니다. 러스트는 <code>}</code> 괄호가 닫힐때 자동적으로 <code>drop</code>을 호출합니다.</p>
<blockquote>
<p>노트: C++에서는 이렇게 아이템의 수명주기의 끝나는 시점에 자원을 해제하는 패턴을 종종
<em>자원 습득이 곧 초기화</em> (<em>Resource Acquisition Is Initialization, RAII</em>) 라고
부릅니다. 러스트의 <code>drop</code> 함수는 여러분이 RAII 패턴을 경험해본 적 있다면 익숙할
것입니다.</p>
</blockquote>
<p>이 패턴은 러스트 코드가 작성되는 방법에 깊은 영향을 줍니다. 지금은 단순해 보이시겠지만,
우리가 힙에 할당시킨 데이터를 사용하는 여러 개의 변수를 사용하고자 할 경우와 같이 좀더
복잡한 상황에서, 코드의 동작은 예기치 못할 수 있습니다. 이제 그런 경우들을 좀더
탐험해봅시다.</p>
<a class="header" href="print.html#변수와-데이터가-상호작용하는-방법-이동move" id="변수와-데이터가-상호작용하는-방법-이동move"><h4>변수와 데이터가 상호작용하는 방법: 이동(move)</h4></a>
<p>여러 개의 변수들은 러스트에서 서로 다른 방식으로 같은 데이터에 대해 상호작용을 할 수
있습니다. Listing 4-2의 정수형을 이용한 예제를 한번 보겠습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;
#}</code></pre></pre>
<p><span class="caption">Listing 4-2: 변수 <code>x</code>의 정수값을 <code>y</code>에 대입하기</span></p>
<p>우리는 아마도 다른 언어들에서의 경험을 토대로 어떤 일이 벌어지는지 추측할 수 있습니다:
“정수값 <code>5</code>를 <code>x</code>에 묶어놓고; <code>x</code>의 값의 복사본을 만들어 <code>y</code>에 묶는다.” 우리는 이제
<code>x</code>와 <code>y</code> 두 개의 변수를 갖게 되었고, 둘 다 <code>5</code>와 같습니다. 정수값이 결정되어 있는
고정된 크기의 단순한 값이고, <code>5</code>라는 값들이 스택에 푸쉬되기 때문에, 실제로도 이렇게
됩니다.</p>
<p>이제 <code>String</code> 버전을 봅시다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
#}</code></pre></pre>
<p>이 코드는 이전의 코드와 매우 유사해 보여서, 동작하는 방식도 동일할 것이라고 가정할지도
모르겠습니다: 즉, 두번째 줄이 <code>s1</code>의 복사본을 만들어서 <code>s2</code>에 묶어놓는 식으로 말이죠.
그렇지만 이는 실제 동작과 다른 생각입니다.</p>
<p>좀 더 완전히 설명하기 위해, <code>String</code>이 Figure 4-3에서와 같이 생겼다는 것을 주목합시다.
<code>String</code>은 그림의 완쪽과 같이 세 개의 부분으로 이루어져 있습니다: 문자열의 내용물을
담고 있는 메모리의 포인터, 길이, 그리고 용량입니다. 이 데이터의 그룹은 스택에 저장됩니다.
내용물을 담은 오른쪽의 것은 힙 메모리에 있습니다.</p>
<p><img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 4-3: <code>s1</code> 변수에 <code>&quot;hello&quot;</code>값이 저장된 <code>String</code>의
메모리 구조</span></p>
<p>길이값은 바이트 단위로 <code>String</code>의 내용물이 얼마나 많은 메모리를 현재 사용하고 있는지를
말합니다. 용량값은 바이트 단위로 <code>String</code>이 운영체제로부터 얼마나 많은 양의 메모리를
할당 받았는지를 말합니다. 길이와 용량의 차이는 중요합니다만, 이번 내용에서는 아닙니다.
그러니까 현재로서는 용량값을 무시하셔도 좋겠습니다.</p>
<p><code>s2</code>에 <code>s1</code>을 대입하면, <code>String</code> 데이터가 복사되는데, 이는 스택에 있는 포인터, 길이값,
그리고 용량값이 복사된다는 의미입니다. 포인터가 가리키고 있는 힙 메모리 상의 데이터는
복사되지 않습니다. 달리 말하면, 메모리 내의 데이터 구조는 Figure 4-4와 같이 됩니다.</p>
<p><img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 4-4: <code>s1</code>의 포인터, 길이값, 용량값이 복사된 <code>s2</code> 변수의
메모리 구조</span></p>
<p>메모리 구조는 Figure 4-5와 같지 <em>않는데</em>, 이 그림은 러스트가 힙 메모리 상의 데이터까지도
복사한다면 벌어질 일입니다. 만일 러스트가 이렇게 동작한다면, 힙 안의 데이터가 클 경우
<code>s2 = s1</code> 연산은 런타임 상에서 매우 느려질 가능성이 있습니다.</p>
<p><img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 4-5: 러스트가 힙 데이터까지 복사하게 될 경우 <code>s2 = s1</code>가
만들 또다른 가능성</span></p>
<p>앞서 우리는 변수가 스코프 밖으로 벗어날 때, 러스트는 자동적으로 <code>drop</code>함수를 호출하여
해당 변수가 사용하는 힙 메모리를 제거한다고 했습니다. 하지만 Figure 4-4에서는 두 데이터
포인터가 모두 같은 곳을 가리키고 있는 것이 보입니다. 이는 곧 문제가 됩니다: <code>s2</code>와 <code>s1</code>이
스코프 밖으로 벗어나게 되면, 둘 다 같은 메모리를 해제하려 할 것입니다. 이는 <em>두번 해제</em>
(<em>double free</em>) 오류라고 알려져 있으며 이전에 언급한 바 있는 메모리 안정성 버그들 중
하나입니다. 메모리를 두번 해제하는 것은 메모리 손상(memory corruption)의 원인이 되는데,
이는 보안 취약성 문제를 일으킬 가능성이 있습니다.</p>
<p>메모리 안정성을 보장하기 위해서, 러스트에서는 이런 경우 어떤 일이 일어나는지 한가지 더
디테일이 있습니다. 할당된 메모리를 복사하는 것을 시도하는 대신, 러스트에서는 <code>s1</code>이
더이상 유효하지 않다고 간주하고, 그러므로 러스트는 <code>s1</code>가 스코프 밖으로 벗어났을 때
이무것도 해제할 필요가 없어집니다. <code>s1</code>을 <code>s2</code>가 만들어진 후에 사용하려고 할때 어떤
일이 벌어지는지 확인해 봅시다:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;

println!(&quot;{}&quot;, s1);
</code></pre>
<p>여러분은 아래와 같은 에러 메세지를 보게 될텐데, 그 이유는 러스트가 여러분으로부터
유효하지 않은 참조자를 사용하는 것을 막기 때문입니다:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `s1`
 --&gt; src/main.rs:4:27
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`,
which does not implement the `Copy` trait
</code></pre>
<p>만일 여러분이 다른 언어로 프로그래밍 하는 동안 “얕은 복사(shallow copy)”와 “깊은
복사(deep copy)”라는 용어를 들어보셨다면, 데이터의 복사 없이 포인터와 길이값 및
용량값만 복사한다는 개념이 얕은 복사와 비슷하게 들릴지도 모르겠습니다. 하지만
러스트는 첫번째 변수를 무효화 시키기도 하기 때문에, 이를 얕은 복사라고 부르는 대신
<em>이동</em>(<em>move</em>)이라 말합니다. 여기서 우리는 <code>s1</code>이 <code>s2</code>로 <em>이동되었다</em>라고 말하는
식으로 위 코드를 읽을 것입니다. 그러므로 실제로 일어낸 일은 Figure 4-6과 같습니다.</p>
<p><img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 4-6: <code>s1</code>이 무효화된 후의 메모리 구조</span></p>
<p>이것이 우리 문제를 해결해줍니다! 오직 <code>s2</code>만 유효한 상황에서, 스코프 밖으로 벗어나면
혼자 메모리를 해제할 것이고, 일이 잘 처리되겠습니다.</p>
<p>여기에 더해서, 이러한 경우가 함축하는 디자인 선택이 있습니다: 러스트는 결코 자동적으로
여러분의 데이터에 대한 “깊은” 복사본을 만들지 않을 것입니다. 그러므로, 어떠한
<em>자동적인</em> 복사라도 런타임 실행 과정에서 효율적일 것이라 가정할 수 있습니다.</p>
<a class="header" href="print.html#변수와-데이터가-상호작용하는-방법-클론" id="변수와-데이터가-상호작용하는-방법-클론"><h4>변수와 데이터가 상호작용하는 방법: 클론</h4></a>
<p>만일 <code>String</code>의 스택 데이터 만이 아니라, 힙 데이터를 깊이 복사하기를 정말 원한다면,
<code>clone</code>이라 불리우는 공용 메소드를 사용할 수 있습니다. 이 메소드 문법에 대해서는
5장에서 다루게 될 것입니다만, 이 메소드가 많은 프로그래밍 언어들 사이에서 흔한
특성이기 때문에, 여려분은 아마도 전에 이런 것들을 본적이 있을지도 모르겠습니다.</p>
<p><code>clone</code> 메소드가 동작하는 예제를 보겠습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
#}</code></pre></pre>
<p>이 코드는 잘 동작하고 Figure 4-5가 나타내는, 즉 힙 데이터가 <em>정말로</em> 복사되는 동작을
여러분이 명시적으로 만들어낼 수 있는 방법입니다.</p>
<p><code>clone</code>을 호출하는 부분을 보면, 어떤 비용이 많이 들어갈지도 모르는 코드가 실행되는
중이란 것을 알 수 있게 됩니다. 이는 무언가 다른 동작이 수행되는 것을 알려주는 시각적인
지시자입니다.</p>
<a class="header" href="print.html#스택에만-있는-데이터-복사" id="스택에만-있는-데이터-복사"><h4>스택에만 있는 데이터: 복사</h4></a>
<p>우리가 아직 다루지 않은 또다른 부분이 있습니다. 아래 코드는 앞서 Listing 4-2에서
본 정수값을 이용하는 코드로, 잘 동작하며 유효합니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
#}</code></pre></pre>
<p>하지만 이 코드는 우리가 방금 배운 것과 대립되는 것처럼 보입니다: <code>clone</code>을 호출하지
않았지만, <code>x</code>도 유효하며 <code>y</code>로 이동하지도 않았지요.</p>
<p>그 이유는 정수형과 같이 컴파일 타임에 결정되어 있는 크기의 타입은 스택에 모두 저장되기
때문에, 실제 값의 복사본이 빠르게 만들어질 수 있습니다. 이는 변수 <code>y</code>가 생성된 후에
<code>x</code>가 더 이상 유효하지 않도록 해야할 이유가 없다는 뜻입니다. 바꿔 말하면, 여기서는
깊은 복사와 얕은 복사 간의 차이가 없다는 것으로, <code>clone</code>을 호출하는 것이 보통의
얕은 복사와 아무런 차이점이 없어 우리는 이를 그냥 버릴 수 있다는 것입니다.</p>
<p>러스트는 정수형과 같이 스택에 저장할 수 있는 타입에 대해 달수 있는 <code>Copy</code> 트레잇이라고
불리우는 특별한 어노테이션(annotation)을 가지고 있습니다 (트레잇에 관해서는 10장에서
더 자세히 보겠습니다). 만일 어떤 타입이 <code>Copy</code> 트레잇을 갖고 있다면, 대입 과정 후에도
예전 변수를 계속 사용할 수 있습니다. 러스트는 만일 그 타입 혹은 그 타입이 가지고 있는
부분 중에서 <code>Drop</code> 트레잇을 구현한 것이 있다면 <code>Copy</code> 트레잇을 어노테이션 할 수 없게끔
합니다. 만일 어떤 타입이 스코프 밖으로 벗어났을 때 어떤 특수한 동작을 필요로 하고 우리가
그 타입에 대해 <code>Copy</code> 어노테이션을 추가한다면, 컴파일 타임 오류를 보게 됩니다. <code>Copy</code>
어노테이션을 여러분의 타입에 어떤 식으로 추가하는지 알고 싶다면, 부록 C의 파생 가능한
트레잇(Derivable Traits)을 보세요.</p>
<p>그래서 어떤 타입이 <code>Copy</code>가 될까요? 여러분은 주어진 타입에 대해 확신을 하기 위해 문서를
확인할 수도 있겠지만, 일반적인 규칙으로서 단순한 스칼라 값들의 묶음은 <code>Copy</code>가
가능하고, 할당이 필요하거나 어떤 자원의 형태인 경우 <code>Copy</code>를 사용할 수 없습니다.
<code>Copy</code>가 가능한 몇가지 타입을 나열해 보겠습니다:</p>
<ul>
<li><code>u32</code>와 같은 모든 정수형 타입들</li>
<li><code>true</code>와 <code>false</code>값을 갖는 부울린 타입 <code>bool</code></li>
<li><code>f64</code>와 같은 모든 부동 소수점 타입들</li>
<li><code>Copy</code>가 가능한 타입만으로 구성된 튜플들. <code>(i32, i32)</code>는 <code>Copy</code>가 되지만,
<code>(i32, String)</code>은 안됩니다.</li>
</ul>
<a class="header" href="print.html#소유권과-함수" id="소유권과-함수"><h3>소유권과 함수</h3></a>
<p>함수에게 값을 넘기는 의미론(semantics)은 값을 변수에 대입하는 것과 유사합니다.
함수에게 변수를 넘기는 것은 대입과 마찬가지로 이동하거나 복사될 것입니다. Listing
4-7은 변수가 스코프 안으로 들어갔다 밖으로 벗어나는 것을 주석과 함께 보여주는 예입니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s가 스코프 안으로 들어왔습니다.

    takes_ownership(s);             // s의 값이 함수 안으로 이동했습니다...
                                    // ... 그리고 이제 더이상 유효하지 않습니다.
    let x = 5;                      // x가 스코프 안으로 들어왔습니다.

    makes_copy(x);                  // x가 함수 안으로 이동했습니다만,
                                    // i32는 Copy가 되므로, x를 이후에 계속
                                    // 사용해도 됩니다.

} // 여기서 x는 스코프 밖으로 나가고, s도 그 후 나갑니다. 하지만 s는 이미 이동되었으므로,
  // 별다른 일이 발생하지 않습니다.

fn takes_ownership(some_string: String) { // some_string이 스코프 안으로 들어왔습니다.
    println!(&quot;{}&quot;, some_string);
} // 여기서 some_string이 스코프 밖으로 벗어났고 `drop`이 호출됩니다. 메모리는
  // 해제되었습니다.

fn makes_copy(some_integer: i32) { // some_integer이 스코프 안으로 들어왔습니다.
    println!(&quot;{}&quot;, some_integer);
} // 여기서 some_integer가 스코프 밖으로 벗어났습니다. 별다른 일은 발생하지 않습니다.
</code></pre></pre>
<p><span class="caption">Listing 4-7: 소유권과 스코프에 대한 설명이 주석으로 달린 함수들</span></p>
<p>만일 우리가 <code>s</code>를 <code>takes_ownership</code> 함수를 호출한 이후에 사용하려 한다면, 러스트는
컴파일 타임 오류를 낼 것입니다. 이러한 정적 확인은 여러 실수들을 방지해 줍니다.
이후에 변수들을 사용할 수 있는지, 그리고 그러한 것을 소유권 규칙이 막아주는지를
확인해보려면 <code>main</code> 안에 <code>s</code>와 <code>x</code>에 관한 코드를 추가해보세요.</p>
<a class="header" href="print.html#반환-값과-스코프" id="반환-값과-스코프"><h3>반환 값과 스코프</h3></a>
<p>값의 반환 또한 소유권을 이동시킵니다. Listing 4-7과 비슷한 주석이 달린 예제를 하나
봅시다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership은 반환값을 s1에게
                                        // 이동시킵니다.

    let s2 = String::from(&quot;hello&quot;);     // s2가 스코프 안에 들어왔습니다.

    let s3 = takes_and_gives_back(s2);  // s2는 takes_and_gives_back 안으로
                                        // 이동되었고, 이 함수가 반환값을 s3으로
                                        // 도 이동시켰습니다.
} // 여기서 s3는 스코프 밖으로 벗어났으며 drop이 호출됩니다. s2는 스코프 밖으로
  // 벗어났지만 이동되었으므로 아무 일도 일어나지 않습니다. s1은 스코프 밖으로
  // 벗어나서 drop이 호출됩니다.

fn gives_ownership() -&gt; String {             // gives_ownership 함수가 반환 값을
                                             // 호출한 쪽으로 이동시킵니다.

    let some_string = String::from(&quot;hello&quot;); // some_string이 스코프 안에 들어왔습니다.

    some_string                              // some_string이 반환되고, 호출한 쪽의
                                             // 함수로 이동됩니다.
}

// takes_and_gives_back 함수는 String을 하나 받아서 다른 하나를 반환합니다.
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string이 스코프
                                                      // 안으로 들어왔습니다.

    a_string  // a_string은 반환되고, 호출한 쪽의 함수로 이동됩니다.
}
</code></pre></pre>
<p>변수의 소유권은 모든 순간 똑같은 패턴을 따릅니다: 어떤 값을 다른 변수에 대입하면
값이 이동됩니다. 힙에 데이터를 갖고 있는 변수가 스코프 밖으로 벗어나면, 해당 값은
데이터가 다른 변수에 의해 소유되도록 이동하지 않는한 <code>drop</code>에 의해 제거될 것입니다.</p>
<p>모든 함수에 대해 가지고 소유권을 갖고 소유권을 반납하는 것은 조금 지루해 보입니다.
만일 함수에게 값을 사용할 수 있도록 하되 소유권은 갖지 않도록 하고 싶다면요?
함수의 본체로부터 얻어진 결과와 더불어 우리가 넘겨주고자 하는 어떤 값을 다시 쓰고 싶어서
함께 반환받아야 한다면 꽤나 짜증나겠지요.</p>
<p>이게 아래와 같이 튜플을 이용하여 여러 값을 돌려받는 식으로 가능하긴 합니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() returns the length of a String.

    (s, length)
}
</code></pre></pre>
<p>하지만 이건 너무 많이 나간 의례절차고 일반적인 개념로서는 과한 작업이 됩니다.
운좋게도, 러스트는 이를 위한 기능을 갖고 있으며, <em>참조자</em>(<em>references</em>)라고 부릅니다.</p>
<a class="header" href="print.html#참조자references와-빌림borrowing" id="참조자references와-빌림borrowing"><h2>참조자(References)와 빌림(Borrowing)</h2></a>
<p>앞 절의 마지막에 등장한 튜플을 이용하는 이슈는 <code>String</code>을 호출하는 함수 쪽으로
반환함으로써 <code>calculate_length</code>를 호출한 이후에도 여전히 <code>String</code>을 이용할 수 있도록
하는 것인데, 그 이유는 <code>String</code>이 <code>calculate_length</code> 안쪽으로 이동되었기 때문입니다.</p>
<p>여기 값의 소유권을 넘기는 대신 개체에 대한 <em>참조자</em>(<em>reference</em>)를 인자로 사용하는
<code>calculate_length</code> 함수를 정의하고 이용하는 방법이 있습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>첫번째로, 변수 선언부와 함수 반환값에 있던 튜플 코드가 모두 없어진 것에 주목하세요.
두번째로, <code>calculate_length</code> 함수에 <code>&amp;s1</code>를 넘기고, 함수의 정의 부분에는
<code>String</code>이 아니라 <code>&amp;String</code>을 이용했다는 점을 기억하세요.</p>
<p>이 엠퍼센드(&amp;) 기호가 <em>참조자</em>이며, 이는 여러분이 어떤 값을 소유권을 넘기지 않고
참조할수 있도록 해줍니다. Figure 4-8은 이에 대한 다이어그램입니다.</p>
<p><img alt="&String s pointing at String s1" src="img/trpl04-05.svg" class="center" /></p>
<p><span class="caption">Figure 4-8: <code>String s1</code>을 가리키고 있는 <code>&amp;String s</code></span></p>
<p>함수 호출 부분을 좀더 자세히 봅시다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn calculate_length(s: &amp;String) -&gt; usize {
#     s.len()
# }
let s1 = String::from(&quot;hello&quot;);

let len = calculate_length(&amp;s1);
#}</code></pre></pre>
<p><code>&amp;s1</code> 문법은 우리가 <code>s1</code>의 값을 <em>참조</em>하지만 소유하지는 않는 참조자를 생성하도록
해줍니다. 소유권을 갖고 있지는 않기 때문에, 이 참조자가 가리키는 값은 참조자가 스코프
밖으로 벗어났을 때도 메모리가 반납되지 않을 것입니다.</p>
<p>비슷한 이치로, 함수 시그니처도 <code>&amp;</code>를 사용하여 인자 <code>s</code>의 타입이 참조자라는 것을 나타내고
있습니다. 설명을 위한 주석을 달아봅시다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn calculate_length(s: &amp;String) -&gt; usize { // s는 String의 참조자입니다
    s.len()
} // 여기서 s는 스코프 밖으로 벗어났습니다. 하지만 가리키고 있는 값에 대한 소유권이 없기
  // 때문에, 아무런 일도 발생하지 않습니다.
#}</code></pre></pre>
<p>변수 <code>s</code>가 유효한 스코프는 여느 함수의 파라미터의 스코프와 동일하지만, 소유권을 갖고
있지 않으므로 이 참조자가 스코프 밖으로 벗어났을 때 참조자가 가리키고 있는 값은 버리지
않습니다. 또한 실제 값 대신 참조자를 파라미터로 갖고 있는 함수는 소유권을 갖고 있지
않기 때문에 소유권을 되돌려주기 위해 값을 다시 반환할 필요도 없다는 뜻이 됩니다.</p>
<p>함수의 파라미터로 참조자를 만드는 것을 <em>빌림</em>이라고 부릅니다. 실제 생활에서 만일
어떤 사람이 뭔가를 소유하고 있다면, 여러분은 그걸 빌릴 수 있습니다. 여러분의 용무가
끝났을 때는 그것을 돌려주어야 합니다.</p>
<p>그러니까 만일 우리가 빌린 무언가를 고치려고 시도한다면 무슨 일이 생길까요? Listing 4-9의
코드를 시험해보세요. 스포일러 경고: 작동이 안될겁니다!</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let s = String::from(&quot;hello&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>
<p><span class="caption">Listing 4-9: 빌린 값을 고치려 해보기</span></p>
<p>여기 오류를 보시죠:</p>
<pre><code class="language-text">error: cannot borrow immutable borrowed content `*some_string` as mutable
 --&gt; error.rs:8:5
  |
8 |     some_string.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^
</code></pre>
<p>변수가 기본적으로 불변인 것처럼, 참조자도 마찬가지입니다. 우리가 참조하는 어떤 것을
변경하는 것은 허용되지 않습니다.</p>
<a class="header" href="print.html#가변-참조자mutable-references" id="가변-참조자mutable-references"><h3>가변 참조자(Mutable References)</h3></a>
<p>Listing 4-9의 코드를 살짝만 바꾸면 오류를 고칠 수 있습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<p>먼저 <code>s</code>를 <code>mut</code>로 바꿔야 합니다. 그리고 <code>&amp;mut s</code>로 가변 참조자를 생성하고
<code>some_string: &amp;mut String</code>으로 이 가변 참조자를 받아야 합니다.</p>
<p>하지만 가변 참조자는 딱 한가지 큰 제한이 있습니다: 특정한 스코프 내에 특정한 데이터
조각에 대한 가변 참조자를 딱 하나만 만들 수 있다는 겁니다. 아래 코드는 실패할 겁니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;
</code></pre>
<p>Here’s the error:</p>
<pre><code class="language-text">error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; borrow_twice.rs:5:19
  |
4 |     let r1 = &amp;mut s;
  |                   - first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |                   ^ second mutable borrow occurs here
6 | }
  | - first borrow ends here
</code></pre>
<p>이 제한 사항은 가변을 허용하긴 하지만 매우 통제된 형식으로 허용합니다. 이것이 새로운
러스트인들이 힘들어하는 부분인데, 대부분의 언어들은 여러분이 원하는대로 값을 변형하도록
해주기 때문입니다. 하지만 이러한 제한이 가지는 이점은 바로 러스트가 컴파일 타임에
데이터 레이스(data race)를 방지할 수 있도록 해준다는 것입니다.</p>
<p><em>데이터 레이스</em>는 아래에 정리된 세 가지 동작이 발생했을때 나타나는 특정한 레이스
조건입니다:</p>
<ol>
<li>두 개 이상의 포인터가 동시에 같은 데이터에 접근한다.</li>
<li>그 중 적어도 하나의 포인터가 데이터를 쓴다.</li>
<li>데이터에 접근하는데 동기화를 하는 어떠한 메커니즘도 없다.</li>
</ol>
<p>데이터 레이스는 정의되지 않은 동작을 일으키고 런타임에 이를 추적하고자 할 때는
이를 진단하고 고치기 어려울 수 있습니다; 러스트는 데이터 레이스가 발생할 수 있는
코드가 컴파일 조차 안되기 때문에 이 문제의 발생을 막아버립니다!</p>
<p>항상 우리는 새로운 스코프를 만들기 위해 중괄호를 사용하는데, 이는 그저 <em>동시</em>에
만드는 것이 아니게 해줌으로써, 여러 개의 가변 참조자를 만들 수 있도록 해줍니다.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;hello&quot;);

{
    let r1 = &amp;mut s;

} // 여기서 r1은 스코프 밖으로 벗어났으므로, 우리는 아무 문제 없이 새로운 참조자를 만들 수 있습니다.

let r2 = &amp;mut s;
#}</code></pre></pre>
<p>가변 참조자와 불변 참조자를 혼용할 경우에 대한 비슷한 규칙이 있습니다. 아래 코드는
컴파일 오류가 발생합니다:</p>
<pre><code class="language-rust ignore">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;s; // 문제 없음
let r2 = &amp;s; // 문제 없음
let r3 = &amp;mut s; // 큰 문제
</code></pre>
<p>여기 오류 메세지를 보시죠:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as
immutable
 --&gt; borrow_thrice.rs:6:19
  |
4 |     let r1 = &amp;s; // 문제 없음
  |               - immutable borrow occurs here
5 |     let r2 = &amp;s; // 문제 없음
6 |     let r3 = &amp;mut s; // 큰 문제
  |                   ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>어휴! 우리는 불변 참조자를 가지고 있을 동안에도 <em>역시</em> 가변 참조자를 만들 수 없습니다.
불변 참조자의 사용자는 사용중인 동안에 값이 값자기 바뀌리라 예상하지 않습니다! 하지만
여러 개의 불변 참조자는 만들 수 있는데, 데이터를 그냥 읽기만하는 것은 다른 것들이 그
데이터를 읽는데에 어떠한 영향도 주지 못하기 때문입니다.</p>
<p>때때로 이러한 오류들이 여러분을 좌절시킬지라도, 이것이 러스트 컴파일러가 (런타임이 아니라
컴파일 타임에) 일찌감치 잠재된 버그를 찾아내고, 왜 여러분의 데이터가 여러분 생각대로의
값을 갖고 있지 않은지 추적해 내려가는 대신 어느 지점이 문제인지를 정확히 보여주는
기능이란 점을 기억하세요.</p>
<a class="header" href="print.html#댕글링-참조자dangling-references" id="댕글링-참조자dangling-references"><h3>댕글링 참조자(Dangling References)</h3></a>
<p>포인터가 있는 언어에서는 자칫 잘못하면 <em>댕글링 포인터(dangling pointer)</em> 를 만들기 쉬운데, 댕글링
포인터란 어떤 메모리를 가리키는 포인터를 보존하는 동안, 그 메모리를 해제함으로써 다른 개체에게
사용하도록 줘버렸을 지도 모를 메모리를 참조하고 있는 포인터를 말합니다. 이와는 반대로, 러스트에서는
컴파일러가 모든 참조자들이 댕글링 참조자가 되지 않도록 보장해 줍니다: 만일 우리가 어떤 데이터의 참조자를
만들었다면, 컴파일러는 그 참조자가 스코프 밖으로 벗어나기 전에는 데이터가 스코프 밖으로 벗어나지 않을
것임을 확인해 줄 것입니다.</p>
<p>댕글링 참조자를 만드는 시도를 해봅시다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<p>위 코드의 오류 메세지입니다:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; dangle.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^^^^^^^
  |
  = help: this function's return type contains a borrowed value, but there is no
    value for it to be borrowed from
  = help: consider giving it a 'static lifetime

error: aborting due to previous error
</code></pre>
<p>이 오류 메세지는 우리가 아직 다루지 못한 특성을 인용하고 있습니다: 바로 <em>라이프타임(lifetime)</em>
입니다. 라이프타임에 대한 것은 10장에서 자세히 다룰 것입니다. 하지만 여러분이 라이프타임에 대한
부분을 무시한다면, 이 메세지는 이 코드가 왜 문제인지를 알려줄 열쇠를 쥐고 있습니다:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
(해석: 이 함수의 반환 타입은 빌린 값을 포함하고 있는데, 빌려온 실제 값은 없습니다.)
</code></pre>
<p><code>dangle</code> 코드 부분의 각 단계에서 어떤 일이 벌어지는지 더 면밀히 들여다봅시다:</p>
<pre><code class="language-rust ignore">fn dangle() -&gt; &amp;String { // dangle은 String의 참조자를 반환합니다

    let s = String::from(&quot;hello&quot;); // s는 새로운 String입니다

    &amp;s // 우리는 String s의 참조자를 반환합니다.
} // 여기서 s는 스코프를 벗어나고 버려집니다. 이것의 메모리는 사라집니다.
  // 위험하군요!
</code></pre>
<p><code>s</code>가 <code>dangle</code>안에서 만들어졌기 때문에, <code>dangle</code>의 코드가 끝이나면 <code>s</code>는 할당 해제됩니다.
하지만 우리는 이것의 참조자를 반환하려고 했습니다. 이는 곧 이 참조자가 어떤 무효화된 <code>String</code>을
가리키게 될 것이란 뜻이 아닙니까! 별로 안 좋죠. 러스트는 우리가 이런 짓을 못하게 합니다.</p>
<p>여기서의 해법은 <code>String</code>을 직접 반환하는 것입니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
#}</code></pre></pre>
<p>이 코드는 아무런 문제없이 동작합니다. 소유권이 밖으로 이동되었고, 아무것도 할당 해제되지 않습니다.</p>
<a class="header" href="print.html#참조자의-규칙" id="참조자의-규칙"><h3>참조자의 규칙</h3></a>
<p>우리가 참조자에 대해 논의한 것들을 정리해 봅시다:</p>
<ol>
<li>어떠한 경우이든 간에, 여러분은 아래 둘 다는 아니고 <em>둘 중 하나만</em> 가질 수 있습니다:</li>
</ol>
<ul>
<li>하나의 가변 참조자</li>
<li>임의 개수의 불변 참조자들</li>
</ul>
<ol start="2">
<li>참조자는 항상 유효하다.</li>
</ol>
<p>다음으로, 우리는 다른 종류의 참조자인 슬라이스(slice)를 볼 것입니다.</p>
<a class="header" href="print.html#슬라이스slices" id="슬라이스slices"><h2>슬라이스(Slices)</h2></a>
<p>소유권을 갖지 않는 또다른 데이터 타입은 <em>슬라이스</em>입니다. 슬라이스는 여러분이 컬렉션(collection)
전체가 아닌 컬렉션의 연속된 일련의 요소들을 참조할 수 있게 합니다.</p>
<p>여기 작은 프로그래밍 문제가 있습니다: 스트링을 입력 받아 그 스트링에서 찾은 첫번째 단어를 반환하는
함수를 작성하세요. 만일 함수가 공백문자를 찾지 못한다면, 이는 전체 스트링이 한 단어라는 의미이고,
이때는 전체 스트링이 반환되어야 합니다.</p>
<p>이 함수의 시그니처(signature)에 대해 생각해봅시다:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<p>이 함수 <code>first_word</code>는 <code>&amp;String</code>을 파라미터로 갖습니다. 우리는 소유권을 원하지 않으므로, 이렇게
해도 좋습니다. 하지만 뭘 반환해야할까요? 우리는 스트링의 <em>일부</em>에 대해 표현할 방법이 없습니다. 하지만
단어의 끝부분의 인덱스를 반환할 수는 있겠습니다. Listing 4-10의 코드처럼 시도해 봅시다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
#}</code></pre></pre>
<p><span class="caption">Listing 4-10: <code>String</code> 파라미터의 바이트 인덱스 값을 반환하는
<code>first_word</code> 함수</span></p>
<p>이 코드를 쪼개서 봅시다. 입력된 <code>String</code>를 요소 단위 보면서 그 값이 공백인지 확인할 필요가 있기
때문에, <code>String</code>은 <code>as_bytes</code> 메소드를 이용하여 바이트 배열로 변환됩니다:</p>
<pre><code class="language-rust ignore">let bytes = s.as_bytes();
</code></pre>
<p>다음으로, <code>iter</code> 메소드를 이용하여 바이트 배열의 반복자(iterator)를 생성합니다:</p>
<pre><code class="language-rust ignore">for (i, &amp;item) in bytes.iter().enumerate() {
</code></pre>
<p>반복자에 대한 것은 13장에서 더 자세히 다루겠습니다. 지금은 <code>iter</code>가 컬렉션의 각 요소를 반환하는 함수이며,
<code>enumerate</code>은 <code>iter</code>의 결과값을 직접 반환하는 대신 이를 감싸서 튜플의 일부로 만들어 반환한다는 정도만
알아두세요. 반환된 튜플의 첫번째 요소는 인덱스이며, 두번째 요소는 요소에 대한 참조값입니다. 이는 우리 스스로
인덱스를 계산하는 것보다 조금 더 편리합니다.</p>
<p><code>enumerate</code> 메소드가 튜플을 반환하기 때문에, 우리는 러스트의 다른 모든 부분에서 그러하듯이 이 튜플을
해체하기 위해 패턴을 이용할 수 있습니다. 따라서 <code>for</code> 루프 내에서, <code>i</code>는 튜플 내의 인덱스에 대응하고
<code>&amp;item</code>은 튜플 내의 한 바이트에 대응하는 패턴을 기술한 것입니다. <code>.iter().enumerate()</code>의
요소에 대한 참조자를 갖는 것이므로, <code>&amp;</code>을 패턴 내에 사용했습니다.</p>
<p>우리는 바이트 리터럴 문법을 이용하여 공백 문자를 나타내는 바이트를 찾습니다. 공백 문자를 찾았다면,
이 위치를 반환합니다. 그렇지 않으면 <code>s.len()</code>을 통해 스트링의 길이값을 반환합니다:</p>
<pre><code class="language-rust ignore">    if item == b' ' {
        return i;
    }
}
s.len()
</code></pre>
<p>이제 우리에게 스트링의 첫번째 단어의 끝부분의 인덱스를 찾아낼 방법이 생겼습니다. <code>usize</code>를
그대로 반환하고 있지만, 이는 <code>&amp;string</code>의 내용물 내에서만 의미가 있습니다. 바꿔 말하면,
이것이 <code>String</code>로부터 분리되어 있는 숫자이기 때문에, 이것이 나중에도 여전히 유효한지를 보장할
길이 없습니다. Listing 4-10의 <code>first_word</code> 함수를 사용하는 Listing 4-11의 프로그램을
보시죠:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn first_word(s: &amp;String) -&gt; usize {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
#
#     s.len()
# }
#
fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s); // word는 5를 갖게 될 것입니다.

    s.clear(); // 이 코드는 String을 비워서 &quot;&quot;로 만들게 됩니다.

    // word는 여기서 여전히 5를 갖고 있지만, 5라는 값을 의미있게 쓸 수 있는 스트링은 이제 없습니다.
    // word는 이제 완전 유효하지 않습니다!
}
</code></pre></pre>
<p><span class="caption">Listing 4-11: <code>first_word</code> 함수를 호출하여 결과를 저장한 뒤
<code>String</code>의 내용물을 바꾸기</span></p>
<p>이 프로그램은 아무런 오류 없이 컴파일되고, <code>s.clear()</code>을 호출한 뒤 <code>word</code>를 사용한다 해도
역시 컴파일될 것입니다. <code>word</code>는 <code>s</code>의 상태와 전혀 연결되어 있지 않으므로, <code>word</code>는 여전히 값
<code>5</code>를 담고 있습니다. 우리는 첫번째 단어를 추출하고자 하기 위해 <code>s</code>와 값 <code>5</code>를 사용할 수 있지만,
<code>word에</code>5<code>를 저장한 뒤</code>s`의 내용물이 변경되었기 때문에 이러한 사용은 버그가 될 것입니다.</p>
<p><code>word</code>의 인덱스가 <code>s</code>의 데이터와 싱크가 안맞을 것을 걱정하는 건 지겹고 쉽게 발생할 수 있는 오류입니다!
이러한 인덱스들을 관리하는 것은 우리가 <code>second_word</code> 함수를 작성했을 때 더더욱 다루기 어려워집니다.
이 함수의 시그니처는 아래와 같은 모양이 되어야 할 것입니다:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>이제 우리는 시작, <em>그리고</em> 끝 인덱스를 추적하고 있고, 특정 상태에 있는 데이터로부터 계산되었지만
그 상태와 전혀 묶여있지 않은 더 많은 값들을 갖게 됩니다. 이제 우리는 동기화를 유지할 필요가 있는
주위를 떠다니는 세 개의 관련없는 변수들을 갖게 되었습니다.</p>
<p>운좋게도, 러스트는 이러한 문제에 대한 해결책을 갖고 있습니다: 바로 스트링 슬라이스(string slice)
입니다.</p>
<a class="header" href="print.html#스트링-슬라이스" id="스트링-슬라이스"><h3>스트링 슬라이스</h3></a>
<p><em>스트링 슬라이스</em>는 <code>String</code>의 일부분에 대한 참조자고, 아래와 같이 생겼습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello world&quot;);

let hello = &amp;s[0..5];
let world = &amp;s[6..11];
#}</code></pre></pre>
<p>이는 전체 <code>String</code>의 참조자를 갖는 것과 비슷하지만, 추가적으로 <code>[0..5]</code>라는 코드가 붙어 있습니다.
전체 <code>String</code>에 대한 참조자 보다는, <code>String</code>의 일부분에 대한 참조자입니다. <code>start..end</code> 문법은
<code>start</code>부터 시작하여 <code>end</code>를 포함하지 않는 연속된 범위를 기술합니다.</p>
<p>우리는 대괄호 내에 <code>[starting_index..ending_index]</code>를 특정한 범위를 이용하여 슬라이스를 만들
수 있는데, 여기서 <code>starting_index</code>는 슬라이스에 포함되는 첫번째 위치이고 <code>ending_index</code>는
슬라이스에 포함될 마지막 위치보다 1을 더한 값입니다. 내부적으로 슬라이스 데이터 구조는 시작 위치와
슬라이스의 길이를 저장하는데, 이 길이 갚은 <code>ending_index</code>에서 <code>starting_index</code>를 뺸 값입니다.
따라서 <code>let world = &amp;[6..11];</code>의 경우, <code>world</code>는 <code>s</code>의 6번째 바이트를 가리키고 있는 포인터와
길이값 5를 갖고 있는 슬라이스가 될 것입니다.</p>
<p>Figure 4-12는 이를 다이어그램으로 보여줍니다.</p>
<p><img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 4-12: <code>String</code>의 일부를 참조하는 스트링 슬라이스</span></p>
<p>러스트의 <code>..</code> 범위 문법을 사용하여, 여러분이 만일 첫번째 인덱스(즉 0)에서부터 시작하길 원한다면,
두 개의 마침표 전의 값은 생략할 수 있습니다. 다시 말하면, 아래의 두 줄은 동일한 표현입니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
#}</code></pre></pre>
<p>비슷한 이치로, 만일 여러분의 슬라이스가 <code>String</code>의 마지막 바이트까지 포함한다면, 여러분은 끝의
숫자를 생략할 수 있습니다. 이는 아래 두 줄의 표현이 동일하다는 의미입니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
#}</code></pre></pre>
<p>여러분은 또한 전체 스트링의 슬라이스를 만들기 위해 양쪽 값을 모두 생략할 수 있습니다. 따라서 아래
두 줄의 표현은 동일합니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
#}</code></pre></pre>
<p>이 모든 정보를 잘 기억하시고, <code>first_word</code>가 슬라이스를 반환하도록 다시 작성해봅시다.
“스트링 슬라이스”를  나타내는 타입은 <code>&amp;str</code>로 씁니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<p>우리는 Listing 4-10에서 작성한 것과 같은 방법으로 공백 문자가 첫번째로 나타난 지점을 찾아서 단어의
끝 인덱스를 얻어냅니다. 공백 문자를 찾으면, 스트링의 시작과 공백 문자의 인덱스를 각각 시작과 끝 인덱스로
사용하여 스트링 슬라이스를 반환합니다.</p>
<p>이제 <code>first_word</code>가 호출되면, 해당 데이터와 묶여있는 하나의 값을 반환받게 되었습니다. 이 값은
슬라이스의 시작 위치에 대한 참조자와 슬라이스의 요소 개수로 이루어져 있습니다.</p>
<p><code>second_word</code> 함수에 대해서도 마찬가지로 슬라이스를 반환하는 형식이 잘 동작할 것입니다:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>우리는 이제 엉망이 되기 훨씬 힘든 직관적인 API를 갖게 되었는데, 이는 컴파일러가 <code>String</code>에 대한
참조자들이 유효한 상태로 남아있게끔 보장할 것이기 때문입니다. 첫번째 단어의 끝 인덱스를 찾았지만,
그 후 스트링을 비워버려서 인덱스가 유효하지 않게되는 Listing 4-11의 프로그램 내의 버그를 기억하시나요?
그런 코드는 논리적으로 맞지 않지만 어떠한 즉각적인 오류도 보여주지 못합니다. 그런 문제는 우리가
비어 있는 스트링에 대해 첫번째 단어의 인덱스를 사용하고자 시도할 경우에나 나타나게 될 것입니다.
슬라이스는 이러한 버그를 불가능하게 만들고 우리가 코드 내에서 발생할 수 있는 문제를 훨씬 일찍 알게
해줍니다. <code>first_word</code>의 슬라이스 버젼을 이용하는 것은 컴파일 타임 오류를 발생시킬 것입니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // Error!
}
</code></pre>
<p>여기 컴파일 오류 메세지를 보시죠:</p>
<pre><code class="language-text">17:6 error: cannot borrow `s` as mutable because it is also borrowed as
            immutable [E0502]
    s.clear(); // Error!
    ^
15:29 note: previous borrow of `s` occurs here; the immutable borrow prevents
            subsequent moves or mutable borrows of `s` until the borrow ends
    let word = first_word(&amp;s);
                           ^
18:2 note: previous borrow ends here
fn main() {

}
^
</code></pre>
<p>빌림 규칙에서 우리가 만일 무언가에 대한 불변 참조자를 만들었을 경우, 가변 참조자를 만들 수 없다는
점을 상기해보세요. <code>clear</code> 함수가 <code>String</code>을 잘라낼 필요가 있기 때문에, 이 함수는 가변 참조자를
갖기 위한 시도를 할 것이고, 이는 실패하게 됩니다. 러스트는 우리의 API를 사용하기 쉽게 해줄 뿐만 아니라
이러한 종류의 오류 전체를 컴파일 타임에 제거해 줍니다!</p>
<a class="header" href="print.html#스트링-리터럴은-슽라이스입니다" id="스트링-리터럴은-슽라이스입니다"><h4>스트링 리터럴은 슽라이스입니다</h4></a>
<p>스트링 리터럴이 바이너리 안에 저장된다고 하는 얘기를 상기해봅시다. 이제 슬라이스에 대해 알았으니,
우리는 스트링 리터럴을 적합하게 이해할 수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;Hello, world!&quot;;
#}</code></pre></pre>
<p>여기서 <code>s</code>의 타입은 <code>&amp;str</code>입니다: 이것은 바이너리의 특정 지점을 가리키고 있는 슬라이스입니다.
이는 왜 스트링 리터럴이 불변인가도 설명해줍니다; <code>&amp;str</code>은 불번 참조자이기 때문입니다.</p>
<a class="header" href="print.html#파라미터로서의-스트링-슬라이스" id="파라미터로서의-스트링-슬라이스"><h4>파라미터로서의 스트링 슬라이스</h4></a>
<p>여러분이 리터럴과 <code>String</code>의 슬라이스를 얻을 수 있다는 것을 알게 되었다면 <code>first_word</code> 함수를
한번 더 개선시킬 수 있는데, 바로 이 함수의 시그니처입니다:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>더 경험이 많은 러스트인이라면 대신 아래와 같이 작성하는데, 그 이유는 <code>String</code>과 <code>&amp;str</code> 둘 모두에
대한 같은 함수를 사용할 수 있도록 해주기 때문입니다.</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>만일 우리가 스트링 슬라이스를 갖고 있다면, 이를 바로 넘길 수 있습니다. <code>String</code>을 갖고 있다면,
이 <code>String</code>의 전체 슬라이스를 넘길 수 있습니다. 함수가 <code>String</code>의 참조자 대신 스트링 슬라이스를
갖도록 정의하는 것은 우리의 API를 어떠한 기능적인 손실 없이도 더 일반적이고 유용하게 해줍니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn first_word(s: &amp;str) -&gt; &amp;str {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &amp;s[0..i];
#         }
#     }
#
#     &amp;s[..]
# }
fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // first_word가 `String`의 슬라이스로 동작합니다.
    let word = first_word(&amp;my_string[..]);

    let my_string_literal = &quot;hello world&quot;;

    // first_word가 스트링 리터럴의 슬라이스로 동작합니다.
    let word = first_word(&amp;my_string_literal[..]);

    // 스트링 리터럴은 *또한* 스트링 슬라이스이기 때문에,
    // 아래 코드도 슬라이스 문법 없이 동작합니다!
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<a class="header" href="print.html#그-밖의-슬라이스들" id="그-밖의-슬라이스들"><h3>그 밖의 슬라이스들</h3></a>
<p>스트링 슬라이스는 여러분이 상상하는 바와 같이, 스트링에 특정되어 있습니다. 하지만 더 일반적인
슬라이스 타입도 역시 있습니다. 아래 배열을 보시죠:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];
#}</code></pre></pre>
<p>우리가 스트링의 일부를 참조하고 싶어할 수 있는 것처럼, 배열의 일부를 참조하고 싶을 수 있고, 그러면
아래와 같이 쓸 수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
#}</code></pre></pre>
<p>이 슬라이스는 <code>&amp;[i32]</code> 타입을 갖습니다. 이는 스트링 슬라이스가 동작하는 방법과 똑같이, 슬라이스의
첫번째 요소에 대한 참조자와 슬라이스의 길이를 저장하는 방식으로 동작합니다. 여러분은 다른 모든 종류의
컬렉션들에 대하여 이런 종류의 슬라이스를 이용할 수 있습니다. 벡터에 대해서 8장에서 이야기할 때 이러한
컬렉션에 대해 더 자세히 다루겠습니다.</p>
<a class="header" href="print.html#정리" id="정리"><h2>정리</h2></a>
<p>소유권, 빌림, 그리고 슬라이스의 개념은 러스트 프로그램의 메모리 안정성을 컴파일 타임에 보장하는 것입니다.
러스트 언어는 다른 시스템 프로그래밍 언어와 같이 여러분의 메모리 사용에 대한 제어권을 주지만, 데이터의
소유자가 스코프 밖으로 벗어났을 때 소유자가 자동적으로 데이터를 버리도록 하는 것은 곧 여러분이 이러한
제어를 위해 추가적인 코드 작성이나 디버깅을 하지 않아도 된다는 뜻입니다.</p>
<p>소유권은 러스트의 다른 수많은 부분이 어떻게 동작하는지에 영향을 주므로, 이 책의 남은 부분 전체에 걸쳐
이 개념들에 대해 더 이야기할 것입니다. 다음 장으로 넘어가서 데이터들을 함께 그룹짓는 <code>struct</code>를
보겠습니다.</p>
<a class="header" href="print.html#연관된-데이터들을-구조체로-다루기" id="연관된-데이터들을-구조체로-다루기"><h1>연관된 데이터들을 구조체로 다루기</h1></a>
<p>구조체(<em>struct</em>)는 사용자들이 연관된 여러 값들을 묶어서 의미있는 데이터 단위를 정의할 수 있게 합니다.
객체지향 언어를 사용해 본 경험이 있으시다면, 구조체(<em>struct</em>)는 객체의 데이터 속성 같은 것으로 보시면
됩니다. 이번 장에서는 튜플과 구조체를 비교해 보고, 구조체를 어떻게 사용하는지 알아보며, 메소드와
구조체 데이터의 동작과 관련된 연관함수(associated functions)의 정의 방법에 대해 알아보도록
하겠습니다. 구조체와 열거형(6장에서 살펴볼 것입니다)에 대한 개념은 여러분의 프로그램 도메인 상에서
새로운 타입을 만들기 위한 기초 재료로서, 러스트의 컴파일 시점 타입 검사 기능을 최대한 활용합니다.</p>
<a class="header" href="print.html#구조체를-정의하고-초기화하기" id="구조체를-정의하고-초기화하기"><h2>구조체를 정의하고 초기화하기</h2></a>
<p>구조체는 3장에서 학습한 튜플과 비슷합니다. 튜플과 유사하게, 구조체의 구성요소들은 각자 다른 타입을
지닐 수 있습니다. 그러나 튜플과는 다르게 각 구성요소들은 명명할 수 있어 값이 의미하는 바를 명확하게
인지할 수 있습니다. 구조체는 각 구성요소들에 명명을 할 수 있다는 점 덕분에 튜플보다 유연하게 다룰 수
있습니다. 구조체 내의 특정 요소 데이터 명세를 기술하거나, 접근할 때 순서에 의존할 필요가 없기 때문입니다.</p>
<p>구조체를 정의할 때는 <code>struct</code> 키워드를 먼저 입력하고 명명할 구조체명을 입력하면 됩니다. 구조체의 이름은
함께 묶이게 되는 구성요소들의 의미를 내포할 수 있도록 짓는 것이 좋습니다.
이후 중괄호 안에서는, 필드(<em>field</em>)라 불리는 각 구성요소들의 타입과 접근할 수 있는 이름을 정의합니다.</p>
<p>아래 예제 5-1에서는 사용자 계정에 대한 정보를 저장하는 구조체를 정의합니다.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
#}</code></pre></pre>
<p><span class="caption">Listing 5-1: 사용자 계정정보를 저장하는 <code>User</code> 구조체 정의</span></p>
<p>정의한 구조체를 사용하려면, 각 필드의 값을 명세한 인스턴스(<em>instance</em>)를 생성해야 합니다.
인스턴스는 구조체의 이름을 명시함으로써 사용할 수 있고, 필드를 식별할 수 있는 이름인 키와
그 키에 저장하고자 하는 값의 쌍(<code>key:value</code>)을 이어지는 중괄호 안에 추가하여 생성할 수 있습니다.</p>
<p>구조체를 정의할때 필드들의 순서가 정의한 필드의 순서와 같을 필요는 없습니다. 달리 서술하자면, 구조체
정의는 무엇이 들어가야 하는 지 대략적으로 정의된 양식 정도라고 생각하시면 되고, 인스턴스는 그것에
특정한 값을 넣어 실체화한 것이라 생각하시면 됩니다. 아래 예제 5-2에서는 특정 사용자를 선언하는
과정을 보여줍니다.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
let user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};
#}</code></pre></pre>
<p><span class="caption">Listing 5-2: 구조체 <code>User</code>의 인스턴스 생성하기</span></p>
<p>구조체에서 특정한 값을 읽어오려면, 점(.) 표기법을 사용하시면 됩니다. 사용자의 이메일 값을 얻고자 하면,
<code>user1.email</code> 과 같은 방식으로 접근하실 수 있습니다. 변경이 가능한 구조체에 들어있는 값을 바꾸고자
할 때는, 아래와 같이 점(.) 표기법을 사용하여 새 값을 할당할 수 있습니다.
<code>user1.email = String::from(&quot;someone-else@example.com&quot;);</code></p>
<a class="header" href="print.html#변수명이-필드명과-같을-때-간단하게-필드-초기화하기" id="변수명이-필드명과-같을-때-간단하게-필드-초기화하기"><h3>변수명이 필드명과 같을 때 간단하게 필드 초기화하기</h3></a>
<p>변수명과 구조체의 필드명이 같다면, 필드 초기화 축약법(<em>field init shorthand</em>) 을 이용할 수 있습니다.
이를 활용하면 구조체를 생성하는 함수를 더 간단히 작성할 수 있게 됩니다.
아래 예제 5-3의 <code>build_user</code> 함수에는 <code>email</code>과 <code>username</code> 라는 매개변수가
있습니다. 함수는 <code>User</code>구조체가 구현된 인스턴스를 반환합니다.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
#}</code></pre></pre>
<p><span class="caption">예제 5-3: 사용자의 이메일과 이름을 받아 <code>User</code>구조체의 인스턴스를
반환하는 <code>build_user</code> 함수</span></p>
<p>매개변수인 <code>email</code>과 <code>username</code>이 <code>User</code>구조체의 필드명과 같기 떄문에, 함수 <code>build_user</code>
에서 <code>email</code>과 <code>username</code>를 명시하는 부분을 예제 5-4와 같이 다시 작성할 필요가 없습니다.</p>
<p>예제 5-4의 <code>build_user</code> 함수는 예제 5-3과 같은 방식으로 동작합니다. 필드 초기화를 이러한 방식으로
수행하는 문법은 간결한 코드를 작성하는데 도움이 되고, 많은 필드의 값이 정의되어야할 때 특히 유용합니다.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
#}</code></pre></pre>
<p><span class="caption">예제 5-4: 매개변수 <code>email</code>과 <code>username</code>가 구조체의 필드와 이름이
같아, 함수 내에서 특별히 명시하지 않고 초기화한 예인 <code>build_user</code> 함수</span></p>
<a class="header" href="print.html#구조체-갱신법을-이용하여-기존-구조체-인스턴스로-새-구조체-인스턴스-생성하기" id="구조체-갱신법을-이용하여-기존-구조체-인스턴스로-새-구조체-인스턴스-생성하기"><h3>구조체 갱신법을 이용하여 기존 구조체 인스턴스로 새 구조체 인스턴스 생성하기</h3></a>
<p>존재하는 인스턴스에서 기존 값의 대부분은 재사용하고, 몇몇 값만 바꿔 새로운 인스턴스를 정의하는 방법은
유용합니다. 예제 5-5는 변수 <code>user2</code>에 <code>email</code>과 <code>username</code>은 새로 할당하고, 나머지
필드들은 예제 5-2에서 정의한 <code>user1</code>의 값들을 그대로 사용하는 방식으로 <code>User</code> 인스턴스를
생성하는 것을 보여줍니다.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
# let user1 = User {
#     email: String::from(&quot;someone@example.com&quot;),
#     username: String::from(&quot;someusername123&quot;),
#     active: true,
#     sign_in_count: 1,
# };
#
let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    active: user1.active,
    sign_in_count: user1.sign_in_count,
};
#}</code></pre></pre>
<p><span class="caption">예제 5-5: <code>user1</code>을 일부 값들을 재사용하여, 구조체 <code>User</code>의 인스턴스
<code>user2</code>를 새로 생성</span></p>
<p>구조체 갱신법(<em>struct update syntax</em>)은 예제 5-5에서 작성한 짧은 코드와 같은 효과를 낼 수
있습니다. 구조체 갱신법은, 입력으로 주어진 인스턴스와 변화하지 않는 필드들을 명시적으로 할당하지
않기 위해 <code>..</code> 구문을 사용합니다. 예제 5-6의 코드는 <code>user1</code> 인스턴스와 <code>active</code>,
<code>sign_in_count</code> 필드의 값은 같고, <code>email</code>과 <code>username</code> 필드들은 값은 다른 <code>user2</code>
인스턴스를 생성할 때 구조체 갱신법을 사용하는 것을 보여줍니다.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
# let user1 = User {
#     email: String::from(&quot;someone@example.com&quot;),
#     username: String::from(&quot;someusername123&quot;),
#     active: true,
#     sign_in_count: 1,
# };
#
let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    ..user1
};
#}</code></pre></pre>
<p><span class="caption">예제 5-6: 인스턴스 갱신 문법의 사용 예시 - 새 <code>User</code> 구조체 생성 시
<code>email</code>과 <code>username</code> 필드에는 새 값을 할당하고, 나머지 필드는 <code>user1</code>에서 재사용</span></p>
<a class="header" href="print.html#이름이-없고-필드마다-타입은-다르게-정의-가능한-튜플-구조체" id="이름이-없고-필드마다-타입은-다르게-정의-가능한-튜플-구조체"><h3>이름이 없고 필드마다 타입은 다르게 정의 가능한 튜플 구조체</h3></a>
<p>구조체명을 통해 의미를 부여할 수 있으나 필드의 타입만 정의할 수 있고 명명은 할 수 없는,
튜플 구조체(<em>tuple structs</em>)라 불리는 튜플과 유사한 형태의 구조체도 정의할 수 있습니다.</p>
<p>튜플 구조체는 일반적인 구조체 정의방법과 똑같이 <code>struct</code> 키워드를 통해 정의할 수 있고, 튜플의
타입 정의가 키워드 뒤에서 이루어지면 됩니다. 아래는 튜플 구조체인 <code>Color</code>, <code>Point</code>의 정의와
사용 예시 입니다.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
#}</code></pre></pre>
<p>다른 튜플 구조체이기 때문에, <code>black</code>과 <code>origin</code>이 다른 타입이란 것을 유념해 두셔야 합니다.
구조체 내의 타입이 모두 동일하더라도 각각의 구조체는 고유의 타입이기 때문입니다. 한편 튜플 구조체
인스턴스는, 3장에서 살펴 본 튜플과 비슷하게 동작합니다.</p>
<a class="header" href="print.html#필드가-없는-유사-유닛-구조체" id="필드가-없는-유사-유닛-구조체"><h3>필드가 없는 유사 유닛 구조체</h3></a>
<p>또한 어떤 필드도 없는 구조체 역시 정의할 수 있습니다! 이는 유닛 타입인 <code>()</code>와 비슷하게 동작하고,
그 때문에 유사 유닛 구조체(<em>unit-like structs</em>)라 불립니다.
유사 유닛 구조체는 특정한 타입의 트레잇(trait)을 구현해야하지만 타입 자체에 데이터를 저장하지 않는
경우에 유용합니다. 트레잇(trait)에 대해서는 10장에서 더 살펴보도록 하겠습니다.</p>
<blockquote>
<a class="header" href="print.html#구조체-데이터의-소유권ownership" id="구조체-데이터의-소유권ownership"><h3>구조체 데이터의 소유권(Ownership)</h3></a>
<p>예제 5-1에서의 <code>User</code> 구조체 정의에서는, <code>&amp;str</code> 문자 슬라이스 타입 대신 <code>String</code>타입을
사용했습니다. 이는 의도적인 선택으로, 구조체 전체가 유효한 동안 구조체가 그 데이터를 소유하게 하고자
함입니다.</p>
<p>구조체가 소유권이 없는 데이터의 참조를 저장할수는 있지만, 10장에서 언급 될 라이프타임(<em>lifetimes</em>)
의 사용을 전제로 합니다.
라이프타임은 구조체가 존재하는동안 참조하는 데이터를 계속 존재할 수 있도록 합니다. 라이프타임을
사용하지 않고 참조를 저장하고자 하면 아래와 같은 일이 발생합니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct User {
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre>
<p>컴파일러는 라이프타임이 명시되어야 한다고 에러를 발생시킵니다.</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt;
  |
2 |     username: &amp;str,
  |               ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
 --&gt;
  |
3 |     email: &amp;str,
  |            ^ expected lifetime parameter
</code></pre>
<p>참조가 저장이 불가능한 위 에러 개선에 대해서는 10장에서 살펴보도록 하겠습니다. 지금은 <code>&amp;str</code> 대신
<code>String</code> 을 사용하는 방식으로 에러를 고치도록 하겠습니다.</p>
</blockquote>
<a class="header" href="print.html#an-example-program-using-structs" id="an-example-program-using-structs"><h2>An Example Program Using Structs</h2></a>
<p>To understand when we might want to use structs, let’s write a program that
calculates the area of a rectangle. We’ll start with single variables, and then
refactor the program until we’re using structs instead.</p>
<p>Let’s make a new binary project with Cargo called <em>rectangles</em> that will take
the length and width of a rectangle specified in pixels and will calculate the
area of the rectangle. Listing 5-7 shows a short program with one way of doing
just that in our project’s <em>src/main.rs</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let length1 = 50;
    let width1 = 30;

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(length1, width1)
    );
}

fn area(length: u32, width: u32) -&gt; u32 {
    length * width
}
</code></pre></pre>
<p><span class="caption">Listing 5-7: Calculating the area of a rectangle
specified by its length and width in separate variables</span></p>
<p>Now, run this program using <code>cargo run</code>:</p>
<pre><code class="language-text">The area of the rectangle is 1500 square pixels.
</code></pre>
<a class="header" href="print.html#refactoring-with-tuples" id="refactoring-with-tuples"><h3>Refactoring with Tuples</h3></a>
<p>Even though Listing 5-7 works and figures out the area of the rectangle by
calling the <code>area</code> function with each dimension, we can do better. The length
and the width are related to each other because together they describe one
rectangle.</p>
<p>The issue with this method is evident in the signature of <code>area</code>:</p>
<pre><code class="language-rust ignore">fn area(length: u32, width: u32) -&gt; u32 {
</code></pre>
<p>The <code>area</code> function is supposed to calculate the area of one rectangle, but the
function we wrote has two parameters. The parameters are related, but that’s
not expressed anywhere in our program. It would be more readable and more
manageable to group length and width together. We’ve already discussed one way
we might do that in the Grouping Values into Tuples section of Chapter 3 on
page XX: by using tuples. Listing 5-8 shows another version of our program that
uses tuples:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let rect1 = (50, 30);

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<p><span class="caption">Listing 5-8: Specifying the length and width of the
rectangle with a tuple</span></p>
<p>In one way, this program is better. Tuples let us add a bit of structure, and
we’re now passing just one argument. But in another way this version is less
clear: tuples don’t name their elements, so our calculation has become more
confusing because we have to index into the parts of the tuple.</p>
<p>It doesn’t matter if we mix up length and width for the area calculation, but
if we want to draw the rectangle on the screen, it would matter! We would have
to keep in mind that <code>length</code> is the tuple index <code>0</code> and <code>width</code> is the tuple
index <code>1</code>. If someone else worked on this code, they would have to figure this
out and keep it in mind as well. It would be easy to forget or mix up these
values and cause errors, because we haven’t conveyed the meaning of our data in
our code.</p>
<a class="header" href="print.html#refactoring-with-structs-adding-more-meaning" id="refactoring-with-structs-adding-more-meaning"><h3>Refactoring with Structs: Adding More Meaning</h3></a>
<p>We use structs to add meaning by labeling the data. We can transform the tuple
we’re using into a data type with a name for the whole as well as names for the
parts, as shown in Listing 5-9:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Rectangle {
    length: u32,
    width: u32,
}

fn main() {
    let rect1 = Rectangle { length: 50, width: 30 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.length * rectangle.width
}
</code></pre></pre>
<p><span class="caption">Listing 5-9: Defining a <code>Rectangle</code> struct</span></p>
<p>Here we’ve defined a struct and named it <code>Rectangle</code>. Inside the <code>{}</code> we
defined the fields as <code>length</code> and <code>width</code>, both of which have type <code>u32</code>. Then
in <code>main</code> we create a particular instance of a <code>Rectangle</code> that has a length of
50 and a width of 30.</p>
<p>Our <code>area</code> function is now defined with one parameter, which we’ve named
<code>rectangle</code>, whose type is an immutable borrow of a struct <code>Rectangle</code>
instance. As mentioned in Chapter 4, we want to borrow the struct rather than
take ownership of it. This way, <code>main</code> retains its ownership and can continue
using <code>rect1</code>, which is the reason we use the <code>&amp;</code> in the function signature and
where we call the function.</p>
<p>The <code>area</code> function accesses the <code>length</code> and <code>width</code> fields of the <code>Rectangle</code>
instance. Our function signature for <code>area</code> now indicates exactly what we mean:
calculate the area of a <code>Rectangle</code> using its <code>length</code> and <code>width</code> fields. This
conveys that the length and width are related to each other, and gives
descriptive names to the values rather than using the tuple index values of <code>0</code>
and <code>1</code>—a win for clarity.</p>
<a class="header" href="print.html#adding-useful-functionality-with-derived-traits" id="adding-useful-functionality-with-derived-traits"><h3>Adding Useful Functionality with Derived Traits</h3></a>
<p>It would be helpful to be able to print out an instance of the <code>Rectangle</code>
while we’re debugging our program in order to see the values for all its
fields. Listing 5-10 uses the <code>println!</code> macro as we have been in earlier
chapters:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct Rectangle {
    length: u32,
    width: u32,
}

fn main() {
    let rect1 = Rectangle { length: 50, width: 30 };

    println!(&quot;rect1 is {}&quot;, rect1);
}
</code></pre>
<p><span class="caption">Listing 5-10: Attempting to print a <code>Rectangle</code>
instance</span></p>
<p>When we run this code, we get an error with this core message:</p>
<pre><code class="language-text">error[E0277]: the trait bound `Rectangle: std::fmt::Display` is not satisfied
</code></pre>
<p>The <code>println!</code> macro can do many kinds of formatting, and by default, <code>{}</code>
tells <code>println!</code> to use formatting known as <code>Display</code>: output intended for
direct end user consumption. The primitive types we’ve seen so far implement
<code>Display</code> by default, because there’s only one way you’d want to show a <code>1</code> or
any other primitive type to a user. But with structs, the way <code>println!</code> should
format the output is less clear because there are more display possibilities:
do you want commas or not? Do you want to print the curly braces? Should all
the fields be shown? Due to this ambiguity, Rust doesn’t try to guess what we
want and structs don’t have a provided implementation of <code>Display</code>.</p>
<p>If we continue reading the errors, we’ll find this helpful note:</p>
<pre><code class="language-text">note: `Rectangle` cannot be formatted with the default formatter; try using
`:?` instead if you are using a format string
</code></pre>
<p>Let’s try it! The <code>println!</code> macro call will now look like <code>println!(&quot;rect1 is {:?}&quot;, rect1);</code>. Putting the specifier <code>:?</code> inside the <code>{}</code> tells <code>println!</code> we
want to use an output format called <code>Debug</code>. <code>Debug</code> is a trait that enables us
to print out our struct in a way that is useful for developers so we can see
its value while we’re debugging our code.</p>
<p>Run the code with this change. Drat! We still get an error:</p>
<pre><code class="language-text">error: the trait bound `Rectangle: std::fmt::Debug` is not satisfied
</code></pre>
<p>But again, the compiler gives us a helpful note:</p>
<pre><code class="language-text">note: `Rectangle` cannot be formatted using `:?`; if it is defined in your
crate, add `#[derive(Debug)]` or manually implement it
</code></pre>
<p>Rust <em>does</em> include functionality to print out debugging information, but we
have to explicitly opt-in to make that functionality available for our struct.
To do that, we add the annotation <code>#[derive(Debug)]</code> just before the struct
definition, as shown in Listing 5-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    length: u32,
    width: u32,
}

fn main() {
    let rect1 = Rectangle { length: 50, width: 30 };

    println!(&quot;rect1 is {:?}&quot;, rect1);
}
</code></pre></pre>
<p><span class="caption">Listing5-11: Adding the annotation to derive the <code>Debug</code>
trait and printing the <code>Rectangle</code> instance using debug formatting</span></p>
<p>Now when we run the program, we won’t get any errors and we’ll see the
following output:</p>
<pre><code class="language-text">rect1 is Rectangle { length: 50, width: 30 }
</code></pre>
<p>Nice! It’s not the prettiest output, but it shows the values of all the fields
for this instance, which would definitely help during debugging. When we have
larger structs, it’s useful to have output that’s a bit easier to read; in
those cases, we can use <code>{:#?}</code> instead of <code>{:?}</code> in the <code>println!</code> string.
When we use the <code>{:#?}</code> style in the example, the output will look like this:</p>
<pre><code class="language-text">rect1 is Rectangle {
    length: 50,
    width: 30
}
</code></pre>
<p>Rust has provided a number of traits for us to use with the <code>derive</code> annotation
that can add useful behavior to our custom types. Those traits and their
behaviors are listed in Appendix C. We’ll cover how to implement these traits
with custom behavior as well as how to create your own traits in Chapter 10.</p>
<p>Our <code>area</code> function is very specific: it only computes the area of rectangles.
It would be helpful to tie this behavior more closely to our <code>Rectangle</code>
struct, because it won't work with any other type. Let’s look at how we can
continue to refactor this code by turning the <code>area</code> function into an <code>area</code>
<em>method</em> defined on our <code>Rectangle</code> type.</p>
<a class="header" href="print.html#method-syntax" id="method-syntax"><h2>Method Syntax</h2></a>
<p><em>Methods</em> are similar to functions: they’re declared with the <code>fn</code> keyword and
their name, they can have parameters and return values, and they contain some
code that is run when they’re called from somewhere else. However, methods are
different from functions in that they’re defined within the context of a struct
(or an enum or a trait object, which we cover in Chapters 6 and 17,
respectively), and their first parameter is always <code>self</code>, which represents the
instance of the struct the method is being called on.</p>
<a class="header" href="print.html#defining-methods" id="defining-methods"><h3>Defining Methods</h3></a>
<p>Let’s change the <code>area</code> function that has a <code>Rectangle</code> instance as a parameter
and instead make an <code>area</code> method defined on the <code>Rectangle</code> struct, as shown
in Listing 5-12:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.length * self.width
    }
}

fn main() {
    let rect1 = Rectangle { length: 50, width: 30 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<p><span class="caption">Listing 5-12: Defining an <code>area</code> method on the
<code>Rectangle</code> struct</span></p>
<p>To define the function within the context of <code>Rectangle</code>, we start an <code>impl</code>
(<em>implementation</em>) block. Then we move the <code>area</code> function within the <code>impl</code>
curly braces and change the first (and in this case, only) parameter to be
<code>self</code> in the signature and everywhere within the body. In <code>main</code> where we
called the <code>area</code> function and passed <code>rect1</code> as an argument, we can instead
use <em>method syntax</em> to call the <code>area</code> method on our <code>Rectangle</code> instance.
The method syntax goes after an instance: we add a dot followed by the method
name, parentheses, and any arguments.</p>
<p>In the signature for <code>area</code>, we use <code>&amp;self</code> instead of <code>rectangle: &amp;Rectangle</code>
because Rust knows the type of <code>self</code> is <code>Rectangle</code> due to this method being
inside the <code>impl Rectangle</code> context. Note that we still need to use the <code>&amp;</code>
before <code>self</code>, just like we did in <code>&amp;Rectangle</code>. Methods can take ownership of
<code>self</code>, borrow <code>self</code> immutably as we’ve done here, or borrow <code>self</code> mutably,
just like any other parameter.</p>
<p>We’ve chosen <code>&amp;self</code> here for the same reason we used <code>&amp;Rectangle</code> in the
function version: we don’t want to take ownership, and we just want to read the
data in the struct, not write to it. If we wanted to change the instance that
we’ve called the method on as part of what the method does, we’d use <code>&amp;mut self</code> as the first parameter. Having a method that takes ownership of the
instance by using just <code>self</code> as the first parameter is rare; this technique is
usually used when the method transforms <code>self</code> into something else and we want
to prevent the caller from using the original instance after the transformation.</p>
<p>The main benefit of using methods instead of functions, in addition to using
method syntax and not having to repeat the type of <code>self</code> in every method’s
signature, is for organization. We’ve put all the things we can do with an
instance of a type in one <code>impl</code> block rather than making future users of our
code search for capabilities of <code>Rectangle</code> in various places in the library we
provide.</p>
<blockquote>
<a class="header" href="print.html#wheres-the---operator" id="wheres-the---operator"><h3>Where’s the <code>-&gt;</code> Operator?</h3></a>
<p>In languages like C++, two different operators are used for calling methods:
you use <code>.</code> if you’re calling a method on the object directly and <code>-&gt;</code> if
you’re calling the method on a pointer to the object and need to dereference
the pointer first. In other words, if <code>object</code> is a pointer,
<code>object-&gt;something()</code> is similar to <code>(*object).something()</code>.</p>
<p>Rust doesn’t have an equivalent to the <code>-&gt;</code> operator; instead, Rust has a
feature called <em>automatic referencing and dereferencing</em>. Calling methods is
one of the few places in Rust that has this behavior.</p>
<p>Here’s how it works: when you call a method with <code>object.something()</code>, Rust
automatically adds in <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code> so <code>object</code> matches the signature of
the method. In other words, the following are the same:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug,Copy,Clone)]
# struct Point {
#     x: f64,
#     y: f64,
# }
#
# impl Point {
#    fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
#        let x_squared = f64::powi(other.x - self.x, 2);
#        let y_squared = f64::powi(other.y - self.y, 2);
#
#        f64::sqrt(x_squared + y_squared)
#    }
# }
# let p1 = Point { x: 0.0, y: 0.0 };
# let p2 = Point { x: 5.0, y: 6.5 };
p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
#}</code></pre></pre>
<p>The first one looks much cleaner. This automatic referencing behavior works
because methods have a clear receiver—the type of <code>self</code>. Given the receiver
and name of a method, Rust can figure out definitively whether the method is
reading (<code>&amp;self</code>), mutating (<code>&amp;mut self</code>), or consuming (<code>self</code>). The fact
that Rust makes borrowing implicit for method receivers is a big part of
making ownership ergonomic in practice.</p>
</blockquote>
<a class="header" href="print.html#methods-with-more-parameters" id="methods-with-more-parameters"><h3>Methods with More Parameters</h3></a>
<p>Let’s practice using methods by implementing a second method on the <code>Rectangle</code>
struct. This time, we want an instance of <code>Rectangle</code> to take another instance
of <code>Rectangle</code> and return <code>true</code> if the second <code>Rectangle</code> can fit completely
within <code>self</code>; otherwise it should return <code>false</code>. That is, we want to be able
to write the program shown in Listing 5-13, once we’ve defined the <code>can_hold</code>
method:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle { length: 50, width: 30 };
    let rect2 = Rectangle { length: 40, width: 10 };
    let rect3 = Rectangle { length: 45, width: 60 };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<p><span class="caption">Listing 5-13: Demonstration of using the as-yet-unwritten
<code>can_hold</code> method</span></p>
<p>And the expected output would look like the following, because both dimensions
of <code>rect2</code> are smaller than the dimensions of <code>rect1</code>, but <code>rect3</code> is wider
than <code>rect1</code>:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>We know we want to define a method, so it will be within the <code>impl Rectangle</code>
block. The method name will be <code>can_hold</code>, and it will take an immutable borrow
of another <code>Rectangle</code> as a parameter. We can tell what the type of the
parameter will be by looking at the code that calls the method:
<code>rect1.can_hold(&amp;rect2)</code> passes in <code>&amp;rect2</code>, which is an immutable borrow to
<code>rect2</code>, an instance of <code>Rectangle</code>. This makes sense because we only need to
read <code>rect2</code> (rather than write, which would mean we’d need a mutable borrow),
and we want <code>main</code> to retain ownership of <code>rect2</code> so we can use it again after
calling the <code>can_hold</code> method. The return value of <code>can_hold</code> will be a
boolean, and the implementation will check whether the length and width of
<code>self</code> are both greater than the length and width of the other <code>Rectangle</code>,
respectively. Let’s add the new <code>can_hold</code> method to the <code>impl</code> block from
Listing 5-12, shown in Listing 5-14:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# struct Rectangle {
#     length: u32,
#     width: u32,
# }
#
impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.length * self.width
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &gt; other.length &amp;&amp; self.width &gt; other.width
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 5-14: Implementing the <code>can_hold</code> method on
<code>Rectangle</code> that takes another <code>Rectangle</code> instance as a parameter</span></p>
<p>When we run this code with the <code>main</code> function in Listing 5-13, we’ll get our
desired output. Methods can take multiple parameters that we add to the
signature after the <code>self</code> parameter, and those parameters work just like
parameters in functions.</p>
<a class="header" href="print.html#associated-functions" id="associated-functions"><h3>Associated Functions</h3></a>
<p>Another useful feature of <code>impl</code> blocks is that we’re allowed to define
functions within <code>impl</code> blocks that <em>don’t</em> take <code>self</code> as a parameter. These
are called <em>associated functions</em> because they’re associated with the struct.
They’re still functions, not methods, because they don’t have an instance of
the struct to work with. You’ve already used the <code>String::from</code> associated
function.</p>
<p>Associated functions are often used for constructors that will return a new
instance of the struct. For example, we could provide an associated function
that would have one dimension parameter and use that as both length and width,
thus making it easier to create a square <code>Rectangle</code> rather than having to
specify the same value twice:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# struct Rectangle {
#     length: u32,
#     width: u32,
# }
#
impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
        Rectangle { length: size, width: size }
    }
}
#}</code></pre></pre>
<p>To call this associated function, we use the <code>::</code> syntax with the struct name,
like <code>let sq = Rectangle::square(3);</code>, for example. This function is
namespaced by the struct: the <code>::</code> syntax is used for both associated functions
and namespaces created by modules, which we'll discuss in Chapter 7.</p>
<a class="header" href="print.html#summary" id="summary"><h2>Summary</h2></a>
<p>Structs let us create custom types that are meaningful for our domain. By using
structs, we can keep associated pieces of data connected to each other and name
each piece to make our code clear. Methods let us specify the behavior that
instances of our structs have, and associated functions let us namespace
functionality that is particular to our struct without having an instance
available.</p>
<p>But structs aren’t the only way we can create custom types: let’s turn to
Rust’s enum feature to add another tool to our toolbox.</p>
<a class="header" href="print.html#열거형과-패턴-매칭" id="열거형과-패턴-매칭"><h1>열거형과 패턴 매칭</h1></a>
<p>이번 장에서는 <em>열거(enumerations)</em> 에 대해 살펴 볼 것 입니다. <em>열거형(enums)</em> 이라고도 합니다.
열거형은 하나의 타입이 갖을 수 있는 값들을 열거 함으로써 타입을 정의 할 수 있도록 합니다.
우선, 하나의 열거형을 정의하고 사용해 봄으로써, 어떻게 열거형에 의미와 함께 데이터를 담을 수 있는지 보여줄 것 입니다.
다음으로, <code>Option</code> 이라고 하는 특히 유용한 열거형을 자세히 볼 텐데, 이것은 어떤 값을 갖을 수 도 있고, 갖지 않을 수 도 있습니다.
그 다음으로, 열거형의 값에 따라 쉽게 다른 코드를 실행하기 위해 <code>match</code> 표현식에서 패턴 매칭을 사용하는 방법을 볼 것 입니다.
마지막으로, 코드에서 열거형을 편하고 간결하게 다루기 위한 관용 표현인 <code>if let</code> 구문을 다룰 것입니다.</p>
<p>열거형은 다른 언어들에서도 볼 수 있는 특징이지만, 각 언어마다 열거형으로 할 수 있는 것들이 다릅니다.
러스트의 열거형은 F#, OCaml, Haskell 과 같은 함수형 언어의 <em>대수 데이터 타입</em>과 가장 비슷합니다.</p>
<a class="header" href="print.html#열거형-정의하기" id="열거형-정의하기"><h2>열거형 정의하기</h2></a>
<p>코드를 작성 할 때, 어떻게 열거형이 구조체 보다 더 적절하고 유용한지 살펴 볼
것입니다. IP 주소를 다뤄야 하는 경우를 생각해 봅시다.
현재 IP 주소에는 두개의 주요한 표준이 있습니다: 버전 4와 버전 6 입니다.
프로그램에서 IP 주소에 대해 다룰 때 이 두 가지가 유일한 경우들 입니다:
모든 가능한 값들을 <em>나열(enumerate)</em> 할 수 있으며, 이 경우를 열거라고 부를 수
있습니다.</p>
<p>어떤 IP 주소는 버전 4나 버전 6이 될 수 있으며, 동시에 두 버전이 될 수는
없습니다.
IP 주소의 속성을 보면 열거형 자료 구조가 적절합니다.
왜냐하면, 열거형의 값은 variants 중 하나만 될 수 있기 때문 입니다.
버전 4나 버전 6은 근본적으로 IP 주소이기 때문에, 이 둘은 코드에서 모든 종류의
IP 주소에 적용되는 상황을 다룰 때 동일한 타입으로 처리되는 것이 좋습니다.</p>
<p><code>IpAddrKind</code> 이라는 열거형을 정의하면서 포함할 수 있는 IP 주소인 <code>V4</code> 과 <code>V6</code> 를
나열함으로써 이 개념을 코드에 표현할 수 있습니다.
이것들은 열거형의 <em>variants</em> 라고 합니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddrKind {
    V4,
    V6,
}
#}</code></pre></pre>
<p><code>IpAddrKind</code> is now a custom data type that we can use elsewhere in our code.</p>
<a class="header" href="print.html#열거형-값" id="열거형-값"><h3>열거형 값</h3></a>
<p>아래 처럼 <code>IpAddrKind</code> 의 두개의 variants 에 대한 인스턴스를 만들 수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
#}</code></pre></pre>
<p>열거형의 variants 는 열거형을 정의한 식별자에 의해 이름 공간이 생기며, 두개의
콜론을 사용하여 둘을 구분할 수 있습니다. <code>IpAddrKind::V4</code> 와 <code>IpAddrKind::V6</code> 의
값은 동일한 타입이기 때문에, 이 방식이 유용 합니다: <code>IpAddrKind</code>
이제 <code>IpAddrKind</code> 타입을 인자로 받는 함수를 정의할 수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
fn route(ip_type: IpAddrKind) { }
#}</code></pre></pre>
<p>그리고, variant 중 하나를 사용해서 함수를 호출 할 수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
# fn route(ip_type: IpAddrKind) { }
#
route(IpAddrKind::V4);
route(IpAddrKind::V6);
#}</code></pre></pre>
<p>열거형을 사용하면 잇점이 더 있습니다. IP 주소 타입에 대해 더 생각해 볼 때,
지금으로써는 실제 IP 주소 <em>데이터</em>를 저장할 방법이 없습니다; 단지 어떤 <em>종류</em>
인지만 알 뿐 입니다. 5장에서 구조체에 대해 방금 공부 했다고 한다면, 이 문제를
Listing 6-1 에서 보여지는 것 처럼 풀려고 할 것 입니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from(&quot;127.0.0.1&quot;),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from(&quot;::1&quot;),
};
#}</code></pre></pre>
<p><span class="caption">Listing 6-1: <code>struct</code> 를 사용해서 IP 주소의 데이터와
<code>IpAddrKind</code> variant 저장하기</span></p>
<p>여기서 두 개의 필드를 갖는 <code>IpAddr</code> 를 정의 했습니다: <code>IpAddrKind</code> 타입(이전에
정의한 열거형)인 <code>kind</code> 필드와 <code>String</code> 타입인 <code>address</code> 필드 입니다. 구조체에
대한 두 개의 인스턴스가 있습니다.
첫번째 <code>home</code> 은 <code>kind</code> 의 값으로 <code>IpAddrKind::V4</code> 을 갖고 연관된 주소 데이터로
<code>127.0.0.1</code> 를 갖습니다. 두번째 <code>loopback</code> 은 <code>IpAddrKind</code> 의 다른 variant 인
<code>V6</code> 을 값으로 갖고, 연관된 주소로 <code>::1</code> 를 갖습니다. <code>kind</code> 와 <code>address</code> 의
값을 함께 사용하기 위해 구조체를 사용 했습니다. 그렇게 함으로써 variant 가
연관된 값을 갖게 되었습니다.</p>
<p>각 열거형 variant 에 데이터를 직접 넣는 방식을 사용해서 열거형을 구조체의 일부로
사용하는 방식 보다 더 간결하게 동일한 개념을 표현할 수 있습니다.
<code>IpAddr</code> 얼거형의 새로운 정의에서는 두 개의 <code>V4</code> 와 <code>V6</code> variant 는 연관된
<code>String</code> 타입의 값을 갖게 됩니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>열거형의 각 variant 에 직접 데이터를 붙임으로써, 구조체를 사용할 필요가 없어
졌습니다.</p>
<p>구조체 보다 열거형을 사용할 때 다른 장점이 있습니다: 각 variant 는 다른 타입과
다른 양의 연관된 데이터를 가질 수 있습니다. 버전 4 타입의 IP 주소는 항상 0 ~ 255
사이의 숫자 4개로 된 구성요소를 갖게 될 것 입니다. <code>V4</code> 주소에 4개의 <code>u8</code> 값을
저장하길 원하지만, V6 주소는 하나의 String 값으로 표현되길 원한다면, 구조체로는
이렇게 할 수 없습니다. 열거형은 이런 경우를 쉽게 처리합니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>두가지 다른 종류의 IP 주소를 저장하기 위해 코드상에서 열거형을 정의하는 몇가지
방법을 살펴 봤습니다. 그러나, 누구나 알듯이 IP 주소와 그 종류를 저장하는 것은
흔하기 때문에, <a href="../../std/net/enum.IpAddr.html">표준 라이브러리에 사용할 수 있는 정의가 있습니다!</a></p>
<!-- ignore --> 표준 라이브러리에서 `IpAddr` 를 어떻게 정의하고 있는지 살펴봅시
다. 위에서 정의하고 사용했던 것과 동일한 열거형과 variant 를 갖고 있지만,
variant 에 포함된 주소 데이터는 두 가지 다른 구조체로 되어 있으며, 각 variant 
마다 다르게 정의하고 있습니다:
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ipv4Addr {
    // details elided
}

struct Ipv6Addr {
    // details elided
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#}</code></pre></pre>
<p>이 코드에서 보듯이 열거형 variant 에 어떤 종류의 데이터라도 넣을 수 있습니다:
예를 들면 문자열, 숫자 타입, 혹은 구조체. 다른 열거형 조차도 포함할 수 있습니다!
또한 표준 라이브러리 타입들은 어떤 경우에는 해결책으로 생각한 것보다 훨씬 더
복잡하지 않습니다.</p>
<p>현재 스코프에 표준 라이브러리를 가져오지 않았기 때문에, 표준 라이브러리에
<code>IpAddr</code> 정의가 있더라도, 동일한 이름의 타입을 만들고 사용할 수 있습니다.
타입을 가져오는 것에 대해서는 7장에서 더 살펴볼 것 입니다.</p>
<p>Listing 6-2 에 있는 열거형의 다른 예제를 살펴 봅시다: 이 예제에서는 각 variants
에 다양한 유형의 타입들이 포함되어 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#}</code></pre></pre>
<p><span class="caption">Listing 6-2: <code>Message</code> 열거형은 각 variants 가 다른 타입과
다른 양의 값을 저장함.</span></p>
<p>이 열거형에는 다른 데이터 타입을 갖는 네 개의 variants 가 있습니다:</p>
<ul>
<li><code>Quit</code> 은 연관된 데이터가 전혀 없습니다.</li>
<li><code>Move</code> 은 익명 구조체를 포함 합니다.</li>
<li><code>Write</code> 은 하나의 <code>String</code> 을 포함 합니다.</li>
<li><code>ChangeColor</code> 는 세 개의 <code>i32</code> 을 포함 합니다.</li>
</ul>
<p>Listing 6-2 에서 처럼 variants 로 열거형을 정의하는 것은 다른 종류의 구조체들을
정의하는 것과 비슷합니다. 열거형과 다른 점은 <code>struct</code> 키워드를 사용하지 않는
다는 것과 모든 variants 가 <code>Message</code> 타입으로 그룹화 된다는 것 입니다.
아래 구조체들은 이전 열거형의 variants 가 갖는 것과 동일한 데이터를 포함할 수
있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct QuitMessage; // 유닛 구조체
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // 튜플 구조체
struct ChangeColorMessage(i32, i32, i32); // 튜플 구조체
#}</code></pre></pre>
<p>각기 다른 타입을 갖는 여러 개의 구조체를 사용한다면, 이 메세지 중 어떤 한가지를
인자로 받는 함수를 정의하기 힘들 것 입니다. Listing 6-2 에 정의한 <code>Message</code>
열거형은 하나의 타입으로 이것이 가능 합니다.</p>
<p>열거형과 구조체는 한가지 더 유사한 점이 있습니다: 구조체에 <code>impl</code> 을 사용해서
메서드를 정의한 것 처럼, 열거형에도 정의할 수 있습니다. 여기 <code>Message</code> 열거형에
에 정의한 <code>call</code> 이라는 메서드가 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Message {
#     Quit,
#     Move { x: i32, y: i32 },
#     Write(String),
#     ChangeColor(i32, i32, i32),
# }
#
impl Message {
    fn call(&amp;self) {
        // 메서드 내용은 여기 정의할 수 있습니다.
    }
}

let m = Message::Write(String::from(&quot;hello&quot;));
m.call();
#}</code></pre></pre>
<p>열거형의 값을 가져오기 위해 메서드 안에서 <code>self</code> 를 사용할 것 입니다.
이 에제에서 생성한 변수 <code>m</code> 은 <code>Message::Write(&quot;hello&quot;)</code> 값을 갖게 되고,
이 값은  <code>m.call()</code> 이 실행될 때, <code>call</code> 메서드 안에서 <code>self</code> 가 될 것입니다.</p>
<p>표준 라이브러리에 있는 매우 흔하게 사용하고 유용한 열거형을 살펴 봅시다:
<code>Option</code>.</p>
<a class="header" href="print.html#option-열거형과-null-값-보다-좋은-점들" id="option-열거형과-null-값-보다-좋은-점들"><h3><code>Option</code> 열거형과 Null 값 보다 좋은 점들.</h3></a>
<p>이전 절에서, <code>IpAddr</code> 열거형을 사용하여 작성한 프로그램에서는 러스트 타입
시스템을 사용하여 데이터 뿐만 아니라 더 많은 정보를 담을 수 있는 방법을 살펴
보았습니다.</p>
<p>이번 절에서는 표준 라이브러리에서 열거형으로 정의된 또다른 타입인 <code>Option</code> 에
대한 사용예를 살펴볼 것 입니다. <code>Option</code> 타입은 많이 사용되는데, 값이 있거나
없을 수도 있는 아주 흔한 상황을 나타내기 때문 입니다. 이 개념을 타입 시스템의
관점으로 표현하자면, 컴파일러가 발생할 수 있는 모든 경우를 처리했는지 체크 할 수
있습니다. 이렇게 함으로써 버그를 방지할 수 있고, 이것은 다른 프로그래밍 언어에서
매우 흔합니다.</p>
<p>프로그래밍 언어 디자인은 가끔 어떤 특성들이 포함되었는지의 관점에서 생각되기도
하지만, 포함되지 않은 특성들도 역시 중요 합니다. 러스트는 다른 언어에 있는지
null 특성이 없습니다. <em>Null</em> 은 값이 없다는 것을 표현하는 하나의 값 입니다.
null 을 허용하는 언어에서는, 변수는 항상 두 상태중 하나가 될 수 있습니다:
null 혹은 null 이 아님.</p>
<p>null 을 고안한 Tony Hoare 의 &quot;Null 참조 : 10 억 달러의 실수&quot; 에서 다음과 같이
말합니다:</p>
<blockquote>
<p>나는 그것을 나의 10억 달러의 실수라고 생각한다. 그 당시 객체지향 언어에서
처음 참조를 위한 포괄적인 타입 시스템을 디자인 하고 있었다. 내 목표는
컴파일러에 의해 자동으로 수행되는 체크를 통해 모든 참조의 사용은 절대적으로
안전하다는 것을 확인하는 것이었다. 그러나 null 참조를 넣고 싶은 유혹을 참을
수 없었다. 간단한 이유는 구현이 쉽다는 것이었다. 이것은 수없이 많은 오류와
취약점들, 시스템 종료를 유발 했고, 지난 40년간 10억 달러의 고통과
손실을 초래했을 수도 있다.</p>
</blockquote>
<p>null 값으로 발생하는 문제는, null 값을 null 이 아닌 값 처럼 사용하려고 할 때 여러 종류의 오류가
발생할 수 있다는 것입니다. null 이나 null 이 아닌 속성은 어디에나 있을 수 있고, 너무나도 쉽게 이런
종류의 오류를 만들어 냅니다.</p>
<p>그러나, null 이 표현하려고 하는 것은 아직까지도 유용합니다: null 은 현재 어떤 이유로 유효하지 않고,
존재하지 않는 하나의 값 입니다.</p>
<p>문제는 실제 개념에 있기 보다, 특정 구현에 있습니다. 이와 같이 러스트에는 null 이 없지만, 값의 존재
혹은 부재의 개념을 표현할 수 있는 열거형이 있습니다. 이 열거형은 <code>Option&lt;T&gt;</code> 이며, 다음과 같이
<a href="../../std/option/enum.Option.html">표준 라이브러리에 정의되어</a><!-- ignore --> 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<p><code>Option&lt;T&gt;</code> 열거형은 매우 유용하며 기본적으로 포함되어 있기 때문에, 명시적으로 가져오지 않아도
사용할 수 있습니다. 또한 variants 도 마찬가지 입니다: <code>Option::</code> 를 앞에 붙이지 않고,
<code>Some</code> 과 <code>None</code> 을 바로 사용할 수 있습니다.
<code>Option&lt;T&gt;</code> 는 여전히 일반적인 열거형이고, <code>Some(T)</code> 과 <code>None</code> 도 여전히 <code>Option&lt;T&gt;</code> 의
variants 입니다.</p>
<p><code>&lt;T&gt;</code> 는 러스트의 문법이며 아직 다루지 않았습니다. 제너릭 타입 파라미터 이며, 제너릭에 대해서는
10 장에서 더 자세히 다룰 것 입니다.
지금은 단지 <code>&lt;T&gt;</code> 가 <code>Option</code> 열거형의 <code>Some</code> variant 가 어떤 타입의 데이터라도 가질 수 있다는
것을 의미한다는 것을 알고 있으면 됩니다. 여기 숫자 타입과 문자열 타입을 갖는 <code>Option</code> 값에 대한
예들이 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let some_number = Some(5);
let some_string = Some(&quot;a string&quot;);

let absent_number: Option&lt;i32&gt; = None;
#}</code></pre></pre>
<p><code>Some</code> 이 아닌 <code>None</code> 을 사용한다면, <code>Option&lt;T&gt;</code> 이 어떤 타입을 가질지 러스트에게 알려줄 필요가
있습니다. 컴파일러는 <code>None</code> 만 보고는 <code>Some</code> variant 가 어떤 타입인지 추론할 수 없습니다.</p>
<p><code>Some</code> 값을 얻게 되면, 값이 있다는 것과 <code>Some</code> 이 갖고 있는 값에 대해 알 수 있습니다.
<code>None</code> 값을 사용하면, 어떤 면에서는 null 과 같은 의미를 갖게 됩니다: 유효한 값을 갖지 않습니다.
그렇다면 왜 <code>Option&lt;T&gt;</code> 가 null 을 갖는 것 보다 나을까요?</p>
<p>간단하게 말하면, <code>Option&lt;T&gt;</code> 와 <code>T</code> (<code>T</code> 는 어떤 타입이던 될 수 있음)는 다른 타입이며,
컴파일러는 <code>Option&lt;T&gt;</code> 값을 명확하게 유효한 값 처럼 사용하지 못하도록 합니다. 예를 들면,
아래 코드는 <code>Option&lt;i8&gt;</code> 에 <code>i8</code> 을 더하려고 하기 때문에 컴파일 되지 않습니다:</p>
<pre><code class="language-rust ignore">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
</code></pre>
<p>이 코드를 실행하면, 아래와 같은 에러 메세지가 출력 됩니다:</p>
<pre><code class="language-text">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
 --&gt;
  |
7 | let sum = x + y;
  |           ^^^^^
  |
</code></pre>
<p>주목하세요! 실제로, 이 에러 메세지는 러스트가 <code>Option&lt;i8&gt;</code> 와 <code>i8</code> 를 어떻게
더해야 하는지 모른다는 것을 의미 하는데, 둘은 다른 타입이기 때문 입니다.
러스트에서 <code>i8</code> 과 같은 타입의 값을 가질 때, 컴파일러는 항상 유효한 값을 갖고
있다는 것을 보장할 것 입니다. 값을 사용하기 전에 null 인지 확인할 필요도 없이
자신있게 사용할 수 있습니다. 단지 <code>Option&lt;i8&gt;</code> 을 사용할 경우엔 (혹은 어떤 타입
이건 간에) 값이 있을지 없을지에 대해 걱정할 필요가 있으며, 컴파일러는 값을
사용하기 전에 이런 케이스가 처리되었는지 확인해 줄 것입니다.</p>
<p>다르게 얘기 하자면, <code>T</code> 에 대한 연산을 수행하기 전에 <code>Option&lt;T&gt;</code> 를 <code>T</code> 로
변환해야 합니다. 일반적으로, 이런 방식은 null 과 관련된 가장 흔한 이슈 중 하나를
발견하는데 도움을 줍니다: 실제로 null 일 때, null 이 아니라고 가정하는 경우
입니다.</p>
<p>null 이 아닌 값을 갖는 다는 가정을 놓치는 경우에 대해 걱정 할 필요가 없게되면,
코드에 더 확신을 갖게 됩니다. null 일 수 있는 값을 사용하기 위해서,
명시적으로 값의 타입을 <code>Option&lt;T&gt;</code> 로 만들어 줘야 합니다. 그다음엔 값을 사용할
때 명시적으로 null 인 경우를 처리해야 합니다. 값의 타입이 <code>Option&lt;T&gt;</code> 가 아닌
모든 곳은 값이 null 아 아니라고 안전하게 가정 <em>할 수 있습니다</em>.
이것은 null을 너무 많이 사용하는 문제를 제한하고 러스트 코드의 안정성을 높이기 위한 러스트의 의도된
디자인 결정사항 입니다.</p>
<p>그럼 <code>Option&lt;T&gt;</code> 타입인 값을 사용할 때, <code>Some</code> variant 에서 <code>T</code> 값을 어떻게
가져와서 사용할 수 있을까요? <code>Option&lt;T&gt;</code> 열거형에서 다양한 상황에서 유용하게
사용할 수 있는 많은 메소드들이 있습니다; <a href="../../std/option/enum.Option.html">문서에서</a><!-- ignore --> 확인할
수 있습니다. <code>Option&lt;T&gt;</code> 의 메소드들에 익숙해 지는 것은 러스트를 사용하는데
매우 유용할 것 입니다.</p>
<p>일반적으로, <code>Option&lt;T&gt;</code> 값을 사용하기 위해서는 각 variant 를 처리할 코드가 필요
할 것입니다. <code>Some(T)</code> 값일 경우만 실행되는 코드가 필요하고, 이 코드는 안에있는
<code>T</code> 를 사용할 수 있습니다. 다른 코드에서는 <code>None</code> 값일 때 실행되는 코드가 필요가
하기도 하며, 이 코드에서는 사용할 수 있는 <code>T</code> 값이 없습니다.
<code>match</code> 표현식은 제어 흐름을 위한 구분으로, 열거형과 함께 사용하면 이런 일들을
할 수 있습니다: 열거형이 갖는 variant 에 따라 다른 코드를 실행할 것이고, 그 코드
는 매칭된 값에 있는 데이터를 사용할 수 있습니다.</p>
<a class="header" href="print.html#the-match-control-flow-operator" id="the-match-control-flow-operator"><h2>The <code>match</code> Control Flow Operator</h2></a>
<p>Rust has an extremely powerful control-flow operator called <code>match</code> that allows
us to compare a value against a series of patterns and then execute code based
on which pattern matches. Patterns can be made up of literal values, variable
names, wildcards, and many other things; Chapter 18 will cover all the
different kinds of patterns and what they do. The power of <code>match</code> comes from
the expressiveness of the patterns and the compiler checks that make sure all
possible cases are handled.</p>
<p>Think of a <code>match</code> expression kind of like a coin sorting machine: coins slide
down a track with variously sized holes along it, and each coin falls through
the first hole it encounters that it fits into. In the same way, values go
through each pattern in a <code>match</code>, and at the first pattern the value “fits,”
the value will fall into the associated code block to be used during execution.</p>
<p>Because we just mentioned coins, let’s use them as an example using <code>match</code>! We
can write a function that can take an unknown United States coin and, in a
similar way as the counting machine, determine which coin it is and return its
value in cents, as shown here in Listing 6-3:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; i32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 6-3: An enum and a <code>match</code> expression that has
the variants of the enum as its patterns.</span></p>
<p>Let’s break down the <code>match</code> in the <code>value_in_cents</code> function. First, we list
the <code>match</code> keyword followed by an expression, which in this case is the value
<code>coin</code>. This seems very similar to an expression used with <code>if</code>, but there’s a
big difference: with <code>if</code>, the expression needs to return a boolean value.
Here, it can be any type. The type of <code>coin</code> in this example is the <code>Coin</code> enum
that we defined in Listing 6-3.</p>
<p>Next are the <code>match</code> arms. An arm has two parts: a pattern and some code. The
first arm here has a pattern that is the value <code>Coin::Penny</code> and then the <code>=&gt;</code>
operator that separates the pattern and the code to run. The code in this case
is just the value <code>1</code>. Each arm is separated from the next with a comma.</p>
<p>When the <code>match</code> expression executes, it compares the resulting value against
the pattern of each arm, in order. If a pattern matches the value, the code
associated with that pattern is executed. If that pattern doesn’t match the
value, execution continues to the next arm, much like a coin sorting machine.
We can have as many arms as we need: in Listing 6-3, our <code>match</code> has four arms.</p>
<p>The code associated with each arm is an expression, and the resulting value of
the expression in the matching arm is the value that gets returned for the
entire <code>match</code> expression.</p>
<p>Curly braces typically aren’t used if the match arm code is short, as it is in
Listing 6-3 where each arm just returns a value. If you want to run multiple
lines of code in a match arm, you can use curly braces. For example, the
following code would print out “Lucky penny!” every time the method was called
with a <code>Coin::Penny</code> but would still return the last value of the block, <code>1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter,
# }
#
fn value_in_cents(coin: Coin) -&gt; i32 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Lucky penny!&quot;);
            1
        },
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#patterns-that-bind-to-values" id="patterns-that-bind-to-values"><h3>Patterns that Bind to Values</h3></a>
<p>Another useful feature of match arms is that they can bind to parts of the
values that match the pattern. This is how we can extract values out of enum
variants.</p>
<p>As an example, let’s change one of our enum variants to hold data inside it.
From 1999 through 2008, the United States minted quarters with different
designs for each of the 50 states on one side. No other coins got state
designs, so only quarters have this extra value. We can add this information to
our <code>enum</code> by changing the <code>Quarter</code> variant to include a <code>State</code> value stored
inside it, which we've done here in Listing 6-4:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)] // So we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // ... etc
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
#}</code></pre></pre>
<p><span class="caption">Listing 6-4: A <code>Coin</code> enum where the <code>Quarter</code> variant
also holds a <code>UsState</code> value</span></p>
<p>Let’s imagine that a friend of ours is trying to collect all 50 state quarters.
While we sort our loose change by coin type, we’ll also call out the name of
the state associated with each quarter so if it’s one our friend doesn’t have,
they can add it to their collection.</p>
<p>In the match expression for this code, we add a variable called <code>state</code> to the
pattern that matches values of the variant <code>Coin::Quarter</code>. When a
<code>Coin::Quarter</code> matches, the <code>state</code> variable will bind to the value of that
quarter’s state. Then we can use <code>state</code> in the code for that arm, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
#
fn value_in_cents(coin: Coin) -&gt; i32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        },
    }
}
#}</code></pre></pre>
<p>If we were to call <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>, <code>coin</code>
would be <code>Coin::Quarter(UsState::Alaska)</code>. When we compare that value with each
of the match arms, none of them match until we reach <code>Coin::Quarter(state)</code>. At
that point, the binding for <code>state</code> will be the value <code>UsState::Alaska</code>. We can
then use that binding in the <code>println!</code> expression, thus getting the inner
state value out of the <code>Coin</code> enum variant for <code>Quarter</code>.</p>
<a class="header" href="print.html#matching-with-optiont" id="matching-with-optiont"><h3>Matching with <code>Option&lt;T&gt;</code></h3></a>
<p>In the previous section we wanted to get the inner <code>T</code> value out of the <code>Some</code>
case when using <code>Option&lt;T&gt;</code>; we can also handle <code>Option&lt;T&gt;</code> using <code>match</code> as we
did with the <code>Coin</code> enum! Instead of comparing coins, we’ll compare the
variants of <code>Option&lt;T&gt;</code>, but the way that the <code>match</code> expression works remains
the same.</p>
<p>Let’s say we want to write a function that takes an <code>Option&lt;i32&gt;</code>, and if
there’s a value inside, adds one to that value. If there isn’t a value inside,
the function should return the <code>None</code> value and not attempt to perform any
operations.</p>
<p>This function is very easy to write, thanks to <code>match</code>, and will look like
Listing 6-5:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
#}</code></pre></pre>
<p><span class="caption">Listing 6-5: A function that uses a <code>match</code> expression on
an <code>Option&lt;i32&gt;</code></span></p>
<a class="header" href="print.html#matching-somet" id="matching-somet"><h4>Matching <code>Some(T)</code></h4></a>
<p>Let’s examine the first execution of <code>plus_one</code> in more detail. When we call
<code>plus_one(five)</code>, the variable <code>x</code> in the body of <code>plus_one</code> will have the
value <code>Some(5)</code>. We then compare that against each match arm.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>The <code>Some(5)</code> value doesn’t match the pattern <code>None</code>, so we continue to the
next arm.</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<p>Does <code>Some(5)</code> match <code>Some(i)</code>? Why yes it does! We have the same variant.
The <code>i</code> binds to the value contained in <code>Some</code>, so <code>i</code> takes the value <code>5</code>. The
code in the match arm is then executed, so we add one to the value of <code>i</code> and
create a new <code>Some</code> value with our total <code>6</code> inside.</p>
<a class="header" href="print.html#matching-none" id="matching-none"><h4>Matching <code>None</code></h4></a>
<p>Now let’s consider the second call of <code>plus_one</code> in Listing 6-5 where <code>x</code> is
<code>None</code>. We enter the <code>match</code> and compare to the first arm.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>It matches! There’s no value to add to, so the program stops and returns the
<code>None</code> value on the right side of <code>=&gt;</code>. Because the first arm matched, no other
arms are compared.</p>
<p>Combining <code>match</code> and enums is useful in many situations. You’ll see this
pattern a lot in Rust code: <code>match</code> against an enum, bind a variable to the
data inside, and then execute code based on it. It’s a bit tricky at first, but
once you get used to it, you’ll wish you had it in all languages. It’s
consistently a user favorite.</p>
<a class="header" href="print.html#matches-are-exhaustive" id="matches-are-exhaustive"><h3>Matches Are Exhaustive</h3></a>
<p>There’s one other aspect of <code>match</code> we need to discuss. Consider this version
of our <code>plus_one</code> function:</p>
<pre><code class="language-rust ignore">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>
<p>We didn’t handle the <code>None</code> case, so this code will cause a bug. Luckily, it’s
a bug Rust knows how to catch. If we try to compile this code, we’ll get this
error:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt;
  |
6 |         match x {
  |               ^ pattern `None` not covered
</code></pre>
<p>Rust knows that we didn’t cover every possible case and even knows which
pattern we forgot! Matches in Rust are <em>exhaustive</em>: we must exhaust every last
possibility in order for the code to be valid. Especially in the case of
<code>Option&lt;T&gt;</code>, when Rust prevents us from forgetting to explicitly handle the
<code>None</code> case, it protects us from assuming that we have a value when we might
have null, thus making the billion dollar mistake discussed earlier.</p>
<a class="header" href="print.html#the-_-placeholder" id="the-_-placeholder"><h3>The <code>_</code> Placeholder</h3></a>
<p>Rust also has a pattern we can use in situations when we don’t want to list all
possible values. For example, a <code>u8</code> can have valid values of 0 through 255. If
we only care about the values 1, 3, 5, and 7, we don’t want to have to list out
0, 2, 4, 6, 8, 9 all the way up to 255. Fortunately, we don’t have to: we can
use the special pattern <code>_</code> instead:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let some_u8_value = 0u8;
match some_u8_value {
    1 =&gt; println!(&quot;one&quot;),
    3 =&gt; println!(&quot;three&quot;),
    5 =&gt; println!(&quot;five&quot;),
    7 =&gt; println!(&quot;seven&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p>The <code>_</code> pattern will match any value. By putting it after our other arms, the
<code>_</code> will match all the possible cases that aren’t specified before it. The <code>()</code>
is just the unit value, so nothing will happen in the <code>_</code> case. As a result, we
can say that we want to do nothing for all the possible values that we don’t
list before the <code>_</code> placeholder.</p>
<p>However, the <code>match</code> expression can be a bit wordy in a situation in which we
only care about <em>one</em> of the cases. For this situation, Rust provides <code>if let</code>.</p>
<a class="header" href="print.html#concise-control-flow-with-if-let" id="concise-control-flow-with-if-let"><h2>Concise Control Flow with <code>if let</code></h2></a>
<p>The <code>if let</code> syntax lets you combine <code>if</code> and <code>let</code> into a less verbose way to
handle values that match one pattern and ignore the rest. Consider the program
in Listing 6-6 that matches on an <code>Option&lt;u8&gt;</code> value but only wants to execute
code if the value is three:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let some_u8_value = Some(0u8);
match some_u8_value {
    Some(3) =&gt; println!(&quot;three&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p><span class="caption">Listing 6-6: A <code>match</code> that only cares about executing
code when the value is <code>Some(3)</code></span></p>
<p>We want to do something with the <code>Some(3)</code> match but do nothing with any other
<code>Some&lt;u8&gt;</code> value or the <code>None</code> value. To satisfy the <code>match</code> expression, we
have to add <code>_ =&gt; ()</code> after processing just one variant, which is a lot of
boilerplate code to add.</p>
<p>Instead, we could write this in a shorter way using <code>if let</code>. The following
code behaves the same as the <code>match</code> in Listing 6-6:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let some_u8_value = Some(0u8);
if let Some(3) = some_u8_value {
    println!(&quot;three&quot;);
}
#}</code></pre></pre>
<p><code>if let</code> takes a pattern and an expression separated by an <code>=</code>. It works the
same way as a <code>match</code>, where the expression is given to the <code>match</code> and the
pattern is its first arm.</p>
<p>Using <code>if let</code> means you have less to type, less indentation, and less
boilerplate code. However, we’ve lost the exhaustive checking that <code>match</code>
enforces. Choosing between <code>match</code> and <code>if let</code> depends on what you’re doing in
your particular situation and if gaining conciseness is an appropriate
trade-off for losing exhaustive checking.</p>
<p>In other words, you can think of <code>if let</code> as syntax sugar for a <code>match</code> that
runs code when the value matches one pattern and then ignores all other values.</p>
<p>We can include an <code>else</code> with an <code>if let</code>. The block of code that goes with the
<code>else</code> is the same as the block of code that would go with the <code>_</code> case in the
<code>match</code> expression that is equivalent to the <code>if let</code> and <code>else</code>. Recall the
<code>Coin</code> enum definition in Listing 6-4, where the <code>Quarter</code> variant also held a
<code>UsState</code> value. If we wanted to count all non-quarter coins we see while also
announcing the state of the quarters, we could do that with a <code>match</code>
expression like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
# let coin = Coin::Penny;
let mut count = 0;
match coin {
    Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),
    _ =&gt; count += 1,
}
#}</code></pre></pre>
<p>Or we could use an <code>if let</code> and <code>else</code> expression like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
# let coin = Coin::Penny;
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!(&quot;State quarter from {:?}!&quot;, state);
} else {
    count += 1;
}
#}</code></pre></pre>
<p>If you have a situation in which your program has logic that is too verbose to
express using a <code>match</code>, remember that <code>if let</code> is in your Rust toolbox as well.</p>
<a class="header" href="print.html#summary-1" id="summary-1"><h2>Summary</h2></a>
<p>We’ve now covered how to use enums to create custom types that can be one of a
set of enumerated values. We’ve shown how the standard library’s <code>Option&lt;T&gt;</code>
type helps you use the type system to prevent errors. When enum values have
data inside them, you can use <code>match</code> or <code>if let</code> to extract and use those
values, depending on how many cases you need to handle.</p>
<p>Your Rust programs can now express concepts in your domain using structs and
enums. Creating custom types to use in your API ensures type safety: the
compiler will make certain your functions only get values of the type each
function expects.</p>
<p>In order to provide a well-organized API to your users that is straightforward
to use and only exposes exactly what your users will need, let’s now turn to
Rust’s modules.</p>
<a class="header" href="print.html#모듈을-사용하여-코드를-재사용하고-조직화하기" id="모듈을-사용하여-코드를-재사용하고-조직화하기"><h1>모듈을 사용하여 코드를 재사용하고 조직화하기</h1></a>
<p>여러분이 러스트로 프로그램을 작성하기 시작했을 때, 여러분의 코드는 오로지 <code>main</code> 함수
안에만 있을지도 모르겠습니다. 코드가 커짐에 따라서, 여러분은 재사용 및 더 나은 조직화를
위하여 결국 어떤 기능을 다른 함수로 이동시킬 것입니다. 코드를 더 작은 덩어리로 쪼갬으로서,
각각의 덩어리들은 개별적으로 이해하기 더 수월해집니다. 하지만 함수가 너무 많으면 어떤
일이 벌어질까요? 러스트는 조직화된 방식으로 코드의 재사용을 할 수 있게 해주는 모듈(module)
시스템을 갖추고 있습니다.</p>
<p>코드 몇줄을 함수로 추출하는 것과 같은 방식으로, 여러분은 함수 (혹은 구조체나 열거형
같은 다른 코드들)를 다른 모듈로 뽑아낼 수 있으며, 여러분은 이것들의 정의가 모듈의
바깥쪽에서 볼 수 있도록 하거나(public) 혹은 보이지 않게 하도록 (private) 선택할
수 있습니다. 모듈이 어떤 식으로 동작하는지에 대한 개요를 봅시다:</p>
<ul>
<li><code>mod</code> 키워드는 새로운 모듈을 선언합니다. 모듈 내의 코드는 이 선언 바로 뒤에
중괄호 로 묶여서 따라오거나 다른 파일에 놓일 수 있습니다.</li>
<li>기본적으로, 함수, 타입, 상수, 그리고 모듈은 private입니다. <code>pub</code> 키워드가
어떤 아이템을 public하게 만들어줘서 이것의 네임스페이스 바깥쪽에서도 볼 수
있도록 합니다.</li>
<li><code>use</code> 키워드는 모듈이나 모듈 내의 정의들을 스코프 안으로 가져와서 이들을
더 쉽게 참조할 수 있도록 합니다.</li>
</ul>
<p>각각의 부분들을 살펴보면서 이것들이 전체적으로 어떻게 맞물리는지 살펴봅시다.</p>
<a class="header" href="print.html#mod와-파일-시스템" id="mod와-파일-시스템"><h2><code>mod</code>와 파일 시스템</h2></a>
<p>먼저 카고를 이용해서 새로운 프로젝트를 만드는 것으로 모듈 예제를 시작하려고 하는데,
바이너리 크레이트(crate)을 만드는 대신에 라이브러리 크레이트을 만들 것입니다. 여기서
라이브러리 크레이트이란 다른 사람들이 자신들의 프로젝트에 디펜던시(dependency)로 추가할
수 있는 프로젝트를 말합니다. 예를 들어, 2장의 <code>rand</code> 크레이트은 우리가 추측 게임
프로젝트에서 디펜던시로 사용했던 라이브러리 크레이트입니다.</p>
<p>우리는 몇가지 일반적인 네트워크 기능을 제공하는 라이브러리의 뼈대를 만들 것입니다;
여기서는 모듈들과 함수들의 조직화에 집중할 것이고, 함수의 본체에 어떤 코드가 들어가야
하는지는 신경쓰지 않겠습니다. 이 라이브러리를 <code>communicator</code>라고 부르겠습니다.
기본적으로, 카고는 다른 타입의 프로젝트로 특정하지 않는 이상 라이브러리를 만들
것입니다: 이전의 모든 장들에서 사용해왔던 <code>--bin</code> 옵션을 제거하면, 프로젝트는
라이브러리가 될 것입니다:</p>
<pre><code class="language-text">$ cargo new communicator
$ cd communicator
</code></pre>
<p>카고가 <em>src/main.rs</em> 대신 <em>src/lib.rs</em>을 생성했음을 주목하세요. <em>src/lib.rs</em>
내부를 보면 다음과 같은 코드를 찾을 수 있습니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
    }
}
#}</code></pre></pre>
<p>카고는 우리가 만든 라이브러리의 작성 시작을 돕기 위해 빈 테스트를 만드는데,
이는 <code>--bin</code> 옵션을 사용했을때 “Hello, world!” 바이너리를 만들어준 것과 사뭇
다릅니다. <code>#[]</code>와 <code>mod tests</code> 문법은 이 장의 “<code>super</code>를 이용하여 부모 모듈에
접근하기”절에서 더 자세히 다룰 것이지만, 당장은 <em>src/lib.rs</em>의 아래쪽에 이 코드를
남겨두겠습니다.</p>
<p><em>src/main.rs</em> 파일이 없기 떄문에, <code>cargo run</code> 커맨드로 카고가 실행할 것이 없습니다.
따라서, 여기서는 라이브러리 크레이트의 코드를 컴파일하기 위해 <code>cargo build</code>를 사용할
것입니다.</p>
<p>이제 여러분이 작성하는 코드의 의도에 따라 만들어지는 다양한 상황에 알맞도록 라이브러리
코드를 조직화하는 다양한 옵션들을 살펴보겠습니다.</p>
<a class="header" href="print.html#모듈-정의" id="모듈-정의"><h3>모듈 정의</h3></a>
<p>우리의 <code>communicator</code> 네트워크 라이브러리를 위해서, 먼저 <code>connect</code>라는 이름의 함수가
정의되어 있는 <code>network</code>라는 이름의 모듈을 정의하겠습니다. 러스트 내 모듈 정의는 모두
<code>mod</code>로 시작됩니다. 이 코드를 <em>src/lib.rs</em>의 시작 부분, 즉 테스트 코드의 윗 쪽에
추가해봅시다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}
#}</code></pre></pre>
<p><code>mod</code> 키워드 뒤에, 모듈의 이름 <code>network</code>가 쓰여지고 중괄호 안에 코드 블록이 옵니다.
이 블록 안의 모든 것은 이름공간 <code>network</code> 안에 있습니다. 위의 경우 <code>connect</code>라는
이름의 함수 하나가 있습니다. 이 함수를 <code>network</code> 모듈 바깥의 스크립트에서 호출하고자
한다면, 우리는 모듈을 특정할 필요가 있으므로 이름공간 문법 <code>::</code>를 이용해야 합니다:
<code>connect()</code> 이렇게만 하지 않고 <code>network::connect()</code> 이런 식으로요.</p>
<p>또한 같은 <em>src/lib.rs</em> 파일 내에 여러 개의 모듈을 나란히 정의할 수도 있습니다.
예를 들어, <code>connect</code>라는 이름의 함수를 갖고 있는 <code>client</code> 모듈을 정의하려면,
Listing 7-1에 보시는 바와 같이 이를 추가할 수 있습니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}

mod client {
    fn connect() {
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 7-1: <em>src/lib.rs</em> 내에 나란히 정의된 <code>network</code>
모듈과 <code>client</code> 모듈</span></p>
<p>이제 우리는 <code>network::connect</code> 함수와 <code>client::connect</code> 함수를 갖게 되었습니다.
이들은 완전히 다른 기능을 갖고 있을 수 있고, 서로 다른 모듈에 정의되어 있기 때문에
함수 이름이 서로 부딪힐 일은 없습니다.</p>
<p>이 경우, 우리가 라이브러리를 만드는 중이기 때문에, 라이브러리의 시작 지점으로서
제공되는 파일은 <em>src/lib.rs</em> 입니다. 하지만 모듈을 만드는 것에 관하여
<em>src/lib.rs</em>는 특별할 것이 없습니다. 우리는 라이브러리 크레이트의 <em>src/lib.rs</em> 내에
모듈을 만드는 것과 똑같은 방식으로 바이너리 크레이트의 <em>src/main.rs</em> 내에도 모듈을
만들 수 있습니다. 사실 모듈 안에 다른 모듈을 집어넣는 것도 가능한데, 이는 여러분의
모듈이 커짐에 따라 관련된 기능이 잘 조직화 되도록 하는 한편 각각의 기능을 잘 나누도록
하는데 유용할 수 있습니다. 여러분의 코드를 어떻게 조직화 할 것인가에 대한 선택은
여러분이 코드의 각 부분 간의 관계에 대해 어떻게 생각하고 있는지에 따라 달라집니다.
예를 들어, Listing 7-2와 같이 <code>client</code> 모듈과 <code>connect</code> 함수가 <code>network</code> 이름공간
내에 있다면 우리의 라이브러리 사용자가 더 쉽게 이해할지도 모릅니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }

    mod client {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 7-2: <code>client</code> 모듈을 <code>network</code> 모듈 안으로 이동</span></p>
<p><em>src/lib.rs</em> 파일에서 Listing 7-2와 같이 <code>client</code> 모듈이 <code>network</code> 모듈의
내부 모듈이 되도록 <code>mod network</code>와 <code>mod client</code>의 위치를 바꿔 봅시다. 이제
우리는 <code>network::connect</code>와 <code>network::client::connect</code> 함수를 갖게 되었습니다:
다시 말하지만, <code>connect</code>라는 이름의 두 함수는 서로 다른 이름공간에 있으므로
부딪힐 일이 없습니다.</p>
<p>이런 식으로 모듈들은 계층을 구성하게 됩니다. <em>src/lib.rs</em>의 내용은 가장 위의 층을
이루고, 서브 모듈들은 그보다 낮은 층에 있습니다. Listing 7-1 예제에서의 조직화가
계층 구조를 생각했을 때 어떻게 보일지 살펴봅시다:</p>
<pre><code class="language-text">communicator
 ├── network
 └── client
</code></pre>
<p>그리고 Listing 7-2 예제에 대응되는 계층 구조는 이렇습니다:</p>
<pre><code class="language-text">communicator
 └── network
     └── client
</code></pre>
<p>Listing 7-2에서 계층 구조는 <code>client</code>가 <code>network</code>의 형제이기 보다는 자식임을
보여줍니다. 더 복잡한 프로젝트는 많은 수의 모듈을 갖고 있을 수 있고, 이들은 지속적인
트래킹을 위해 논리적으로 잘 조직화될 필요가 있을 것입니다. 여러분의 프로젝트 내에서
“논리적으로”가 의미하는 것은 여러분에게 달려 있는 것이며, 여러분과 여러분의 라이브러리
사용자들이 프로젝트 도메인에 대해 어떻게 생각하는지에 따라 달라집니다. 여러분이 선호하는
어떤 형태의 구조이건 간에 여기서 보여준 나란한 모듈 및 중첩된(nested) 모듈을 만드는
테크닉을 이용해 보세요.</p>
<a class="header" href="print.html#모듈을-다른-파일로-옮기기" id="모듈을-다른-파일로-옮기기"><h3>모듈을 다른 파일로 옮기기</h3></a>
<p>Modules form a hierarchical structure, much like another structure in computing
that you’re used to: filesystems! We can use Rust’s module system along with
multiple files to split up Rust projects so not everything lives in
<em>src/lib.rs</em> or <em>src/main.rs</em>. For this example, let’s start with the code in
Listing 7-3:
모듈은 계층적인 구조를 형성하는데, 여러분이 익숙하게 사용하고 있는 다른 구조와 매우 닮았습니다: 바로
파일 시스템이죠! 러스트에서는 프로젝트를 잘게 나누기 위해 여러 개의 파일 상에서 모듈 시스템을 사용할
수 있어, 모든 것들이 <em>src/lib.rs</em>나 <em>src/main.rs</em> 안에 존재하지 않게할 수 있습니다. 이러한
예를 위해서, Listing 7-3에 있는 코드를 시작해봅시다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod client {
    fn connect() {
    }
}

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 7-3: 세 개의 모듈 <code>client</code>, <code>network</code>, <code>network::server</code>가
모두 <em>src/lib.rs</em>에 정의되어 있음</span></p>
<p>파일 <em>src/lib.rs</em>는 아래와 같은 모듈 계층을 갖고 있습니다:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<p>만일 이 모듈들이 여러 개의 함수들을 갖고 있고, 이 함수들이 길어지고 있다면, 우리가 작업하고자 하는
코드를 찾으려고 이 파일을 스크롤 하기가 까다로워질 것입니다. 함수들은 하나 혹은 그 이상의 <code>mod</code> 블록
안에 포함되어 있기 떄문에, 함수 내의 코드 라인들 또한 길어지기 시작할 것입니다. 이는 <code>client</code>,
<code>network</code>, 그리고 <code>server</code> 모듈을 <em>src/lib.rs</em>로부터 떼어내어 각자를 위한 파일들에 위치시키기
좋은 이유가 되겠습니다.</p>
<p>먼저 <code>client</code> 모듈의 코드를 <code>client</code> 모듈의 선언 부분만 남겨두는 것으로 바꾸세요. 그러니까 여러분의
<em>src/lib.rs</em>는 아래와 같이 될 것입니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
</code></pre>
<p>여기서는 여전히 <code>client</code> 모듈을 <em>선언</em>하고 있지만, 코드 블록을 세미콜론으로 대체함으로써, 우리는
러스트에게 <code>client</code> 모듈의 스코프 내에 정의된 코드를 다른 위치에서 찾으라고 말하는 것입니다. 달리
말하면, <code>mod client;</code>라는 라인의 뜻은 이렇습니다:</p>
<pre><code class="language-rust ignore">mod client {
    // contents of client.rs
}
</code></pre>
<p>이제 모듈의 이름과 같은 이름을 가진 외부 파일을 만들 필요가 있습니다. <em>client.rs</em> 파일을 여러분의
<em>src/</em> 디렉토리에 생성하고 여세요. 그런 뒤 아래와 같이 앞 단계에서 제거했던 <code>client</code> 모듈내의
<code>connect</code> 함수를 입력해세요:</p>
<p><span class="filename">Filename: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>이미 <em>src/lib.rs</em> 안에다 <code>client</code> 모듈을 <code>mod</code>를 이용하여 선언을 했기 때문에,
이 파일 안에는 <code>mod</code> 선언이 필요없다는 점을 기억하세요. 이 파일은 단지 <code>client</code> 모듈의 <em>내용물</em>만
제공할 뿐입니다. 만일 <code>mod client</code>를 여기에 또 집어넣는다면, 이는 <code>client</code> 모듈 내에 서브모듈
<code>client</code>를 만들게 됩니다!</p>
<p>러스트는 기본적으로 <em>src/lib.rs</em>만 찾아볼줄 압니다. 만약에 더 많은 파일을 프로젝트에 추가하고
싶다면, <em>src/lib.rs</em> 내에서 다른 파일을 찾아보라고 러스트에게 말해줄 필요가 있습니다; 이는
<code>mod client</code>라는 코드가 왜 <em>src/lib.rs</em> 내에 정의될 필요가 있는지, 그리고 <em>src/client.rs</em>
내에는 정의될 수 없는지에 대한 이유입니다.</p>
<p>이제 몇 개의 컴파일 경고가 생기지만, 프로젝트는 성공적으로 컴파일 되어야 합니다. 우리가 바이너리 크레이트
대신 라이브러리 크레이트를 만드는 중이므로 <code>cargo run</code> 대신 <code>cargo build</code>를 이용해야 한다는 점을
기억해두세요:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/client.rs:1:1
  |
1 | fn connect() {
  | ^

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/lib.rs:4:5
  |
4 |     fn connect() {
  |     ^

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/lib.rs:8:9
  |
8 |         fn connect() {
  |         ^
</code></pre>
<p>이 경고들은 사용된 적이 없는 함수가 있음을 우리에게 알려줍니다. 지금은 이 경고들을 너무 걱정하지 마세요:
이 장의 뒤에 나오는 “<code>pub</code>을 이용하여 가시성 제어하기”절에서 이 문제에 대해 알아볼 것입니다. 좋은 소식은
이들이 그냥 경고일 뿐이란 것입니다; 우리 프로젝트는 성공적으로 빌드됐습니다!</p>
<p>다음으로 같은 방식을 이용하여 <code>network</code> 모듈을 개별 파일로 추출해봅시다. <em>src/lib.rs</em> 안에서,
아래와 같이 <code>network</code> 모듈의 몸체를 지우고 선언부의 끝부분에 세미콜론을 붙이세요:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network;
</code></pre>
<p>그리고나서 새로운 <em>src/network.rs</em> 파일을 만들어서 아래를 입력하세요:</p>
<p><span class="filename">Filename: src/network.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}

mod server {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>이 모듈 파일 내에는 <code>mod</code> 선언이 여전히 있음을 주목하세요; 이는 <code>server</code>가 <code>network</code>의 서브모듈로서
여전히 필요하기 때문입니다.</p>
<p>Run <code>cargo build</code> again. Success! We have one more module to extract: <code>server</code>.
Because it’s a submodule—that is, a module within a module—our current tactic
of extracting a module into a file named after that module won’t work. We’ll
try anyway so you can see the error. First, change <em>src/network.rs</em> to have
<code>mod server;</code> instead of the <code>server</code> module’s contents:
<code>cargo build</code>를 다시 실행시키세요. 성공! 여기 또 추출할만한 모듈이 하나 더 있습니다: <code>server</code> 말이죠.
이것이 서브모듈(즉, 모듈 내의 모듈)이기 때문에, 모듈을 파일로 추출해서 파일 이름을 모듈 이름으로 사용하는
전략은 사용하기 힘듭니다. 어쨌든 시도해서 에러를 확인해보겠습니다. 먼저, <em>src/network.rs</em> 내에서
<code>server</code> 모듈의 내용물 대신에 <code>mod server</code>을 쓰세요:</p>
<p><span class="filename">Filename: src/network.rs</span></p>
<pre><code class="language-rust ignore">fn connect() {
}

mod server;
</code></pre>
<p>Then create a <em>src/server.rs</em> file and enter the contents of the <code>server</code>
module that we extracted:
그후 <em>src/server.rs</em> 파일을 만들고 추출해둔 <code>server</code> 모듈의 내용물을 입력하세요:</p>
<p><span class="filename">Filename: src/server.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p><code>cargo build</code>를 실행해보면, Listing 7-4와 같은 에러를 얻게 됩니다:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
error: cannot declare a new module at this location
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
  |
note: maybe move this module `network` to its own directory via `network/mod.rs`
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
note: ... or maybe `use` the module `server` instead of possibly redeclaring it
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
</code></pre>
<p><span class="caption">Listing 7-4: <code>server</code> 서브모듈을 <em>src/server.rs</em>로 추출을 시도했을 때
발생하는 에러</span></p>
<p>에러는 <code>이 위치에 새로운 모듈을 선언할수 없다</code>고 말해주며 <em>src/network.rs</em>의 <code>mod server;</code>
라인을 지적하고 있습니다. <em>src/network.rs</em>는 <em>src/lib.rs</em>와는 다소 다릅니다: 왜 그런지
이해하려면 계속 읽어주세요.</p>
<p>Listing 7-4의 중간의 노트는 실질적으로 매우 도움이 되는데, 그 이유는 우리가 아직 설명하지 않은
무언가를 지적하고 있기 때문입니다:</p>
<pre><code class="language-text">note: maybe move this module `network` to its own directory via
`network/mod.rs`
</code></pre>
<p>전에 사용했던 똑같은 파일 이름 쓰기 패턴을 계속해서 따르는 대신, 아래 노트에서 제안하는 것을 해볼
수 있습니다:</p>
<ol>
<li>부모 모듈의 이름에 해당하는, <em>network</em>라는 이름의 새로운 <em>디렉토리</em>를 만드세요.</li>
<li><em>src/network.rs</em> 파일을 이 새로운 <em>network</em> 디렉토리 안으로 옮기고, 파일 이름을
<em>src/network/mod.rs</em>로 고치세요.</li>
<li>서브모듈 파일 <em>src/server.rs</em>를 <em>network</em> 디렉토리 안으로 옮기세요.</li>
</ol>
<p>위의 단계들을 실행하기 위한 명령들입니다:</p>
<pre><code class="language-text">$ mkdir src/network
$ mv src/network.rs src/network/mod.rs
$ mv src/server.rs src/network
</code></pre>
<p>이제 <code>cargo build</code>를 다시 실행하면, 컴파일은 작동할 것입니다 (여전히 경고는 좀 있지만요). 우리의
모듈 레이아웃은 여전히 아래와 같이 되는데, 이는 Listing 7-3의 <em>src/lib.rs</em> 내의 코드에서 만든 것과
정확하게 동일합니다:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<p>이에 대응하는 파일 레이아웃는 아래와 같이 생겼습니다:</p>
<pre><code class="language-text">├── src
│   ├── client.rs
│   ├── lib.rs
│   └── network
│       ├── mod.rs
│       └── server.rs
</code></pre>
<p>그러니까 우리가 <code>network::server</code> 모듈을 추출하고자 할 때, 왜 <code>network::server</code> 모듈을
<em>src/server.rs</em>로 추출하는 대신, <em>src/network.rs</em> 파일에 <em>src/network/mod.rs</em>로 옮기고
<code>network::server</code> 코드를 <em>network</em> 디렉토리 안에 있는 <em>src/network/server.rs</em>에 넣었을까요?
그 이유는 <em>src</em> 디렉토리 안에 <em>server.rs</em> 파일이 있으면, 러스트는 <code>server</code>가 <code>network</code>의
서브모듈이라고 인식할 수 없기 때문입니다. 러스트가 동작하는 방식을 명확하게 알기 위해서, 아래와 같은 모듈
계층 구조를 가진, <em>src/lib.rs</em> 내에 모든 정의가 다 들어있는 다른 예제를 봅시다:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── client
</code></pre>
<p>이 예제에는 또다시 <code>client</code>, <code>network</code>, 그리고 <code>network::client</code>라는 세 개의 모듈이 있습니다.
모듈을 파일로 추출하기 위해 앞서 했던 단계를 따르면, <code>client</code> 모듈을 위한 <em>src/client.rs</em>을
만들게 될 것입니다. <code>network</code> 모듈을 위해서는 <em>src/network.rs</em> 파일을 만들게 될 것입니다.
하지만 <code>network::client</code> 모듈을 <em>src/client.rs</em>로 추출하는 것은 불가능한데, 그 이유는
최상위 층에 <code>client</code> 모듈이 이미 있기 때문이죠! 만일 <code>client</code>와 <code>network::client</code> 모듈
<em>둘다</em> <em>src/client.rs</em> 파일에 집어넣는다면, 러스트는 이 코드가 <code>client</code>를 위한 것인지,
아니면 <code>network::client</code>를 위한 것인지 알아낼 방법이 없을 것입니다.</p>
<p>따라서, <code>network</code> 모듈의 <code>network::client</code> 서브모듈을 위한 파일을 추출하기 위해서는
<em>src/network.rs</em> 파일 대신 <code>network</code> 모듈을 위한 디렉토리를 만들 필요가 있습니다. <code>network</code>
모듈 내의 코드는 그후 <em>src/network/mod.rs</em> 파일로 가고, 서브모듈 <code>network::client</code>은
<em>src/network/client.rs</em> 파일을 갖게할 수 있습니다. 이제 최상위 층의 <em>src/client.rs</em>는
모호하지 않게 <code>client</code> 모듈이 소유한 코드가 됩니다.</p>
<a class="header" href="print.html#모듈-파일-시스템의-규칙" id="모듈-파일-시스템의-규칙"><h3>모듈 파일 시스템의 규칙</h3></a>
<p>파일에 관한 모듈의 규칙을 정리해봅시다:</p>
<ul>
<li>만일 <code>foo</code>라는 이름의 모듈이 서브모듈을 가지고 있지 않다면, <em>foo.rs</em>라는 이름의 파일 내에
<code>foo</code>에 대한 선언을 집어넣어야 합니다.</li>
<li>만일 <code>foo</code>가 서브모듈을 가지고 있다면, <em>foo/mod.rs</em>라는 이름의 파일에 <code>foo</code>에 대한 선언을
집어넣어야 합니다.</li>
</ul>
<p>이 규칙들은 재귀적으로 적용되므로, <code>foo</code>라는 이름의 모듈이 <code>bar</code>라는 이름의 서브모듈을 갖고 있고
`bar는 서브모듈이 없다면, 여러분의 <em>src</em> 디렉토리 안에는 아래와 같은 파일들이 있어야 합니다:</p>
<pre><code class="language-text">├── foo
│   ├── bar.rs (contains the declarations in `foo::bar`)
│   └── mod.rs (contains the declarations in `foo`, including `mod bar`)
</code></pre>
<p>이 모듈들은 부모 모듈의 파일에 <code>mod</code> 키워드를 사용하여 선언되어 있어야 합니다.</p>
<p>다음으로, <code>pub</code> 키워드에 대해 알아보고 앞의 그 경고들을 없애봅시다!</p>
<a class="header" href="print.html#pub으로-가시성visibility-제어하기" id="pub으로-가시성visibility-제어하기"><h2><code>pub</code>으로 가시성(visibility) 제어하기</h2></a>
<p>우리는 <code>network</code>와 <code>network::server</code> 코드를 각각 <em>src/network/mod.rs</em>와
<em>src/network/server.rs</em> 파일 안으로 이동시켜서 Listing 7-4에 나온 에러 메세지를
해결했습니다. 이 지점에서 <code>cargo build</code>로 프로젝트를 빌드할 수 있긴 했지만,
사용하지 않고 있는 <code>client::connect</code>, <code>network::connect</code>, 그리고
<code>network::server::connect</code> 함수에 대한 경고 메세지를 보게 됩니다:</p>
<pre><code class="language-text">warning: function is never used: `connect`, #[warn(dead_code)] on by default
src/client.rs:1:1
  |
1 | fn connect() {
  | ^

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/network/mod.rs:1:1
  |
1 | fn connect() {
  | ^

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/network/server.rs:1:1
  |
1 | fn connect() {
  | ^
</code></pre>
<p>그럼 이런 경고들은 왜 나오는 걸까요? 결국, 우리는 우리 자신의 프로젝트 내에서
사용할 필요가 있는 것이 아닌, <em>사용자</em>가 사용할 수 있도록 만들어진 함수들의
라이브러리를 만드는 중이므로, 이런 <code>connect</code> 함수 등이 사용되지 않는 것은
큰 문제가 아닙니다. 이 함수들을 만든 의도는 함수들이 우리의 지금 이 프로젝트가
아닌 또다른 프로젝트에 사용될 것이란 점입니다.</p>
<p>이 프로그램이 이러한 경고들을 들먹이는 이유를 이해하기 위해, <code>connect</code> 라이브러리
를 다른 프로젝트에서 사용하기를 시도해 봅시다. 이를 위해서, 아래의 코드를 담은
<em>src/main.rs</em> 파일을 만듦으로서 같은 디렉토리에 라이브러리 크레이트와 마찬가지로
바이너리 크레이트를 만들겠습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate communicator;

fn main() {
    communicator::client::connect();
}
</code></pre>
<p><code>communicator</code> 라이브러리 크레이트를 가져오기 위해 <code>extern crate</code> 명령어를
사용합니다. 우리의 패키지는 이제 <em>두 개의</em> 크레이트를 담고 있습니다. 카고는
<em>src/main.rs</em>를 바이너리 크레이트의 루트 파일로 취급하는데, 이 바이너리 크레이트는
<em>src/lib.rs</em>가 루트 파일인 이미 있던 라이브러리 크레이트는 별개입니다. 이러한 패턴은
실행 가능한 프로젝트에서 꽤 흔합니다: 대부분의 기능은 라이브러리 크레이트 안에 있고,
바이너리 크레이트는 이 라이브러리 크레이트를 이용합니다. 결과적으로, 다른 프로그램 또한
그 라이브러리 크레이트를 이용할 수 있고, 이는 멋지게 근심을 덜어줍니다.</p>
<p>From the point of view of a crate outside the <code>communicator</code> library looking
in, all the modules we’ve been creating are within a module that has the same
name as the crate, <code>communicator</code>. We call the top-level module of a crate the
<em>root module</em>.
<code>communicator</code> 라이브러리 밖의 크레이트가 안을 들여다 보는 시점에서, 우리가 만들어왔던
모든 모듈들은 <code>communicator</code>라는 이름을 갖는 모듈 내에 있습니다. 크레이트의 최상위
모듈을 <em>루트 모듈 (root module)</em> 이라 부릅니다.</p>
<p>또한. 비록 우리의 프로젝트의 서브모듈 내에서 외부 크레이트를 이용하고 있을지라도,
<code>extern create</code>이 루트 모듈에 와 있어야 한다는 점(즉 <em>src/main.rs</em> 혹은
<em>src/lib.rs</em>)을 기억하세요. 그러면 서브모듈 안에서 마치 최상위 모듈의 아이템을 참조하듯
외부 크레이트로부터 아이템들을 참조할 수 있습니다.</p>
<p>현시점에서 우리의 바이너리 크레이트는 고작 라이브러리의 <code>client</code> 모듈로부터 <code>connect</code>
함수를 호출할 뿐입니다. 하지만 <code>cargo build</code>을 실행하면 경고들 이후에 에러를 표시할
것입니다:</p>
<pre><code class="language-text">error: module `client` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>아하! 이 에러는 <code>client</code> 모듈이 비공개(private) 임을 알려주고 있는데, 이는 그 경고들의
요점입니다. 또한 러스트의 내용 중에서 <em>공개(public)</em> 그리고 <em>비공개(private)</em> 에 대한
개념에 대해 알아보게 될 첫번째 시간입니다. 러스트의 모든 코드의 기본 상태는 비공개입니다:
즉, 다른 사람은 이 코드를 사용할 수 없습니다. 만일 여러분의 프로그램 내에서 비공개 함수를
이용하지 않는다면, 여러분의 프로그램이 그 함수를 이용할 수 있는 유일한 곳이기 때문에,
러스트는 그 함수가 사용된 적이 없다며 경고해줄 것입니다.</p>
<p><code>client::connect</code>와 같은 함수를 공개로 지정한 뒤에는 우리의 바이너리 크레이트 상에서
이 함수를 호출하는 것이 가능해질 뿐만 아니라, 그 함수가 사용된 적이 없다는 경고 또한
사라질 것입니다. 함수를 공개로 표시하는 것은 러스트로 하여금 그 함수가 우리 프로그램
외부의 코드에 의해 사용될 것이라는 점을 알게끔 해줍니다. 러스트는 이제부터 가능하게
된 이론적인 외부 사용에 대해 이 함수가 “사용되었다”라고 간주합니다. 따라서, 어떤 것이
공개로 표시될 때, 러스트는 그것이 우리 프로그램 내에서 이용되는 것을 요구하지
않으며 해당 아이템이 미사용에 대한 경고를 멈출 것입니다.</p>
<a class="header" href="print.html#함수를-공개로-만들기" id="함수를-공개로-만들기"><h3>함수를 공개로 만들기</h3></a>
<p>러스트에게 어떤 것을 공개하도록 말하기 위해서는, 공개하길 원하는 아이템의 선언 시작
부분에 <code>pub</code> 키워드를 추가합니다. 지금은 <code>client::connect</code>가 사용된 적 없음을 알리는
경고와 바이너리 크레이트에서 나온 <code>module `client` is private</code> 에러를 제거하는데
집중하겠습니다. 아래와 같이 <em>src/lib.rs</em>을 수정하여 <code>client</code> 모듈을 공개로 만드세요:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

mod network;
</code></pre>
<p><code>pub</code> 키워드는 <code>mod</code> 바로 전에 위치합니다. 다시 빌드를 시도해봅시다:</p>
<pre><code class="language-text">error: function `connect` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>만세! 다른 에러가 나왔습니다! 네, 다른 에러 메세지라는건 축하할만한 이유죠. 새로운
에러는 <code>function `connect` is private</code>라고 하고 있으므로, <em>src/client.rs</em>를
수정해서 <code>client::connect</code>도 공개로 만듭시다:</p>
<p><span class="filename">Filename: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn connect() {
}
#}</code></pre></pre>
<p>이제 <code>cargo build</code>를 다시 실행하면:</p>
<pre><code class="language-text">warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/network/mod.rs:1:1
  |
1 | fn connect() {
  | ^

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/network/server.rs:1:1
  |
1 | fn connect() {
  | ^
</code></pre>
<p>코드가 컴파일되었고, <code>client::connect</code>가 사용된 적 없다는 것에 대한 경고도 사라집니다!</p>
<p>미사용 코드 경고가 항상 여러분의 코드에 있는 아이템이 공개로 만들
필요가 있음을 나타내는 것은 아닙니다: 이 함수들이 여러분의 공개 API의 일부분으로서
들어가길 원하지 <em>않는다면</em>, 미사용 코드 경고는 여러분에게 해당 코드가 더이상 필요
없고 안전하게 지울 수 있음을 알려줄 수 있습니다. 또한 이 경고는 여러분의 라이브러리
내에서 해당 함수가 호출된 모든 곳을 실수로 지웠을 경우 발생할 수 있는 버그를 알려줄
수도 있습니다.</p>
<p>하지만 지금의 경우, 우리는 다른 두 함수들이 우리 크레이트의 공개 API의 일부분이
되길 원하고 있으므로, 이들에게 <code>pub</code>를 표시해줘서 남은 경고들을 제거합시다.
<em>src/network/mod.rs</em>를 아래와 같이 수정하세요:</p>
<p><span class="filename">Filename: src/network/mod.rs</span></p>
<pre><code class="language-rust ignore">pub fn connect() {
}

mod server;
</code></pre>
<p>그리고 컴파일하면:</p>
<pre><code class="language-text">warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/network/mod.rs:1:1
  |
1 | pub fn connect() {
  | ^

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/network/server.rs:1:1
  |
1 | fn connect() {
  | ^
</code></pre>
<p>흠, <code>network::connect</code>가 <code>pub</code>으로 설정되어 있음에도, 여전히 미사용 함수 경고가
나옵니다. 그 이유는 함수가 모듈 내에서 공개지만, 함수가 상주해 있는 <code>network</code> 모듈은
공개가 아니기 때문입니다. 이번에는 모듈의 안쪽에서 작업하고 있지만,
<code>client::connect</code>에서는 바깥쪽에서 작업을 했었죠. <em>src/lib.rs</em>을 수정하여 <code>network</code>가
공개가 되도록 할 필요가 있습니다. 이렇게요:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;
</code></pre>
<p>이제 컴파일하면, 그 경고는 사라집니다:</p>
<pre><code class="language-text">warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/network/server.rs:1:1
  |
1 | fn connect() {
  | ^
</code></pre>
<p>경고 딱 하나 남았네요! 여러분이 직접 고쳐보세요!</p>
<a class="header" href="print.html#비공개-규칙privacy-rules" id="비공개-규칙privacy-rules"><h3>비공개 규칙(Privacy Rules)</h3></a>
<p>종합해보면, 아이템 가시성에 관한 규칙은 다음과 같습니다:</p>
<ol>
<li>만일 어떤 아이템이 공개라면, 이는 부모 모듈의 어디에서건 접근 가능합니다.</li>
<li>만일 어떤 아이템이 비공개라면, 이는 현재 모듈 및 자식 모듈에서만 접근 가능합니다.</li>
</ol>
<a class="header" href="print.html#비공개-예제privacy-examples" id="비공개-예제privacy-examples"><h3>비공개 예제(Privacy Examples)</h3></a>
<p>연습을 위해 몇 가지 비공개에 관한 예제를 봅시다. 새로운 라이브러리 프로젝트를 만들고
이 새로운 프로젝트의 <em>src/lib.rs</em>에 Listing 7-5와 같이 코드를 넣으세요:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod outermost {
    pub fn middle_function() {}

    fn middle_secret_function() {}

    mod inside {
        pub fn inner_function() {}

        fn secret_function() {}
    }
}

fn try_me() {
    outermost::middle_function();
    outermost::middle_secret_function();
    outermost::inside::inner_function();
    outermost::inside::secret_function();
}
</code></pre>
<p><span class="caption">Listing 7-5: 비공개 및 공개 함수 예제. 몇 가지는 잘못되었음.</span></p>
<p>이 코드를 컴파일하기 전에, <code>try_me</code> 함수의 어떤 라인이 에러를 발생시킬지 추측해보세요.
그리고나서 컴파일을 하여 여러분이 맞았는지 확인하고, 에러에 대한 논의를 위해 계속
읽어주세요!</p>
<a class="header" href="print.html#에러-보기" id="에러-보기"><h4>에러 보기</h4></a>
<p><code>try_me</code> 함수는 우리 프로젝트의 루트 모듈 내에 있습니다. <code>outermost</code> 모듈은
비공개지만, 두 번째 비공개 규칙은 <code>try_me</code>함수가 <code>outermost</code> 모듈에 접근하는 것이
허용됨을 알려주는데, 이는 <code>outermost</code>가 <code>try_me</code> 함수와 마찬가지로 현재의 (루트)
모듈 내에 있기 때문입니다.</p>
<p><code>middle_function</code>이 공개이므로 <code>outermost::middle_function</code> 호출은 작동할 것이며,
<code>try_me</code>는 <code>middle_function</code>의 부모 모듈인 <code>outermost</code>를 통해 <code>middle_function</code>에
접근하고 있습니다. 이 모듈에 접근 가능하하는 것은 이전 문단에서 알아냈죠.</p>
<p><code>outermost::middle_secret_function</code> 호출은 컴파일 에러를 일으킬 것입니다.
<code>middle_secret_function</code>는 비공개이므로, 두번째 규칙이 적용됩니다. 루트 모듈은
<code>middle_secret_function</code>의 현재 모듈도 아니고 (<code>outermost</code>가 현재 모듈입니다),
<code>middle_secret_function</code>의 현재 모듈의 자식 모듈도 아닙니다.</p>
<p><code>inside</code> 모듈은 비공개고 자식 모듈이 없으므로, 이것의 현재 모듈인 <code>outermost</code>에 의해서만
접근될 수 있습니다. 이는 즉 <code>try_me</code> 함수는 <code>outermost::inside::inner_function</code>나
<code>outermost::inside::secret_function</code>를 호출할 수 없음을 의미합니다.</p>
<a class="header" href="print.html#에러-고치기" id="에러-고치기"><h4>에러 고치기</h4></a>
<p>여기 이 에러들을 고치기 위해 코드를 수정하는것에 관한 몇 가지 제안이 있습니다.
각각을 시도해보기 전에, 이 시도가 에러를 고칠지 그렇지 않을지 추측해 보고,
컴파일을 해서 여러분이 맞췄는지 그렇지 않은지 확인하고, 왜 그랬는지 이해하기 위해
비공개 규칙을 이용해보세요.</p>
<ul>
<li><code>inside</code> 모듈이 공개라면 어떨까요?</li>
<li><code>outermost</code>가 공개고 <code>inside</code>가 비공개면 어떨까요?</li>
<li><code>inner_function</code>의 내부에서 <code>::outermost::middle_secret_function()</code>을
호출한다면 어떨까요? (시작 부분의 콜론 두개는 루트 모듈로부터 시작하여 모듈을 참조하고
싶음을 나타냅니다)</li>
</ul>
<p>자유롭게 더 많은 실험을 설계하고 시도해 보세요!</p>
<p>다음으로, <code>use</code> 키워드를 사용하여 아이템을 스코프 내로 가져오는 것에 대해 이야기해
봅시다.</p>
<a class="header" href="print.html#이름-가져오기-importing-names" id="이름-가져오기-importing-names"><h2>이름 가져오기 (Importing Names)</h2></a>
<p>우리는 Listing 7-6에서 보시는 것과 같이 <code>nested_modules</code> 함수를 호출하는 것처럼,
모듈 이름을 호출 구문의 일부분으로 사용하여 해당 모듈 내에 정의된 함수를 호출하는
방법을 다룬바 있습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

fn main() {
    a::series::of::nested_modules();
}
</code></pre></pre>
<p><span class="caption">Listing 7-6: 함수에 인접한 모듈 경로를 완전히 특정한 함수
호출하기</span></p>
<p>보시다시피 완전하게 경로를 지정한 이름을 참조하는 것은 너무 길어질 수 있습니다.
다행히도 러스트는 이러한 호출을 더 간결하게 만들어주는 키워드를 가지고 있습니다.</p>
<a class="header" href="print.html#use를-이용한-간결한-가져오기" id="use를-이용한-간결한-가져오기"><h3><code>use</code>를 이용한 간결한 가져오기</h3></a>
<p>러스트의 <code>use</code> 키워드는 여러분이 스코프 내에서 호출하고 싶어하는 함수의 모듈을
가져옴으로써 긴 함수 호출을 줄여줍니다. <code>a::series::of</code> 모듈을 바이너리 크레이트의
루트 스코프로 가져온 예제입니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

use a::series::of;

fn main() {
    of::nested_modules();
}
</code></pre></pre>
<p><code>use a::series::of;</code> 줄은 <code>of</code> 모듈을 참조하고 싶은 곳마다 <code>a::series::of</code> 전부를
사용하기 보다는 <code>of</code>를 사용할 수 있다는 뜻입니다.</p>
<p><code>use</code> 키워드는 우리가 명시한 것만 스코프 내로 가져옵니다: 즉 모듈의 자식들을
스코프 내로 가져오지는 않습니다. 이는 <code>nested_modules</code> 함수를 호출하고자 할 떄
여전히 <code>of::nested_modules</code>를 사용해야 하는 이유입니다.</p>
<p>다음과 같이 <code>use</code> 구문 안에서 모듈 대신 함수를 명시하여 스코프 내에서 함수를 가져올
수도 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

use a::series::of::nested_modules;

fn main() {
    nested_modules();
}
</code></pre></pre>
<p>이렇게 하면 모든 모듈을 안 써주고 함수를 직접 참조하도록 해줍니다.</p>
<p>열거형 또한 모듈과 비슷한 일종의 이름공간을 형성하고 있기 때문에, 열거형의 variant
또한 <code>use</code>를 이용하여 가져올 수 있습니다. 어떠한 <code>use</code> 구문이건 하나의 이름공간으로부터
여러 개의 아이템을 가져오려 한다면, 여러분은 아래와 같이 중괄호와 쉼표를 구문의 마지막
위치에 사용하여 이 아이템들을 나열할 수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::{Red, Yellow};

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = TrafficLight::Green;
}
</code></pre></pre>
<p><code>Green</code> variant에 대해서는 여전히 <code>TrafficLight</code> 이름공간을 명시하고 있는데,
이는 <code>use</code> 구문 내에 <code>Green</code>를 포함하지 않았기 때문입니다.</p>
<a class="header" href="print.html#를-이용한-모두glob-가져오기" id="를-이용한-모두glob-가져오기"><h3><code>*</code>를 이용한 모두(glob) 가져오기</h3></a>
<p>이름공간 내의 모든 아이템을 가져오기 위해서는 <code>*</code> 문법을 이용할 수 있습니다. 예를 들면:</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::*;

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = Green;
}
</code></pre></pre>
<p><code>*</code>는 <em>글롭(glob)</em> 이라고 부르며, 이는 이름공간 내에 공개된 모든 아이템을 가져올
것입니다. 여러분은 글롭을 아껴가며 써야 합니다: 글롭은 편리하지만, 여러분이 예상한
것보다 더 많은 아이템을 끌어와서 이름 간의 충돌(naming conflict)의 원인이 될수도
있습니다.</p>
<a class="header" href="print.html#super를-사용하여-부모-모듈에-접근하기" id="super를-사용하여-부모-모듈에-접근하기"><h3><code>super</code>를 사용하여 부모 모듈에 접근하기</h3></a>
<p>이 장의 시작 부분에서 보셨듯이, 여러분이 라이브러리 크레이트를 만들때, 카고는
여러분들을 위해 <code>tests</code> 모듈을 만들어줍니다. 지금부터 이에 대한 구체적인 부분들을
봅시다. 여러분의 <code>communicator</code> 프로젝트 내에 있는 <em>src/lib.rs</em>을 여세요:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
    }
}
</code></pre>
<p>11장에서 테스트에 관한 더 많은걸 설명하고 있습니다만, 이 예제는 지금도 이해가
되시리라 봅니다: <code>tests</code>라는 이름의 모듈이 우리의 다른 모듈들 옆에 있고,
<code>it_works</code>라는 이름의 함수 하나를 담고 있지요. 좀 특별한 주석(annotation)이 있지만,
<code>tests</code> 모듈을 그냥 또다른 모듈일 뿐입니다! 따라서 우리의 모듈 계층 구조는 아래와
같이 생겼습니다:</p>
<pre><code class="language-text">communicator
 ├── client
 ├── network
 |   └── client
 └── tests
</code></pre>
<p>테스트는 우리 라이브러리 내에 있는 코드를 연습하기 위한 것이므로, 현재로서는 어떠한
기능도 확인할 게 없긴 하지만, <code>it_works</code> 함수 안에서 우리의 <code>client::connect</code> 함수를
호출해 봅시다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<p><code>cargo test</code> 명령을 써서 테스트를 실행하면:</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
error[E0433]: failed to resolve. Use of undeclared type or module `client`
 --&gt; src/lib.rs:9:9
  |
9 |         client::connect();
  |         ^^^^^^^^^^^^^^^ Use of undeclared type or module `client`
</code></pre>
<p>컴파일이 실패했습니다, 하지만 대체 왜일까요? 우리는 <em>src/main.rs</em>에서 했었던 것과
마찬가지로 함수 앞에 <code>communicator::</code>를 붙일 필요가 없는데, 왜냐하면 이 코드가
분명히 <code>communicator</code> 라이브러리 크레이트 안에 있기 때문입니다. 원인은 경로가
항상 현재 모듈을 기준으로 상대적인데, 여기는 <code>test</code>이기 때문입니다. 딱 하나의
예외는 <code>use</code> 구문인데, 이는 기본적으로 크레이트 루트에 대한 상대적인 경로로
인식됩니다. 우리의 <code>tests</code> 모듈은 이 스코프 내에서 <code>client</code> 모듈이 필요합니다!</p>
<p>그러면 어떻게 모듈 계층 구조 내에서 한 모듈 위로 거슬러 올라가 <code>tests</code> 모듈 안에서
<code>client::connect</code> 함수를 호출할 수 있을까요? 아래와 같이 앞에 콜론 두개를 사용하여
러스트에게 우리가 루트부터 시작하여 전체 경로를 나열하겠다고 알려주는 방법이 있습니다:</p>
<pre><code class="language-rust ignore">::client::connect();
</code></pre>
<p>혹은, 아래와 같이 <code>super</code>를 사용하여 계층 구조 상에서 현재 모듈로부터 한 모듈 거슬러
올라갈 수도 있습니다:</p>
<pre><code class="language-rust ignore">super::client::connect();
</code></pre>
<p>이 두 가지 옵션은 이번 예제에서는 차이가 없는 것처럼 보이지만, 여러분의 모듈 계층
구조가 깊어진다면, 매번 루트에서부터 경로를 시작하는 것은 여러분의 코드를 길게
만들 것입니다. 그런 경우에는 <code>super</code>를 이용하여 현재 모듈에서 형제 모듈을 가져오는
것이 좋은 지름길이 됩니다. 여기에 더해서, 만약 여러분이 여러 군데에 루트로부터
시작되는 경로를 명시한 뒤에 서브트리를 다른 곳으로 옮기는 식으로 여러분의 모듈을
재정리한다면, 여러분은 여러 군데의 경로를 갱신하도록 요구받는 처지가 될 것이고,
이는 지루한 작업이 될 것입니다.</p>
<p>각각의 테스트에 <code>super::</code>를 타이핑해야 하는 것이 짜증날수 있겠지만, 여러분은
이미 여기에 대한 해답이 될 도구를 보셨습니다: <code>use</code> 말이죠! <code>super::</code>의 기능은
<code>use</code>에 제공한 경로를 변경시켜서 이제 루트 모듈 대신 부모 모듈에 상대적인 경로가
되게 해줍니다.</p>
<p>이러한 이유로, 특히 <code>tests</code> 모듈 내에서는 보통 <code>use super::something</code>이 가장 좋은
해결책이 됩니다. 따라서 이제 우리의 테스트는 이렇게 됩니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::client;

    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<p><code>cargo test</code>를 다시 실행시키면, 테스트가 통과되고 테스트 결과 출력의 첫번째 부분이
아래와 같이 나타날 것입니다:</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
     Running target/debug/communicator-92007ddb5330fa5a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<a class="header" href="print.html#정리-1" id="정리-1"><h2>정리</h2></a>
<p>이제 여러분은 코드를 조직화하기 위한 몇가지 새로운 기술을 알게 되었습니다! 관련된
기능들을 함께 묶여주는 이 기술들을 사용하고, 파일들이 너무 길어지지 않게 하고,
여러분의 라이브러리 사용자들에게 깔끔한 공개 API를 제공해 보세요.</p>
<p>다음으로 여러분의 멋지고 깔끔한 코드에 사용할 수 있는 표준 라이브러리 내의 몇가지
컬렉션 데이터 구조를 보겠습니다!</p>
<a class="header" href="print.html#일반적인-컬렉션" id="일반적인-컬렉션"><h1>일반적인 컬렉션</h1></a>
<p>러스트의 표준 라이브러리에는 <em>컬렉션</em>이라 불리는 여러 개의 정말 유용한 데이터 구조들이 포함되어 있습니다.
대부분의 다른 데이터 타입들은 하나의 특정한 값을 나타내지만, 컬렉션은 다수의 값을 담을 수 있습니다.
내장된 배열(build-in array)와 튜플 타입과는 달리, 이 컬렉션들이 가리키고 있는 데이터들은 힙에
저장되는데, 이는 즉 데이터량이 컴파일 타임에 결정되지 않아도 되며 프로그램이 실행될 때 늘어나거나
줄어들 수 있다는 의미입니다. 각각의 컬렉션 종류는 서로 다른 용량과 비용을 가지고 있으며, 여러분의 상황에
따라 적절한 컬렉션을 선택하는 것은 시간이 지남에 따라 발전시켜야 할 기술입니다. 이번 장에서는 러스트
프로그램에서 굉장히 자주 사용되는 세 가지 컬렉션을 살펴보겠습니다:</p>
<ul>
<li><em>벡터(vector)</em> 는 여러 개의 값을 서로 붙어 있게 저장할 수 있도록 해줍니다.</li>
<li><em>스트링(string)</em> 은 문자(character)의 모음입니다. <code>String</code> 타입은 전에 봤지만, 여기서는
더 깊이 있게 이야기해 보겠습니다.</li>
<li><em>해쉬맵(hash map</em> 은 어떤 값을 특정한 키와 연관지어 주도록 해줍니다. 이는 <em>맵(map)</em> 이라
일컫는 좀더 일반적인 데이터 구조의 특정한 구현 형태입니다.</li>
</ul>
<p>표준 라이브러리가 제공해주는 다른 종류의 컬렉션에 대해 알고 싶으시면,
<a href="../../std/collections/index.html">the documentation</a>를 봐 주세요.</p>
<p>이제부터 어떻게 벡터, 스트링, 해쉬맵을 만들고 업데이트하는지 뿐만 아니라 어떤 것이 각각의 컬렉션을
특별하게 해주는지에 대해 논의해 보겠습니다.</p>
<a class="header" href="print.html#벡터" id="벡터"><h2>벡터</h2></a>
<p>우리가 보게될 첫번째 타입은 <em>벡터</em>라고도 알려진 <code>Vec&lt;T&gt;</code>입니다. 벡터는 모든 값을 메모리 상에 서로
이웃하게 넣어주는 하나의 데이터 구조 안에 여러 개의 값을 저장하도록 해줍니다. 텍터는 같은 타입의
값만을 저장할 수 있습니다. 이 컬렉션은 여러분이 파일 내의 텍스트의 라인들이라던가 장바구니의 아이템
가격들 같은 아이템 리스트를 저장하는 상황일 경우 유용합니다.</p>
<a class="header" href="print.html#새-벡터-만들기" id="새-벡터-만들기"><h3>새 벡터 만들기</h3></a>
<p>비어있는 새 벡터를 만들기 위해서는, <code>Vec::new</code> 함수를 호출해 줍니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;i32&gt; = Vec::new();
#}</code></pre></pre>
<p>여기에 타입 명시(type annotation)를 추가한 것을 주목하세요. 이 벡터에 어떠한 값도 집어넣지 않았기
때문에, 러스트는 우리가 저장하고자 하는 요소의 종류가 어떤 것인지 알지 못합니다. 이는 중요한 지점입니다.
벡터는 동질적(homogeneous)입니다: 여러 개의 값을 저장할 수는 있으나, 이 값들은 모두 동일한 타입이어야
합니다. 벡터는 제네릭(generic)을 이용해서 구현되어 있는데, 이는 10장에서 여러분이 만든 타입 내에
어떻게 사용하는지 다루게 될 것입니다. 지금 여러분이 알아둬야 할 것은 표준 라이브러리가 제공하는 <code>Vec</code>타입은
어떠한 종류의 값이라도 저장할 수 있고, 특정한 <code>Vec</code>은 특정한 타입의 값을 저장하며, 이 타입은 꺾쇠 괄호(&lt;&gt;)
안에 적는다는 것입니다. 우리는 러스트에게 <code>v</code> 안의 <code>Vec</code>가 <code>i32</code> 타입의 요소를 가질 것이고 알려주었습니다.</p>
<p>우리가 한번 값을 집어넣으면 러스트는 우리가 저장하고자 하는 값의 타입을 유추할 수 있으므로, 실제
코드에서 여러분이 이러한 타입 명시를 할 필요는 거의 없습니다. 초기값들을 갖고 있는 <code>Vec</code>을 생성하는
것이 더 일반적이며, 러스트는 편의를 위해 <code>vec!</code> 매크로를 제공합니다. 이 매크로는 우리가 준 값들을
저장하고 있는 새로운 <code>Vec</code>을 생성합니다. 아래 코드는 <code>1</code>, <code>2</code>, <code>3</code>을 저장하고 있는 새로운
<code>Vec&lt;i32&gt;</code>을 생성할 것입니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];
#}</code></pre></pre>
<p>초기 <code>i32</code> 값들을 제공했기 때문에, 러스트는 <code>v</code>가 `Vec<i32> 타입이라는 것을 유추할 수 있으며,
그래서 타입 명시는 필요치 않습니다. 다음으로 벡터를 어떻게 수정하는지를 봅시다.</p>
<a class="header" href="print.html#벡터-갱신하기" id="벡터-갱신하기"><h3>벡터 갱신하기</h3></a>
<p>벡터를 만들고 여기에 요소들을 추가하기 위해서, <code>push</code> 메소드를 사용할 수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
#}</code></pre></pre>
<p>3장에서 설명한 바와 같이, 어떤 변수에 대해 그 변수가 담고 있는 값이 변경될 수 있도록 하려면,
<code>mut</code> 키워드를 사용하여 해당 변수를 가변으로 만들어 줄 필요가 있습니다. 우리가 집어넣는 숫자는
모두 <code>i32</code> 타입이며, 러스트는 데이터로부터 이 타입을 추론하므로, 우리는 <code>Vec&lt;i32&gt;</code> 명시를
붙일 필요가 없습니다.</p>
<a class="header" href="print.html#벡터를-드롭하는-것은-벡터의-요소들을-드롭시킵니다" id="벡터를-드롭하는-것은-벡터의-요소들을-드롭시킵니다"><h3>벡터를 드롭하는 것은 벡터의 요소들을 드롭시킵니다</h3></a>
<p><code>struct</code>와 마찬가지로, 벡터도 스코프 밖으로 벗어났을 때 해제됩니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let v = vec![1, 2, 3, 4];

    // v를 가지고 뭔가 합니다

} // &lt;- v가 스코프 밖으로 벗어났고, 여기서 해제됩니다
#}</code></pre></pre>
<p>벡터가 드롭될 때 벡터의 내용물 또한 전부 드롭되는데, 이는 벡터가 가지고 있는 정수들이 모두 제거된다는
의미입니다. 이는 직관적인 것처럼 보일 수도 있겠지만, 벡터의 요소들에 대한 참조자를 만들기 시작하면 좀 더
복잡해 질 수 있습니다. 다음으로 이런 상황을 파해쳐 봅시다!</p>
<a class="header" href="print.html#벡터의-요소들-읽기" id="벡터의-요소들-읽기"><h3>벡터의 요소들 읽기</h3></a>
<p>지금까지 벡터를 만들고, 갱신하고, 없애는 방법에 대해 알아보았으니, 벡터의 내용물을 읽어들이는 방법을
알아보는 것이 다음 단계로 좋아보입니다. 벡터 내에 저장된 값을 참조하는 두 가지 방법이 있습니다.
예제에서는 특별히 더 명료하게 하기 위해 함수들이 반환하는 값의 타입을 명시했습니다.</p>
<p>이 예제는 인덱스 문법이나 <code>get</code> 메소드를 가지고 벡터의 값에 접근하는 두 방법 모두를 보여주고 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
let third: Option&lt;&amp;i32&gt; = v.get(2);
#}</code></pre></pre>
<p>여기서 몇 가지 기억해야 할 사항들이 있습니다. 먼저 인덱스값 <code>2</code>를 사용하면 세번째 값이 얻어집니다:
벡터는 0부터 시작하는 숫자로 인덱스됩니다. 두번째로, 세번째 요소를 얻기 위해 두 가지 다른 방법이
사용되었습니다: <code>&amp;</code>와 <code>[]</code>를 이용하여 참조자를 얻은 것과, <code>get</code> 함수에 인덱스를 파라미터로
넘겨서 <code>Option&lt;&amp;T&gt;</code>를 얻은 것입니다.</p>
<p>러스트가 벡터 요소를 참조하는 두가지 방법을 제공하는 이유는 여러분이 벡터가 가지고 있지 않은 인덱스값을
사용하고자 했을 때 프로그램이 어떻게 동작할 것인지 여러분이 선택할 수 있도록 하기 위해서입니다. 예를
들어, 아래와 같이 5개의 요소를 가지고 있는 벡터가 있고 100 인덱스에 있는 요소에 접근하려고 시도한
경우 프로그램은 어떻게 동작해야 할까요:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
#}</code></pre></pre>
<p>이 프로그램을 실행하면, 여러분은 첫번째 <code>[]</code> 방법을 이용한 경우를 찾을 것이고, 러스트는 존재하지
않는 요소를 참조할 경우 <code>panic!</code>을 발생시킵니다. 이 방법은 여러분의 프로그램이 벡터의 끝을
지난 요소에 접근하는 시도를 하면 프로그램이 죽게끔 하는 치명적 에러를 발생시키고 싶을 경우에
선호할만한 방법입니다.</p>
<p><code>get</code> 함수에 배열 범위를 벗어난 인덱스가 주어졌을 때는 패닉 없이 <code>None</code>이 반환됩니다. 이는
보통의 환경에서 벡터의 범위 밖에 있는 요소에 접근하는 것이 종종 발생할 수 있다면 사용할만 합니다.
여러분의 코드는 우리가 6장에서 본 것과 같이 <code>Some(&amp;element)</code> 혹은 <code>None</code>에 대해 다루는
로직을 갖추어야 합니다. 예를 들어 인덱스는 사람이 직접 번호를 입력하는 것으로 들어올 수도 있습니다.
만일 사용자가 잘못하여 너무 큰 숫자를 입력하여 여러분의 프로그램이 <code>None</code> 값을 받았을 경우,
여러분은 사용자에게 현재 <code>Vec</code>에 몇개의 아이템이 있으며 유효한 값을 입력할 또한번의 기회를 줄
수도 있습니다. 이런 편이 오타 때문에 프로그램이 죽는 것 보다는 더 사용자 친화적이겠죠!</p>
<a class="header" href="print.html#유효하지-않은-참조자" id="유효하지-않은-참조자"><h4>유효하지 않은 참조자</h4></a>
<p>프로그램이 유효한 참조자를 얻으면, 빌림 검사기(borrow checker)가 4장에서 다룬바 있는 소유권 및 빌림
규칙을 집행하여 이 참조자와 벡터의 내용물로부터 얻은 다른 참조자들이 계속 유효한지 확실히 해줍니다.
같은 스코프 내에서 가변 참조자와 불변 참조자를 가질 수 없다는 규칙을 상기하세요. 이 규칙은 아래 예제에서도
적용되는데, 이 예제에서는 벡터의 첫번째 요소에 대한 불변 참조자를 얻은 뒤 벡터의 끝에 요소를 추가하고자
했습니다:</p>
<pre><code class="language-rust ignore">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);
</code></pre>
<p>이 예제를 컴파일하면 아래와 같은 에러가 나옵니다:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as
immutable
  |
4 | let first = &amp;v[0];
  |              - immutable borrow occurs here
5 |
6 | v.push(6);
  | ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>이 코드는 동작을 해야만 할것처럼 보일 수도 있습니다: 왜 첫번째 요소에 대한 참조자가 벡터 끝에 대한
변경을 걱정해야 하죠? 이 코드가 허용되지 않는 이유는 벡터가 동작하는 방법 때문입니다. 새로운 요소를
벡터의 끝에 추가하는 것은 새로 메모리를 할당하여 예전 요소를 새 공간에 복사하는 일을 필요로 할 수 있는데,
이는 벡터가 모든 요소들을 붙여서 저장할 공간이 충분치 않는 환경에서 일어날 수 있습니다. 이러한 경우,
첫번째 요소에 대한 참조자는 할당이 해제된 메모리를 가리키게 될 것입니다. 빌림 규칙은 프로그램이
이러한 상황에 빠지지 않도록 해줍니다.</p>
<blockquote>
<p>노트: 이것과 관련된 더 많은 사항이 궁금하다면 노미콘을 보세요:
<em>https://doc.rust-lang.org/stable/nomicon/vec.html</em>.</p>
</blockquote>
<a class="header" href="print.html#열거형을-사용하여-여러-타입을-저장하기" id="열거형을-사용하여-여러-타입을-저장하기"><h3>열거형을 사용하여 여러 타입을 저장하기</h3></a>
<p>이 장의 시작 부분에서, 벡터는 모든 요소가 같은 타입인 값만 저장할 수 있다고 이야기했습니다. 이는
불편할 수 있습니다; 다른 타입의 값들에 대한 리스트를 저장할 필요가 있는 상황이 분명히 있지요. 운좋게도,
열거형의 variant는 모두 같은 열거형 타입 내에 정의가 되므로, 백터 내에 다른 타입의 값들을 저장할
필요가 있다면 열거형을 정의하여 사용할 수 있습니다!</p>
<p>예를 들어, 스프레드시트의 행으로부터 값들을 가져오고 싶은데, 여기서 어떤 열은 정수를, 어떤 열은 실수를,
어떤 열은 스트링을 갖고 있다고 해봅시다. 우리는 다른 타입의 값을 가지는 variant가 포함된 열거형을
정의할 수 있고, 모든 열거형 variant들은 해당 열거형 타입, 즉 같은 타입으로 취급될 것입니다. 따라서
우리는 궁극적으로 다른 타입을 담은 열거형 값에 대한 벡터를 생성할 수 있습니다.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];
#}</code></pre></pre>
<p><span class="caption">Listing 8-1: 열거형을 정의하여 벡터 내에 다른 타입의 데이터를 담을 수
있도록 하기</span></p>
<p>러스트가 컴파일 타임에 벡터 내에 저장될 타입이 어떤 것인지 정확히 알아야할 필요가 있는 이유는 각 요소를
저장하기 위해 얼만큼의 힙 메모리가 필요한지 알기 위함입니다. 이 방식의 부차적인 이점은 이 백터에 허용되는
타입에 대해 명시적일 수 있다는 점입니다. 만일 러스트가 어떠한 타입이든 담을수 있는 벡터를 허용한다면,
벡터 내의 각 요소마다 수행되는 연산에 대해 하나 혹은 그 이상의 타입이 에러를 야기할 수도 있습니다.
열거형과 <code>match</code>를 사용한다는 것은 6장에서 설명한 바와 같이 러스트가 컴파일 타임에 모든 가능한 경우에
대해 처리한다는 것을 보장해준다는 의미입니다.</p>
<p>만약 프로그램을 작성하고 있는 시점에서, 여러분의 프로그램이 런타임에 벡터에 저장하게 될 타입의 모든 경우를
알지 못한다면, 열거형을 이용한 방식은 사용할 수 없을 것입니다. 대신 트레잇 객체(trait object)를
이용할 수 있는데, 이건 17장에서 다루게 될 것입니다.</p>
<p>지금까지 벡터를 이용하는 가장 일반적인 방식 중 몇가지를 살펴보았는데, 표준 라이브러리의 <code>Vec</code>에 정의된
수많은 유용한 메소드들이 있으니 API 문서를 꼭 살펴봐 주시기 바랍니다. 예를 들면, <code>push</code>에 더해서
제일 마지막 요소를 반환하고 지워주는 <code>pop</code> 메소드도 있습니다. 다음 컬렉션 타입인 <code>String</code>으로
넘어갑시다!</p>
<a class="header" href="print.html#스트링" id="스트링"><h2>스트링</h2></a>
<p>4장에서 스트링에 관한 이야기를 많이 했습니다만, 지금은 좀더 깊이 살펴보겠습니다. 스트링은 새로운
러스트인들이 흔히 막히는 부분입니다. 이는 세 가지의 조합으로 인한 것입니다: 가능한 에러를 꼭 노출하도록
하는 러스트의 성향, 많은 프로그래머의 예상보다 더 복잡한 데이터 구조인 스트링, 그리고 UTF-8입니다.
다른 언어들을 사용하다 왔을 때 이들의 조합이 러스트의 스트링을 어려운 것처럼 보이게 합니다.</p>
<p>스트링이 컬렉션 장에 있는 이유는 스트링이 바이트의 컬렉션 및 이 바이트들을 텍스트로 통역할때 유용한
기능을 제공하는 몇몇 메소드로 구현되어 있기 때문입니다. 이번 절에서는 생성, 갱신, 값 읽기와 같은
모든 컬렉션 타입이 가지고 있는, <code>String</code>에서의 연산에 대해 이야기 해보겠습니다. 또한 <code>String</code>을
다른 컬렉션들과 다르게 만드는 부분, 즉 사람과 컴퓨터가 <code>String</code> 데이터를 통역하는 방식의 차이로
인해 생기는 <code>String</code> 인덱싱의 복잡함을 논의해보겠습니다.</p>
<a class="header" href="print.html#스트링이-뭔가요" id="스트링이-뭔가요"><h3>스트링이 뭔가요?</h3></a>
<p>이 부분을 깊이 파고들기 전에, 우리가 <em>스트링</em>이라는 용어로 정확히 무엇을 뜻하는 것인지 말해둘 필요가
있겠습니다. 러스트는 핵심 언어 기능 내부에 단 한가지 스트링 타입을 제공합니다: 바로 <code>str</code>인데,
이는 스트링 슬라이스며, 이것의 참조자 형태인 <code>&amp;str</code>을 많이 봤죠. 4장에서는 <em>스트링 슬라이스</em>에 대해
얘기했습니다: 이는 다른 어딘가에 저장된 UTF-8로 인코딩된 스트링 데이터의 참조자입니다. 예를 들어,
스트링 리터럴은 프로그램의 바이너리 출력물 내에 저장되어 있으며, 그러므로 스트링 슬라이스입니다.</p>
<p><code>String</code>이라고 부르는 타입은 핵심 언어 기능 내에 구현된 것이 아니고 러스트의 표준 라이브러리를
통해 제공되며, 커질 수 있고, 가변적이며, 소유권을 갖고 있고, UTF-8로 인코딩된 스트링 타입입니다.
러스트인들이 “스트링”에 대해 이야기할 때, 그들은 보통 <code>String</code>과 스트링 슬라이스 <code>&amp;str</code> 타입
둘 모두를 이야기한 것이지, 이들 중 하나를 뜻한 것은 아닙니다. 이번 절은 대부분 <code>String</code>에 관한
것이지만, 두 타입 모두 러스트 표준 라이브러리에서 매우 많이 사용됩니다. <code>String</code>과 스트링 슬라이스
모두 UTF-8로 인코딩되어 있습니다.</p>
<p>또한 러스트 표준 라이브러리는 <code>OsString</code>, <code>OsStr</code>, <code>CString</code>, 그리고 <code>CStr</code>과 같은 몇가지
다른 스트링 타입도 제공합니다. 심지어 어떤 라이브러리 크레이트들은 스트링 데이터를 저장하기 위해
더 많은 옵션을 제공할지도 모릅니다. <code>*String</code>/<code>*Str</code>이라는 작명과 유사하게, 이들은 종종 소유권이
있는 타입과 이를 빌린 변형 타입을 제공하는데, 이는 <code>String</code>/<code>&amp;str</code>과 비슷합니다. 이러한 스트링
타입들은, 예를 들면 다른 종류의 인코딩을 저장하거나 다른 방식으로 메모리에 저장될 수도 있습니다.
여기서는 이러한 다른 스트링 타입은 다루지 않겠습니다; 이것들을 어떻게 쓰고 어떤 경우에 적합한지에
애해 알고 싶다면 각각의 API 문서를 확인하시기 바랍니다.</p>
<a class="header" href="print.html#새로운-스트링-생성하기" id="새로운-스트링-생성하기"><h3>새로운 스트링 생성하기</h3></a>
<p><code>Vec</code>에서 쓸 수 있는 많은 연산들이 <code>String</code>에서도 마찬가지로 똑같이 쓰일 수 있는데, <code>new</code> 함수를
이용하여 스트링을 생성하는 것으로 아래와 같이 시작해봅시다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::new();
#}</code></pre></pre>
<p>이는 우리가 어떤 데이터를 담아둘 수 있는 <code>s</code>라는 빈 스트링을 만들어 줍니다.</p>
<p>종종 우리는 스트링에 담아두고 시작할 초기값을 가지고 있을 것입니다. 그런 경우, <code>to_string</code> 메소드를
이용하는데, 이는 <code>Display</code> 트레잇이 구현된 어떤 타입이든 사용 가능하며, 스트링 리터럴도 이 트레잇을
구현하고 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let data = &quot;initial contents&quot;;

let s = data.to_string();

// the method also works on a literal directly:
let s = &quot;initial contents&quot;.to_string();
#}</code></pre></pre>
<p>이는 <code>initial contents</code>를 담고 있는 스트링을 생성합니다.</p>
<p>또한 스트링 리터럴로부터 <code>String</code>을 생성하기 위해서 <code>String::from</code> 함수를 이용할 수도 있습니다.
이는 <code>to_string</code>을 사용하는 것과 동일합니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;initial contents&quot;);
#}</code></pre></pre>
<p>스트링이 너무나 많은 것들에 사용되기 때문에, 스트링을 위해 사용될 수 있는 다양한 제네릭 API들이 있으며,
옵션들도 여러가지입니다. 몇몇은 쓸모없는 것처럼 느껴질 수도 있지만, 다 사용할 곳이 있습니다! 지금의 경우,
<code>String::from</code>과 <code>.to_string</code>은 정확히 똑같은 일을 하며, 따라서 어떤 것을 사용하는가는
여러분의 스타일에 따라 달린 문제입니다.</p>
<p>스트링이 UTF-8로 인코딩되었음을 기억하세요. 즉, 우리는 인코딩된 어떤 데이터라도 포함시킬 수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;السلام عليكم&quot;;
let hello = &quot;Dobrý den&quot;;
let hello = &quot;Hello&quot;;
let hello = &quot;שָׁלוֹם&quot;;
let hello = &quot;नमस्ते&quot;;
let hello = &quot;こんにちは&quot;;
let hello = &quot;안녕하세요&quot;;
let hello = &quot;你好&quot;;
let hello = &quot;Olá&quot;;
let hello = &quot;Здравствуйте&quot;;
let hello = &quot;Hola&quot;;
#}</code></pre></pre>
<a class="header" href="print.html#스트링-갱신하기" id="스트링-갱신하기"><h3>스트링 갱신하기</h3></a>
<p><code>String</code>은 크기가 커질 수 있으며 이것이 담고 있는 내용물은 <code>Vec</code>의 내용물과 마찬가지로 더 많은
데이터를 집어넣음으로써 변경될 수 있습니다. 추가적으로, 편의를 위해 <code>String</code>은 <code>+</code> 연산자에
접합(concatenation) 연산을 구현하였습니다.</p>
<a class="header" href="print.html#푸시를-이용하여-스트링-추가하기" id="푸시를-이용하여-스트링-추가하기"><h4>푸시를 이용하여 스트링 추가하기</h4></a>
<p>스트링 슬라이스를 추가하기 위해 <code>push_str</code> 메소드를 이용하여 <code>String</code>을 키울 수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
#}</code></pre></pre>
<p><code>s</code>는 이 두 라인 뒤에 “foobar”를 담게 될 것입니다. <code>push_str</code> 메소드는 스트링 슬라이스를 파라미터로
갖는데 이는 파라미터의 소유권을 가져올 필요가 없기 때문입니다. 예를 들어, 아래와 같은 상황에서 <code>s1</code>에
<code>s2</code>의 내용물을 추가한 뒤 <code>s2</code>를 더 이상 쓸 수 없게된다면 당혹스러울 것입니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s1 = String::from(&quot;foo&quot;);
let s2 = String::from(&quot;bar&quot;);
s1.push_str(&amp;s2);
#}</code></pre></pre>
<p><code>push</code> 메소드는 한 개의 글자를 파라미터로 받아서 <code>String</code>에 추가하도록 정의되어 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;lo&quot;);
s.push('l');
#}</code></pre></pre>
<p>이걸 실행한 뒤에 <code>s</code>는 “lol”을 담고 있을 것입니다.</p>
<a class="header" href="print.html#-연산자나-format-매크로를-이용한-접합" id="-연산자나-format-매크로를-이용한-접합"><h4>+ 연산자나 <code>format!</code> 매크로를 이용한 접합</h4></a>
<p>종종 우리는 가지고 있는 두 개의 스트링을 합께 조합하고 싶어합니다. 한 가지 방법은 아래와 같이 <code>+</code> 연산자를
사용하는 것입니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // s1은 여기서 이동되어 더이상 쓸 수 없음을 유의하세요
#}</code></pre></pre>
<p>이 코드가 실행된 뒤에 스트링 <code>s3</code>는 <code>Hello, world!</code>를 담게 될 것입니다. <code>s1</code>이 더하기 연산
이후에 더이상 유효하지 않은 이유와 <code>s2</code>의 참조자가 사용되는 이유는 <code>+</code> 연산자를 사용했을 때 호출되는
함수의 시그니처와 맞춰야 하기 때문입니다 <code>+</code> 연산자는 <code>add</code> 메소드를 사용하는데, 이 메소드의
시그니처는 아래처럼 생겼습니다:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>이는 표준 라이브러리에 있는 정확한 시그니처는 아닙니다; 표준 라이브러리 내에서 <code>add</code>는 제네릭을 이용하여
정의되어 있습니다. 여기서는 제네릭에 구체 타입(concrete type)을 대입한 <code>add</code>의 시그니처를 보는
중인데, 이는 우리가 <code>String</code> 값으로 이 메소드를 호출했을때 생깁니다. 제네릭에 대한 내용은 10장에서
다룰 것입니다. 이 시그니처는 교묘한 <code>+</code> 연산자를 이해하는데 필요한 단서를 줍니다.</p>
<p>첫번째로, <code>s2</code>는 <code>&amp;</code>를 가지고 있는데, 이는 첫번째 스트링에 두번째 스트링의 <em>참조자</em>를 더하고 있음을
뜻합니다. 이것은 <code>add</code> 함수의 <code>s</code> 파라미터 때문입니다: 우리는 <code>String</code>에 <code>&amp;str</code>만 더할 수 있고,
두 <code>String</code>을 더하지는 못합니다. 하지만, 잠깐만요 - <code>&amp;s2</code>의 타입은 <code>&amp;String</code>이지, <code>add</code>의 두번째
파라미터에 명시한것처럼 <code>&amp;str</code>은 아니죠. 왜 이 예제가 컴파일될까요? <code>&amp;s2</code>를 <code>add</code> 호출에 사용할 수
있는 이유는 <code>&amp;String</code> 인자가 <code>&amp;str</code>로 <em>강제</em>될 수 있기 때문입니다 - <code>add</code> 함수가 호출되면,
러스트는 <em>역참조 강제(deref coercion)</em> 라 불리는 무언가를 사용하는데, 이는 <code>add</code> 함수내에서 사용되는 <code>&amp;s2</code>가
<code>&amp;s2[..]</code>로 비뀌는 것으로 생각할 수 있도록 해줍니다. 역참조 강제에 대한 것은 15장에서 다룰
것입니다. <code>add</code>가 파라미터의 소유권을 가져가지는 않으므로, <code>s2</code>는 이 연산 이후에도 여전히 유효한
<code>String</code>일 것입니다.</p>
<p>두번째로, 시그니처에서 <code>add</code>가 <code>self</code>의 소유권을 가져가는 것을 볼 수 있는데, 이는 <code>self</code>가
<code>&amp;</code>를 <em>안 가지고</em> 있기 때문입니다. 즉 위 예제에서 <code>s1</code>이 <code>add</code> 호출로 이동되어 이후에는 더 이상
유효하지 않을 것이라는 의미입니다. 따라서 <code>let s3 = s1 + &amp;s2;</code>가 마치 두 스트링을 복사하여
새로운 스트링을 만들 것처럼 보이는 반면, 실제로 이 구문은 <code>s1</code>의 소유권을 가져다가 <code>s2</code>의 내용물의
복사본을 추가한 다음, 결과물의 소유권을 반환합니다. 달리 말하면, 이 구문은 여러 복사본을 만드는 것처럼
보여도, 그렇지 않습니다: 이러한 구현은 복사보다 더 효율적입니다.</p>
<p>If we need to concatenate multiple strings, the behavior of <code>+</code> gets unwieldy:
만일 여러 스트링을 접하고자 한다면, <code>+</code>의 동작은 다루기 불편해 집니다.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
#}</code></pre></pre>
<p><code>s</code>는 이 지점에서 “tic-tac-toe”가 될 것입니다. 모든 <code>+</code>와 <code>&quot;</code> 문자들과 함께 보면 어떤 결과가
나올지 알기 힘듭니다. 더 복잡한 스트링 조합을 위해서는 <code>format!</code> 매크로를 사용할 수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
#}</code></pre></pre>
<p>이 코드 또한 <code>s</code>에 “tic-tac-toe”을 설정합니다. <code>format!</code> 매크로는 <code>println!</code>과 똑같은 방식으로
작동하지만, 스크린에 결과를 출력하는 대신 결과를 담은 <code>String</code>을 반환해줍니다. 이 버전이 훨씬 읽기
쉽고, 또한 어떠한 파라미터들의 소유권도 가져가지 않습니다.</p>
<a class="header" href="print.html#스트링-내부의-인덱싱" id="스트링-내부의-인덱싱"><h3>스트링 내부의 인덱싱</h3></a>
<p>다른 많은 언어들에서, 인덱스를 이용한 참조를 통해 스트링 내부의 개별 문자들에 접근하는 것은 유효하고
범용적인 연산에 속합니다. 그러나 러스트에서는 인덱싱 문법을 이용하여 <code>String</code>의 부분에 접근하고자 하면
에러를 얻게 됩니다. 즉 아래와 같은 코드는:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let h = s1[0];
</code></pre>
<p>아래와 같은 에러를 출력합니다:</p>
<pre><code class="language-text">error: the trait bound `std::string::String: std::ops::Index&lt;_&gt;` is not
satisfied [--explain E0277]
  |&gt;
  |&gt;     let h = s1[0];
  |&gt;             ^^^^^
note: the type `std::string::String` cannot be indexed by `_`
</code></pre>
<p>에러와 노트 부분이 이야기해 줍니다: 러스트 스트링은 인덱싱을 지원하지 않는다고. 따라서 뒤따르는 질문은,
왜 안되는 걸까요? 이 질문에 답하기 위해서는 러스트가 어떻게 스트링을 메모리에 저장하는지에 관하여 살짝
이야기해야 합니다.</p>
<a class="header" href="print.html#내부적-표현" id="내부적-표현"><h4>내부적 표현</h4></a>
<p><code>String</code>은 <code>Vec&lt;u8&gt;</code>을 감싼 것입니다(wrapper). 전에 보았던 몇가지 적절히 인코딩된 UTF-8
예제 스트링을 살펴봅시다. 첫번째로, 이것입니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Hola&quot;).len();
#}</code></pre></pre>
<p>이 경우, <code>len</code>은 4가 되는데, 이는 스트링 “Hola”를 저장하고 있는 <code>Vec</code>이 4바이트 길이라는 뜻입니다:
UTF-8로 인코딩되면 각각의 글자들이 1바이트씩 차지한다는 것이죠. 그런데 아래 예제는 어떨까요?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Здравствуйте&quot;).len();
#}</code></pre></pre>
<p>이 스트링의 길이가 얼마인지 질문받은 사람은 12라고 답할런지도 모릅니다. 그러나 러스트의 대답은 24입니다.
이는 “Здравствуйте”를 UTF-8로 인코딩된 바이트들의 크기인데, 각각의 유니코드 스칼라 값이 저장소의
2바이트를 차지하기 때문입니다. 따라서, 스트링의 바이트들 안의 인덱스는 유효한 유니코드 스칼라 값과
항상 대응되지는 않을 것입니다.</p>
<p>이를 보여주기 위해, 다음과 같은 유효하지 않은 러스트 코드를 고려해 보세요:</p>
<pre><code class="language-rust ignore">let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];
</code></pre>
<p><code>answer</code>의 값은 무엇이 되어야 할까요? 첫번째 글자인 <code>З</code>이 되어야 할까요? UTF-8로 인코딩될 때,
<code>З</code>의 첫번째 바이트는 <code>208</code>이고, 두번째는 <code>151</code>이므로, <code>answer</code>는 사실 <code>208</code>이 되어야 하지만,
<code>208</code>은 그 자체로는 유효한 문자가 아닙니다. <code>208</code>을 반환하는 것은 사람들이 이 스트링의 첫번째 글자를
요청했을 경우 사람들이 기대하는 것이 아닙니다. 심지어는 라틴 글자들만 있을 때도요: <code>&amp;&quot;hello&quot;[0]</code>는
<code>h</code>가 아니라 <code>104</code>를 반환합니다. 기대치 않은 값을 반환하고 즉시 발견하기 힘들지도 모를 버그를 야기하는
것을 방지하기 위해, 러스트는 이러한 코드를 전혀 컴파일되지 않는 것을 채택하고 이러한 오해들을 일찌감치
방지합니다.</p>
<a class="header" href="print.html#바이트와-스칼라-값과-문자소-클러스터grapheme-cluster-이런" id="바이트와-스칼라-값과-문자소-클러스터grapheme-cluster-이런"><h4>바이트와 스칼라 값과 문자소 클러스터(Grapheme cluster)! 이런!</h4></a>
<p>이는 UTF-8에 대한 다른 지점을 이끌어냅니다: 러스트의 관점에서는 문자열을 보는 세 가지의 정말
의미있는 방식이 있습니다: 바이트, 스칼라 값, 그리고 문자소 클러스터(사람들이 <em>글자</em>라고 부르는 것과
가장 근접한 것)입니다.</p>
<p>데바가나리 글자로 쓰여진 힌디어 “नमस्ते”를 보면, 이것은 궁극적으로 아래와 같이 <code>u8</code> 값들의
<code>Vec</code>으로서 저장됩니다:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>이건 18바이트이고, 컴퓨터가 이 데이터를 궁극적으로 저장하는 방법입니다. 만일 우리가 이를 유니코드 스칼라
값, 즉 러스트의 <code>char</code> 타입인 형태로 본다면, 아래와 같이 보이게 됩니다:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>여섯개의 <code>char</code> 값이 있지만, 네번쨰와 여섯번째는 글자가 아니고 그 자체로는 이해할 수 없는 발음 구별
부호입니다. 마지막으로, 만일 이를 문자소 클러스로서 본다면, 사람들이 발음할 이 단어를 구성하는 네 글자를
얻습니다:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>러스트는 컴퓨터가 저장하는 가공되지 않은(raw) 스트링을 번역하는 다른 방법을 제공하여, 데이터가 담고 있는
것이 어떤 인간의 언어든 상관없이 각각의 프로그램이 필요로 하는 통역방식을 선택할 수 있도록 합니다.</p>
<p>러스트가 <code>String</code>을 인덱스로 접근하여 문자를 얻지 못하도록 하는 마지막 이유는 인덱스 연산이
언제나 상수 시간(O(1))에 실행될 것으로 기대받기 때문입니다. 그러나 <code>String</code>을 가지고 그러한
성능을 보장하는 것은 불가능한데, 그 이유는 러스트가 스트링 내에 얼마나 많은 유효 문자가 있는지
알아내기 위해 내용물의 시작 지점부터 인덱스로 지정된 곳까지 훑어야 하기 때문입니다.</p>
<a class="header" href="print.html#스트링-슬라이싱하기" id="스트링-슬라이싱하기"><h3>스트링 슬라이싱하기</h3></a>
<p>스트링 인덱싱의 리턴 타입이 어떤 것이 되어야 하는지 투명하지 않고, 스트링의 인덱싱이 종종 나쁜 아이디어이기
때문에, 여러분이 정말로 이를 원할 경우 러스트는 좀 더 구체적으로 지정하도록 요청하는 형태로 여러분을
만류합니다. <code>[]</code>에 숫자 하나를 사용하는 인덱싱보다 더 구체적일 수 있는 방법은 <code>[]</code>와 범위를 사용하여
특정 바이트들이 담고 있는 스트링 슬라이스를 만드는 것입니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
#}</code></pre></pre>
<p>여기서 <code>s</code>는 스트링의 첫 4바이트를 담고 있는 <code>&amp;str</code>가 될 것입니다. 앞서 우리는 이 글자들이 각각
2바이트를 차지한다고 언급했으므로, 이는 <code>s</code>가 “Зд”이 될 것이란 뜻입니다.</p>
<p>만약에 <code>&amp;hello[0..1]</code>라고 했다면 어떻게 될까요? 답은 다음과 같습니다: 런타임에 패닉이 발생하는데,
이는 벡터 내에 유효하지 않은 인덱스에 접근했을 때와 동일한 방식입니다:</p>
<pre><code class="language-text">thread 'main' panicked at 'index 0 and/or 1 in `Здравствуйте` do not lie on
character boundary', ../src/libcore/str/mod.rs:1694
</code></pre>
<p>여러분은 조심스럽게 이 방법을 사용해야 하는데, 이는 여러분의 프로그램을 죽게 만들 수도 있기 때문입니다.</p>
<a class="header" href="print.html#스트링-내에서-반복적으로-실행되는-메소드" id="스트링-내에서-반복적으로-실행되는-메소드"><h3>스트링 내에서 반복적으로 실행되는 메소드</h3></a>
<p>다행히도, 스트링의 요소에 접근하는 다른 방법이 있습니다.</p>
<p>만일 개별적인 유니코드 스칼라 값에 대한 연산을 수행하길 원한다면, 가장 좋은 방법은 <code>chars</code> 메소드를
이용하는 것입니다. <code>chars</code>를 “नमस्ते”에 대해 호출하면 <code>char</code>타입의 6개의 값으로 나누어 반환하며,
여러분은 각각의 요소에 접근하기 위해 이 결과값에 대해 반복(iterate)할 수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
#}</code></pre></pre>
<p>이 코드는 다음을 출력할 것입니다:</p>
<pre><code class="language-text">न
म
स
्
त
े
</code></pre>
<p><code>bytes</code> 메소드는 가공되지 않은 각각의 바이트를 반환하는데, 여러분의 문제 범위에 따라 적절할 수도
있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
#}</code></pre></pre>
<p>이 코드는 이 <code>String</code>을 구성하는 아래처럼 시작되는 18 바이트를 출력합니다:</p>
<pre><code class="language-text">224
164
168
224
// ... etc
</code></pre>
<p>하지만 유효한 유니코드 스칼라 값이 하나 이상의 바이트로 구성될지도 모른다는 것을 확실히 기억해주세요.</p>
<p>스트링으로부터 문자소 클러스터를 얻는 방법은 복잡해서, 이 기능은 표준 라이브러리를 통해 제공되지 않습니다.
여러분이 원하는 기능이 이것이라면 crates.io에서 사용 가능한 크레이트가 있습니다.</p>
<a class="header" href="print.html#스트링은-그렇게-단순하지-않습니다" id="스트링은-그렇게-단순하지-않습니다"><h3>스트링은 그렇게 단순하지 않습니다</h3></a>
<p>종합하면, 스트링은 복잡합니다. 다른 프로그래밍 언어들은 이러한 복잡성을 프로그래머에게 어떻게 보여줄지에
대해 각기 다른 선택을 합니다. 러스트는 <code>String</code> 데이터의 올바른 처리가 모든 러스트 프로그램에 대한
기본적인 동작이 되도록 선택했는데, 이는 솔직히 프로그래머들이 UTF-8 데이터를 처리하는데 있어 더 많은
생각을 해야한다는 의미입니다. 이러한 거래는 다른 프로그래밍 언어들에 비해 더 복잡한 스트링을 노출시키지만,
한편으로는 여러분의 개발 생활 주기 후반에 비 ASCII 캐릭터를 포함하는 에러를 처리해야 하는 것을
막아줄 것입니다.</p>
<p>이것보다 살짝 덜 복잡한 것으로 옮겨 갑시다: 해쉬맵이요!</p>
<a class="header" href="print.html#해쉬맵hash-map" id="해쉬맵hash-map"><h2>해쉬맵(hash map)</h2></a>
<p>마지막으로 볼 일반적인 컬렉션은 <em>해쉬맵</em>입니다. <code>HashMap&lt;K, V&gt;</code> 타입은 <code>K</code> 타입의 키에
<code>V</code> 타입의 값을 매핑한 것을 저장합니다. 이 매핑은 <em>해쉬 함수(hashing function)</em> 을 통해
동작하는데, 해쉬 함수는 이 키와 값을 메모리 어디에 저장할지 결정합니다. 많은 다른 프로그래밍 언어들도
이러한 종류의 데이터 구조를 지원하지만, 종종 다른 이름으로 제공됩니다: 해쉬, 맵, 오브젝트, 해쉬 테이블,
혹은 연관 배열(associative) 등 그저 몇몇 이름으로 불리지요.</p>
<p>해쉬맵은 여러분이 벡터를 이용하듯 인덱스를 이용하는 것이 아니라 임의의 타입으로 된 키를 이용하여
데이터를 찾을 수 있기를 원할때 유용합니다. 예를 들면, 게임 상에서는 각 팀의 점수를 해쉬맵에 유지할
수 있는데, 여기서 키는 팀의 이름이고 값은 팀의 점수가 될 수 있습니다. 팀의 이름을 주면, 여러분은
그 팀의 점수를 찾을 수 있습니다.</p>
<p>이 장에서는 해쉬맵의 기본 API를 다룰 것이지만, 표준 라이브러리의 <code>HashMap</code>에 정의되어 있는
함수 중에는 더 좋은 것들이 숨어있습니다. 항상 말했듯이, 더 많은 정보를 원하신다면 표준 라이브러리
문서를 확인하세요.</p>
<a class="header" href="print.html#새로운-해쉬맵-생성하기" id="새로운-해쉬맵-생성하기"><h3>새로운 해쉬맵 생성하기</h3></a>
<p>우리는 빈 <code>HashMap</code>를 <code>new</code>로 생성할 수 있고, <code>insert</code>를 이용하여 요소를 추가할 수 있습니다.
여기서 우리는 팀 이름이 각각 블루(Blue)와 옐로우(Yellow)인 두 팀의 점수를 유지하고 있습니다. 블루
팀은 10점, 옐로우 팀은 50점으로 시작할 것입니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
#}</code></pre></pre>
<p>먼저 표준 라이브러리의 컬렉션 부분으로부터 <code>HashMap</code>을 <code>use</code>로 가져와야할 필요가 있음을 주목하세요.
우리가 보고 있는 세 가지 일반적인 컬렉션 중에서 이 해쉬맵이 제일 덜 자주 사용되는 것이기 때문에,
프렐루드(prelude) 내에 자동으로 가져와지는 기능에 포함되어 있지 않습니다. 또한 해쉬맵은 표준
라이브러리로부터 덜 지원을 받습니다; 예를 들면 해쉬맵을 생성하는 빌트인 매크로가 없습니다.</p>
<p>벡터와 마찬가지로, 해쉬맵도 데이터를 힙에 저장합니다. 이 <code>HashMap</code>은 <code>String</code> 타입의 키와 <code>i32</code>
타입의 값을 갖습니다. 벡터와 비슷하게 해쉬맵도 동질적입니다: 모든 키는 같은 타입이어야 하고, 모든
값도 같은 타입이여야 합니다.</p>
<p>해쉬맵을 생성하는 또다른 방법은 튜플의 벡터에 대해 <code>collect</code> 메소드를 사용하는 것인데, 이 벡터의
각 튜플은 키와 키에 대한 값으로 구성되어 있습니다. <code>collect</code> 메소드는 데이터를 모아서 <code>HashMap</code>을
포함한 여러 컬렉션 타입으로 만들어줍니다. 예를 들면, 만약 두 개의 분리된 벡터에 각각 팀 이름과 초기
점수를 갖고 있다면, 우리는 <code>zip</code> 메소드를 이용하여 “Blue”와 10이 한 쌍이 되는 식으로 튜플의
벡터를 생성할 수 있습니다. 그 다음 <code>collect</code> 메소드를 사용하여 튜플의 벡터를 <code>HashMap</code>으로 바꿀
수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let teams  = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];

let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
#}</code></pre></pre>
<p>타입 명시 <code>HashMap&lt;_, _&gt;</code>이 필요한데 이는 <code>collect</code>가 다른 많은 데이터 구조로 바뀔 수 있고,
러스트는 여러분이 특정하지 않으면 어떤 것을 원하는지 모르기 때문입니다. 그러나 키와 값의 타입에 대한
타입 파라미터에 대해서는 밑줄을 쓸 수 있으며 러스트는 벡터에 담긴 데이터의 타입에 기초하여 해쉬에
담길 타입을 추론할 수 있습니다.</p>
<a class="header" href="print.html#해쉬맵과-소유권" id="해쉬맵과-소유권"><h3>해쉬맵과 소유권</h3></a>
<p><code>i32</code>와 같이 <code>Copy</code> 트레잇을 구현한 타입에 대하여, 그 값들은 해쉬맵 안으로 복사됩니다. <code>String</code>과
같이 소유된 값들에 대해서는, 값들이 이동되어 해쉬맵이 그 값들에 대한 소유자가 될 것입니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let field_name = String::from(&quot;Favorite color&quot;);
let field_value = String::from(&quot;Blue&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name과 field_value은 이 지점부터 유효하지 않습니다
#}</code></pre></pre>
<p><code>insert</code>를 호출하여 <code>field_name</code>과 <code>field_value</code>를 해쉬맵으로 이동시킨 후에는 더 이상 이 둘을
사용할 수 없을 것입니다.</p>
<p>만일 우리가 해쉬맵에 값들의 참조자들을 삽입한다면, 값들 자체는 해쉬맵으로 이동되지 않을 것입니다. 하지만
참조자가 가리키고 있는 값은 해쉬맵이 유효할 때까지 계속 유효해야합니다. 이것과 관련하여 10장의 라이프타임
절에서 더 자세히 이야기할 것입니다.</p>
<a class="header" href="print.html#해쉬맵-내의-값-접근하기" id="해쉬맵-내의-값-접근하기"><h3>해쉬맵 내의 값 접근하기</h3></a>
<p>해쉬맵의 <code>get</code> 메소드에 키를 제공하여 해쉬맵으로부터 값을 얻어올 수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);
#}</code></pre></pre>
<p>여기서 <code>score</code>는 블루 팀과 연관된 값을 가지고 있을 것이고, 결과값은 <code>Some(&amp;10)</code>일 것입니다.
결과값은 <code>Some</code>으로 감싸져 있는데 왜냐하면 <code>get</code>이 <code>Option&lt;&amp;V&gt;</code>를 반환하기 때문입니다; 만일
해쉬맵 내에 해당 키에 대한 값이 없다면 <code>get</code>은 <code>None</code>을 반환합니다. 프로그램은 우리가 6장에서 다루었던
방법 중 하나로 <code>Option</code>을 처리해야 할 것입니다.</p>
<p>우리는 벡터에서 했던 방법과 유사한 식으로 <code>for</code> 루프를 이용하여 해쉬맵에서도 각각의 키/값 쌍에 대한 반복작업을
할 수 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
#}</code></pre></pre>
<p>이 코드는 각각의 쌍을 임의의 순서로 출력할 것입니다:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<a class="header" href="print.html#해쉬맵-갱신하기" id="해쉬맵-갱신하기"><h3>해쉬맵 갱신하기</h3></a>
<p>키와 값의 개수가 커질 수 있는 반면, 각각의 개별적인 키는 한번에 연관된 값 하나만을 가질 수 있습니다.
해쉬맵 내의 데이터를 변경하길 원한다면, 키에 이미 값이 할당되어 있을 경우에 대한 처리를 어떻게 할지
결정해야 합니다. 예전 값을 완전히 무시하면서 예전 값을 새 값으로 대신하는 방법을 선택할 수도 있습니다.
혹은 예전 값을 계속 유지하면서 새 값은 무시하고, 해당 키에 값이 할당되지 <em>않을</em> 경우에만 새 값을
추가하는 방법을 선택할 수도 있습니다. 또는 예전 값과 새 값을 조합할 수도 있습니다. 각각의 경우를
어떻게 할지 살펴봅시다!</p>
<a class="header" href="print.html#값을-덮어쓰기" id="값을-덮어쓰기"><h4>값을 덮어쓰기</h4></a>
<p>만일 해쉬맵에 키와 값을 삽입하고, 그 후 똑같은 키에 다른 값을 십입하면, 키에 연관지어진 값은 새 값으로
대신될 것입니다. 아래 코드가 <code>insert</code>를 두 번 호출함에도, 해쉬맵은 딱 하나의 키/값 쌍을 담게 될 것인데
그 이유는 두 번 모두 블루 팀의 키에 대한 값을 삽입하고 있기 때문입니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Blue&quot;), 25);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<p>이 코드는 <code>{&quot;Blue&quot;: 25}</code>를 출력할 것입니다. 원래의 값 10은 덮어써졌습니다.</p>
<a class="header" href="print.html#키에-할당된-값이-없을-경우에만-삽입하기" id="키에-할당된-값이-없을-경우에만-삽입하기"><h4>키에 할당된 값이 없을 경우에만 삽입하기</h4></a>
<p>특정 키가 값을 가지고 있는지 검사하고, 만일 가지고 있지 않다면 이 키에 대한 값을 삽입하고자 하는 경우는
흔히 발생합니다. 해쉬맵은 이를 위하여 <code>entry</code>라고 하는 특별한 API를 가지고 있는데, 이는 우리가 검사하고자
하는 키를 인자로 받습니다. <code>entry</code> 함수의 리턴값은 열거형 <code>Entry</code>인데, 해당 키가 있는지 혹은 없는지를
나타냅니다. 우리가 옐로우 팀에 대한 키가 연관된 값을 가지고 있는지 검사하고 싶어한다고 해봅시다. 만일
없다면, 값 50을 합입하고, 블루팀에 대해서도 똑같이 하고 싶습니다. 엔트리 API를 사용한 코드는 아래와
같습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<p><code>Entry</code>에 대한 <code>or_insert</code> 메소드는 해당 키가 존재할 경우 관련된 <code>Entry</code> 키에 대한 값을 반환하고,
그렇지 않을 경우에는 인자로 주어진 값을 해당 키에 대한 새 값을 삽입하고 수정된 <code>Entry</code>에 대한 값을
반환합니다. 이는 우리가 직접 로직을 작성하는 것보다 훨씬 깔끔하고, 게다가 빌림 검사기와 잘 어울려
동작합니다.</p>
<p>이 코드는 <code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>를 출력할 것입니다. 첫번째 <code>entry</code> 호출은 옐로우
팀에 대한 키에 대하여 값 50을 삽입하는데, 이는 옐로우 팀이 값을 가지고 있지 않기 떄문입니다. 두번째
<code>entry</code> 호출은 해쉬맵을 변경하지 않는데, 왜냐하면 블루 팀은 이미 값 10을 가지고 있기 때문입니다.</p>
<a class="header" href="print.html#예전-값을-기초로-값을-갱신하기" id="예전-값을-기초로-값을-갱신하기"><h4>예전 값을 기초로 값을 갱신하기</h4></a>
<p>해쉬맵에 대한 또다른 흔한 사용 방식은 키에 대한 값을 찾아서 예전 값에 기초하여 값을 갱신하는 것입니다.
예를 들어, 만일 우리가 어떤 텍스트에 대해 각 단어가 몇번이나 나오는지 세어보고 싶어한다면, 단어를 키로
사용하는 해쉬맵을 이용하여 해당 단어가 몇번이나 나왔는지를 유지하기 위해 값을 증가시킬 수 있습니다.
만일 어던 단어를 처음 본 것이라면, 값 <code>0</code>을 삽입할 것입니다.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
#}</code></pre></pre>
<p>이 코드는 <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>를 출력할 것입니다. <code>or_insert</code>
메소드는 실제로는 해당 키에 대한 값의 가변 참조자 (<code>&amp;mut V</code>)를 반환합니다. 여기서는 <code>count</code> 변수에
가변 참조자를 저장하였고, 여기에 값을 할당하기 위해 먼저 애스터리스크 (<code>*</code>)를 사용하여 <code>count</code>를
역참조해야 합니다. 가변 참조자는 <code>for</code> 루프의 끝에서 스코프 밖으로 벗어나고, 따라서 모든 값들의 변경은
안전하며 빌림 규칙에 위배되지 않습니다.</p>
<a class="header" href="print.html#해쉬-함수" id="해쉬-함수"><h3>해쉬 함수</h3></a>
<p>기본적으로, <code>HashMap</code>은 서비스 거부 공격(Denial of Service(DoS) attack)에 저항 기능을 제공할
수 있는 암호학적으로 보안되는 해쉬 함수를 사용합니다. 이는 찾을 수 있는 가장 빠른 해쉬 알고리즘은 아니지만,
성능을 떨어트리면서 더 나은 보안을 취하는 거래는 가치가 있습니다. 만일 여러분이 여러분의 코드를 프로파일하여
기본 해쉬 함수가 여러분의 목표에 관해서는 너무 느리다면, 다른 <em>해쉬어(hasher)</em> 를 특정하여 다른 함수로
바꿀 수 있습니다. 해쉬어는 <code>BuildHasher</code> 트레잇을 구현한 타입을 말합니다. 트레잇과 이를 어떻게
구현하는지에 대해서는 10장에서 다룰 것입니다. 여러분의 해쉬어를 바닥부터 새로 구현해야할 필요는 없습니다;
crates.io에서는 많은 수의 범용적인 해쉬 알고리즘을 구현한 해쉬어를 제공하는 공유 라이브러리를 제공합니다.</p>
<a class="header" href="print.html#정리-2" id="정리-2"><h2>정리</h2></a>
<p>벡터, 스트링, 그리고 해쉬맵은 프로그램 내에서 여러분이 데이터를 저장하고, 접근하고, 수정하고 싶어하는
곳마다 여러분을 인도해줄 것입니다. 이제 여러분이 풀 준비가 되어있어야 할만한 몇가지 연습문제를 소개합니다:</p>
<ul>
<li>정수 리스트가 주어졌을 때, 벡터를 이용하여 이 리스트의 평균값(mean, average), 중간값(median,
정렬했을 때 가장 가운데 위치한 값), 그리고 최빈값(mode, 가장 많이 발생한 값; 해쉬맵이 여기서 도움이
될 것입니다)를 반환해보세요.</li>
<li>스트링을 피그 라틴(Pig Latin)으로 변경해보세요. 피그 라틴은 각 단어의 첫번째 자음을 단어의 끝에 붙이고
“ay”를 붙이고, 모음으로 시작하는 단어는 대신 끝에 “hay”를 붙이는 것입니다. (따라서 “first”는
“irst-fay”, “apple”은 “apple-hay”가 됩니다.) UTF-8 인코딩에 대해 기억하세요!</li>
<li>해쉬맵과 벡터를 이용하여, 사용자가 회사 내의 부서에 대한 피고용인 이름을 추가할 수 있도록 하는 텍스트
인터페이스를 만들어보세요. 예를들어 “Add Sally to Engineering”이나 “Add Amir to Sales”
같은 식으로요. 그후 사용자 각 부터의 모든 사람들에 대한 리스트나 알파벳 순으로 정렬된 부서별 모든
사람에 대한 리스트를 조회할 수 있도록 해보세요.</li>
</ul>
<p>표준 라이브러리 API 문서는 이 연습문제들에 대해 도움이 될만한 타입들과 메소드들을 설명해줍니다!</p>
<p>우리는 연산이 실패할 수 있는 더 복잡한 프로그램으로 진입하고 있는 상황이고, 이는 다음으로 에러 처리에
대해 다룰 완벽한 시간이란 뜻이죠!</p>
<a class="header" href="print.html#에러-처리" id="에러-처리"><h1>에러 처리</h1></a>
<p>러스트의 신뢰성에 대한 약속은 에러 처리에도 확장되어 있습니다. 에러는 소프트웨어에서 피할 수 없는 현실이며,
따라서 러스트는 무언가 잘못되었을 경우에 대한 처리를 위한 몇가지 기능을 갖추고 있습니다. 많은 경우,
러스트는 여러분이 에러가 발생할 가능성을 인정하고 여러분의 코드가 컴파일 되기 전에 어떤 행동을 취하기를
요구할 것입니다. 이는 여러분의 코드를 제품으로서 배포한 이후에만 에러를 발견하진 않을 것이라고 보장함으로써
여러분의 프로그램을 더 강건하게 해줍니다.</p>
<p>러스트는 에러를 두 가지 범주로 묶습니다: <em>복구 가능한(recoverable)</em> 에러와
<em>복구 불가능한(unrecoverable)</em> 에러입니다. 복구 가능한 에러는 사용자에게 문제를 보고하고 연산을
재시도하는 것이 보통 합리적인 경우인데, 이를테면 파일을 찾을 수 없는 등의 경우가 그렇습니다. 복구 불가능한
에러는 언제나 버그의 증상이 나타나는데, 예를 들면 배열의 끝을 넘어선 위치의 값을 접근하려고 시도하는 경우가
그렇습니다.</p>
<p>대부분의 언어들은 이 두 종류의 에러를 분간하지 않으며, 예외 처리(exception)와 같은 메카니즘을
이용하여 같은 방식으로 둘 다 처리합니다. 러스트는 예외 처리 기능이 없습니다. 대신, 복구 가능한 에러를
위한 <code>Result&lt;T, E&gt;</code> 값과 복구 불가능한 에러가 발생했을 때 실행을 멈추는 <code>panic!</code> 매크로를 가지고
있습니다. 이번 장에서는 <code>panic!</code>을 호출하는 것을 먼저 다룬 뒤, <code>Result&lt;T, E&gt;</code> 값을 반환하는
것에 대해 이야기 하겠습니다. 마지막으로, 에러로부터 복구을 시도할지 아니면 실행을 멈출지를 결정할 때
고려할 것에 대해 논의해 보겠습니다.</p>
<a class="header" href="print.html#panic과-함께하는-복구-불가능한-에러" id="panic과-함께하는-복구-불가능한-에러"><h2><code>panic!</code>과 함께하는 복구 불가능한 에러</h2></a>
<p>가끔씩 나쁜 일은 일어나고, 이에 대해 여러분이 할 수 있는 것이 없을 수도 있습니다. 이러한 경우를 위하여
러스트는 <code>panic!</code> 매크로를 가지고 있습니다. 이 매크로가 실행되면, 여러분의 프로그램은 실패 메세지를
출력하고, 스택을 되감고 청소하고, 그후 종료됩니다. 이런 일이 발생하는 가장 흔한 상황은 어떤 종류의
버그가 발견되었고 프로그래머가 이 에러를 어떻게 처리할지가 명확하지 않을 때 입니다.</p>
<blockquote>
<a class="header" href="print.html#패닉-상에서-스택-되감기-vs-그만두기" id="패닉-상에서-스택-되감기-vs-그만두기"><h3>패닉 상에서 스택 되감기 v.s. 그만두기</h3></a>
<p>기본적으로, <code>panic!</code>이 발생하면, 프로그램은 <em>되감기(unwinding)</em> 를 시작하는데, 이는 러스트가
패닉을 마주친 각 함수로부터 스택을 거꾸로 훑어가면서 데이터를 제거한다는 뜻이지만, 이 훑어가기 및
제거는 일이 많습니다. 다른 대안으로는 즉시 <em>그만두기(abort)</em> 가 있는데, 이는 데이터 제거 없이
프로그램을 끝내는 것입니다. 프로그램이 사용하고 있던 메모리는 운영체제에 의해 청소될 필요가 있을
것입니다. 여러분의 프로젝트 내에서 결과 바이너리가 가능한 작아지기를 원한다면, 여러분의
<em>Cargo.toml</em> 내에서 적합한 <code>[profile]</code> 섹션에 <code>panic = 'abort'</code>를 추가함으로써 되감기를
그만두기로 바꿀 수 있습니다. 예를 들면, 여러분이 릴리즈 모드 내에서는 패닉 상에서 그만두기를
쓰고 싶다면 아래와 같이 합니다:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>단순한 프로그램으로 <code>panic!</code> 호출을 시도해 봅시다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre></pre>
<p>이걸 실행하면 다음과 같은 것을 보게 될 것입니다:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25 secs
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/panic` (exit code: 101)
</code></pre>
<p>마지막 세 줄이 <code>panic!</code>을 호출함으로 인해 생긴 에러 메세지를 담고 있습니다. 첫번째 줄은 우리의 패닉
메세지와 소스 코드에서 패닉이 발생한 지점을 보여줍니다: <em>src/main.rs:2</em>는 <em>src/main.rs</em> 파일의
두번째 줄을 가리킵니다.</p>
<p>위 예제의 경우, 가리키고 있는 줄은 우리 코드 부분이고, 해당 줄로 가면 <code>panic!</code> 매크로 호출을 보게 됩니다.
그 외의 경우들에서는, <code>panic!</code> 호출이 우리 코드가 호출한 코드 내에 있을 수도 있습니다. 에러 메세지에
의해 보고되는 파일 이름과 라인 번호는 <code>panic!</code> 매크로가 호출된 다른 누군가의 코드일 것이며, 궁극적으로
<code>panic!</code>을 이끌어낸 것이 우리 코드 라인이 아닐 것입니다. 이를 발견하기 위해서 <code>panic!</code> 호출이
발생된 함수에 대한 백트레이스(backtrace)를 사용할 수 있습니다.</p>
<a class="header" href="print.html#panic-백트레이스-사용하기" id="panic-백트레이스-사용하기"><h3><code>panic!</code> 백트레이스 사용하기</h3></a>
<p>다른 예를 통해서, 우리 코드가 직접 매크로를 호출하는 대신 우리 코드의 버그 때문에 <code>panic!</code> 호출이
라이브러리로부터 발생될 때는 어떻게 되는지 살펴봅시다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
    let v = vec![1, 2, 3];

    v[100];
}
</code></pre></pre>
<p>우리는 벡터의 100번째 요소에 접근하기를 시도하고 있지만, 벡터는 오직 3개의 요소만 가지고 있습니다.
이러한 상황이면 러스트는 패닉을 일으킬 것입니다. <code>[]</code>를 사용하는 것은 어떤 요소를 반환하기를 가정하지만,
유효하지 않은 인덱스를 넘기게 되면 러스트가 반환할 올바른 요소는 없습니다.</p>
<p>이러한 상황에서 C 같은 다른 언어들은 여러분이 원하는 것이 아닐지라도, 여러분이 요청한 것을 정확히 주려고
시도할 것입니다: 여러분은 벡터 내에 해당 요소와 상응하는 위치의 메모리에 들어있는 무언가를 얻을 것입니다.
설령 그 메모리 영역이 벡터 소유가 아닐지라도 말이죠. 이러한 것을 <em>버퍼 오버리드(buffer overread)</em>
라고 부르며, 만일 어떤 공격자가 읽도록 허용되어선 안되지만 배열 뒤에 저장되어 있는 데이터를 읽어낼
방법으로서 인덱스를 다룰 수 있게 된다면, 이는 보안 취약점을 발생시킬 수 있습니다.</p>
<p>여러분의 프로그램을 이러한 종류의 취약점으로부터 보호하기 위해서, 여러분이 존재하지 않는 인덱스 상의
요소를 읽으려 시도한다면, 려스트는 실행을 멈추고 계속하기를 거부할 것입니다. 한번 시도해 봅시다:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is
100', /stable-dist-rustc/build/src/libcollections/vec.rs:1362
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/panic` (exit code: 101)
</code></pre>
<p>위 에러는 우리가 작성하지 않은 파일인 <em>libcollections/vec.rs</em>를 가리키고 있습니다. 이는
표준 라이브러리 내에 있는 <code>Vec&lt;T&gt;</code>의 구현 부분입니다. 우리가 벡터 <code>v</code>에 <code>[]</code>를 사용할 때 실행되는
코드는 <em>libcollections/vec.rs</em> 안에 있으며, 그곳이 바로 <code>panic!</code>이 실제 발생한 곳입니다.</p>
<p>그 다음 노트는 <code>RUST_BACKTRACE</code> 환경 변수를 설정하여 에러의 원인이 된 것이 무엇인지 정확하게
백트레이스할 수 있다고 말해주고 있습니다. 이를 시도해봅시다. Listing 9-1은 결과를 보여줍니다:</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 100', /stable-dist-rustc/build/src/libcollections/vec.rs:1392
stack backtrace:
   1:     0x560ed90ec04c - std::sys::imp::backtrace::tracing::imp::write::hf33ae72d0baa11ed
                        at /stable-dist-rustc/build/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:42
   2:     0x560ed90ee03e - std::panicking::default_hook::{{closure}}::h59672b733cc6a455
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:351
   3:     0x560ed90edc44 - std::panicking::default_hook::h1670459d2f3f8843
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:367
   4:     0x560ed90ee41b - std::panicking::rust_panic_with_hook::hcf0ddb069e7abcd7
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:555
   5:     0x560ed90ee2b4 - std::panicking::begin_panic::hd6eb68e27bdf6140
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:517
   6:     0x560ed90ee1d9 - std::panicking::begin_panic_fmt::abcd5965948b877f8
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:501
   7:     0x560ed90ee167 - rust_begin_unwind
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:477
   8:     0x560ed911401d - core::panicking::panic_fmt::hc0f6d7b2c300cdd9
                        at /stable-dist-rustc/build/src/libcore/panicking.rs:69
   9:     0x560ed9113fc8 - core::panicking::panic_bounds_check::h02a4af86d01b3e96
                        at /stable-dist-rustc/build/src/libcore/panicking.rs:56
  10:     0x560ed90e71c5 - &lt;collections::vec::Vec&lt;T&gt; as core::ops::Index&lt;usize&gt;&gt;::index::h98abcd4e2a74c41
                        at /stable-dist-rustc/build/src/libcollections/vec.rs:1392
  11:     0x560ed90e727a - panic::main::h5d6b77c20526bc35
                        at /home/you/projects/panic/src/main.rs:4
  12:     0x560ed90f5d6a - __rust_maybe_catch_panic
                        at /stable-dist-rustc/build/src/libpanic_unwind/lib.rs:98
  13:     0x560ed90ee926 - std::rt::lang_start::hd7c880a37a646e81
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:436
                        at /stable-dist-rustc/build/src/libstd/panic.rs:361
                        at /stable-dist-rustc/build/src/libstd/rt.rs:57
  14:     0x560ed90e7302 - main
  15:     0x7f0d53f16400 - __libc_start_main
  16:     0x560ed90e6659 - _start
  17:                0x0 - &lt;unknown&gt;
</code></pre>
<p><span class="caption">Listing 9-1: 환경 변수 <code>RUST_BACKTRACE</code>가 설정되었을 때 <code>panic!</code>의
호출에 의해 발생되는 백트레이스 출력</span></p>
<p>출력이 엄청 많군요! 백트레이스의 11번 라인이 문제를 일으킨 우리 프로젝트의 라인을 가리키고 있습니다:
<em>src/main.rs</em>, 4번 라인입니다. 백트레이스는 이 지점에서 호출되었던 모든 함수들의 리스트입니다.
러스트의 백트레이스는 다른 언어 내에서의 백트레이스와 비슷하게 동작합니다: 백트레이스를 읽는 열쇠는
여러분이 작성한 파일을 볼때까지 위에서부터 읽어내려가기 시작하는 것입니다. 그곳이 바로 문제가 시작된
지점입니다. 여러분의 파일이 언급된 라인의 윗 라인들은 여러분의 코드가 호출한 코드입니다; 밑의 라인들은
여러분의 코드를 호출한 코드입니다. 이 라인들은 핵심 러스트 코드, 표준 라이브러리 코드, 혹은 여러분이
사용중인 크레이트를 포함할 수도 있습니다.</p>
<p>만일 프로그램이 패닉에 빠지지 않도록 하고 싶다면, 우리가 작성한 파일이 언급된 첫 라인으로 지적된 위치가
바로 패닉을 일으킨 값을 가지고 있는 위치를 찾아내기 위해 수사하기 시작할 지점입니다. 백트레이스를 어떻게
사용하는지 시범을 보이기 위해 고의로 패닉을 일으키는 코드를 작성한 우리의 예제에서, 패닉을 고칠 방법은
고작 3개의 아이템을 가진 벡터로부터 인덱스 100에서의 요소를 요청하지 않도록 하는 것입니다. 여러분의
코드가 추후 패닉에 빠졌을 때, 여러분의 특정한 경우에 대하여 어떤 코드가 패닉을 일으키는 값을 만드는지와
코드는 대신 어떻게 되어야 할지를 알아낼 필요가 있을 것입니다.</p>
<p>우리는 <code>panic!</code>으로 다시 돌아올 것이며 언제 이 메소드를 써야하는지, 혹은 쓰지 말아야 하는지에 대해
이 장의 뒷 부분에서 알아보겠습니다. 다음으로 <code>Result</code>를 이용하여 에러로부터 어떻게 복구하는지를
보겠습니다.</p>
<a class="header" href="print.html#result와-함께하는-복구-가능한-에러" id="result와-함께하는-복구-가능한-에러"><h2><code>Result</code>와 함께하는 복구 가능한 에러</h2></a>
<p>대부분의 에러는 프로그램을 전부 멈추도록 요구될 정도로 심각하지는 않습니다. 종종 어떤 함수가 실패할
때는, 우리가 쉽게 해석하고 대응할 수 있는 이유에 대한 것입니다. 예를 들어, 만일 우리가 어떤 파일을
여는데 해당 파일이 존재하지 않아서 연산에 실패했다면, 프로세스를 멈추는 대신 파일을 새로 만드는
것을 원할지도 모릅니다.</p>
<p>2장의 “<a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type"><code>Result</code> 타입으로 잠재된 실패 다루기</a><!-- ignore -->”에서
<code>Result</code> 열거형은 다음과 같이 <code>Ok</code>와 <code>Err</code>라는 두 개의 variant를 갖도록 정의되어 있음을
상기하세요:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p><code>T</code>와 <code>E</code>는 제네릭 타입 파라미터입니다; 10장에서 제네릭에 대해 더 자세히 다룰 것입니다. 지금으로서
여러분이 알아둘 필요가 있는 것은, <code>T</code>는 성공한 경우에 <code>Ok</code> variant 내에 반환될 값의 타입을 나타내고
<code>E</code>는 실패한 경우에 <code>Err</code> variant 내에 반환될 에러의 타입을 나타내는 것이라는 점입니다. <code>Result</code>가
이러한 제네릭 타입 파라미터를 갖기 때문에, 우리가 반환하고자 하는 성공적인 값과 에러 값이 다를 수 있는
다양한 상황 내에서 표준 라이브러리에 정의된 <code>Result</code> 타입과 함수들을 사용할 수 있습니다.</p>
<p>Listing 9-2에서 보시는 것 처럼 파일을 열 때 함수가 실패할 수도 있어 <code>Result</code> 값을 반환하는 함수를
호출해 봅시다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 9-2: 파일 열기</span></p>
<p><code>File::open</code>이 <code>Result</code>를 반환하는지 어떻게 알까요? 표준 라이브러리 API 문서를 찾아보거나,
컴파일러에게 물어볼 수 있습니다! 만일 <code>f</code>에게 우리가 알고 있고 그 함수의 반환 타입은 <em>아닐</em> 어떤 타입에
대한 타입 명시를 주고, 그리고 그 코드의 컴파일을 시도한다면, 컴파일러는 우리에게 타입이 맞지 않는다고
알려줄 것입니다. 그후 에러 메세지는 <code>f</code>의 타입이 <em>무엇인지</em> 알려줄 것입니다! 한번 해봅시다:
우리는 <code>File::open</code>의 반환 타입이 <code>u32</code>는 아니라는 것을 알고 있으니, <code>let f</code> 구문을 이렇게
바꿔봅시다:</p>
<pre><code class="language-rust ignore">let f: u32 = File::open(&quot;hello.txt&quot;);
</code></pre>
<p>이제 컴파일을 시도하면 다음 메세지가 나타납니다:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
  = note:    found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`
</code></pre>
<p>이 메세지는 <code>File::open</code> 함수의 반환 타입이 <code>Result&lt;T, E&gt;</code>라는 것을 알려줍니다. 여기서 제네릭
파라미터 <code>T</code>는 성공값의 타입인 <code>std::fs::File</code>로 체워져 있는데, 이것은 파일 핸들입니다. 에러에
사용되는 <code>E</code>의 타입은 <code>std::io::Error</code>입니다.</p>
<p>이 반환 타입은 <code>File::open</code>을 호출하는 것이 성공하여 우리가 읽거나 쓸 수 있는 파일 핸들을 반환해
줄 수도 있다는 뜻입니다. 함수 호출은 또한 실패할 수도 있습니다: 예를 들면 파일이 존재하지 않을지도
모르고, 혹은 파일에 접근할 권한이 없을지도 모릅니다. <code>File::open</code> 함수는 우리에게 성공했는지 혹은
실패했는지를 알려주고, 동시에 파일 핸들이나 에러 정보 둘 중 하나를 우리에게 제공할 방법을 가질 필요가
있습니다. 바로 이러한 정보가 <code>Result</code> 열거형이 전달하는 것과 정확히 일치합니다.</p>
<p><code>File::open</code>이 성공한 경우, 변수 <code>f</code>가 가지게 될 값은 파일 핸들을 담고 있는 <code>Ok</code> 인스턴스가
될 것입니다. 실패한 경우, <code>f</code>의 값은 발생한 에러의 종류에 대한 더 많은 정보를 가지고 있는 <code>Err</code>의
인스턴스가 될 것입니다.</p>
<p>우리는 Listing 9-2의 코드에 <code>File::open</code>이 반환하는 값에 따라 다른 행동을 취하는 코드를 추가할
필요가 있습니다. Listing 9-3은 우리가 6장에서 배웠던 기초 도구 <code>match</code> 표현식을 이용하여
<code>Result</code>를 처리하는 한 가지 방법을 보여줍니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            panic!(&quot;There was a problem opening the file: {:?}&quot;, error)
        },
    };
}
</code></pre></pre>
<p><span class="caption">Listing 9-3: <code>match</code> 표현식을 사용하여 발생 가능한 <code>Result</code>
variant들을 처리하기</span></p>
<p><code>Option</code> 열거형과 같이 <code>Result</code> 열거형과 variant들은 프렐루드(prelude)로부터 가져와진다는 점을
기억하세요. 따라서 <code>match</code>의 각 경우에 대해서 <code>Ok</code>와 <code>Err</code> 앞에 <code>Result::</code>를 특정하지 않아도
됩니다.</p>
<p>여기서 우리는 러스트에게 결과가 <code>Ok</code>일 때에는 <code>Ok</code> variant로부터 내부의 <code>file</code> 값을 반환하고,
이 파일 핸들 값을 변수 <code>f</code>에 대입한다고 말해주고 있습니다. <code>match</code> 이후에는 읽거나 쓰기 위해
이 파일 핸들을 사용할 수 있습니다.</p>
<p><code>match</code>의 다른 경우는 <code>File::open</code>으로부터 <code>Err</code>를 얻은 경우를 처리합니다. 이 예제에서는
<code>panic!</code> 매크로를 호출하는 방법을 택했습니다. 우리의 현재 디렉토리 내에 <em>hello.txt</em>라는 이름의
파일이 없는데 이 코드를 실행하게 되면, <code>panic!</code> 매크로로부터 다음과 같은 출력을 보게 될 것입니다:</p>
<pre><code class="language-text">thread 'main' panicked at 'There was a problem opening the file: Error { repr:
Os { code: 2, message: &quot;No such file or directory&quot; } }', src/main.rs:8
</code></pre>
<a class="header" href="print.html#서로-다른-에러에-대해-매칭하기" id="서로-다른-에러에-대해-매칭하기"><h3>서로 다른 에러에 대해 매칭하기</h3></a>
<p>Listing 9-3의 코드는 <code>File::open</code>이 실패한 이유가 무엇이든 간에 <code>panic!</code>을 일으킬 것입니다.
대신 우리가 진짜 하고 싶은 것은 실패 이유에 따라 다른 행동을 취하는 것입니다: 파일이 없어서
<code>File::open</code>이 실패한 것이라면, 새로운 파일을 만들어서 핸들을 반환하고 싶습니다. 만일 그밖의
이유로 <code>File::open</code>이 실패한 거라면, 예를 들어 파일을 열 권한이 없어서라면, Listing 9-3에서
했던 것과 마찬가지로 <code>panic!</code>을 일으키고 싶습니다. <code>match</code>에 새로운 경우를 추가한 Listing 9-4를
봅시다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(ref error) if error.kind() == ErrorKind::NotFound =&gt; {
            match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; {
                    panic!(
                        &quot;Tried to create file but there was a problem: {:?}&quot;,
                        e
                    )
                },
            }
        },
        Err(error) =&gt; {
            panic!(
                &quot;There was a problem opening the file: {:?}&quot;,
                error
            )
        },
    };
}
</code></pre>
<p><span class="caption">Listing 9-4: 다른 종류의 에러를 다른 방식으로 처리하기</span></p>
<p><code>Err</code> variant 내에 있는 <code>File::open</code>이 반환하는 값의 타입은 <code>io::Error</code>인데, 이는
표준 라이브러리에서 제공하는 구조체입니다. 이 구조체는 <code>kind</code> 메소드를 제공하는데 이를 호출하여
<code>io::ErrorKind</code>값을 얻을 수 있습니다. <code>io::ErrorKind</code>는 <code>io</code> 연산으로부터 발생할 수 있는
여러 종류의 에러를 표현하는 variant를 가진, 표준 라이브러리에서 제공하는 열거형입니다. 우리가
관심을 갖고 있는 variant는 <code>ErrorKind::NotFound</code>인데, 이는 열고자 하는 파일이 아직 존재하지
않음을 나타냅니다.</p>
<p>조건문 <code>if error.kind() == ErrorKind::NotFound</code>는 <em>매치 가드(match guard)</em> 라고
부릅니다: 이는 <code>match</code> 줄기 상에서 줄기의 패턴을 좀더 정제해주는 추가 조건문입니다. 그 줄기의 코드가
실행되기 위해서는 이 조건문이 참이어야 합니다; 그렇지 않다면, 패턴 매칭은 <code>match</code>의 다음 줄기에
맞춰보기 위해 이동할 것입니다. 패턴에는 <code>ref</code>가 필요하며 그럼으로써 <code>error</code>가 가드 조건문으로
소유권 이동이 되지 않고 그저 참조만 됩니다. 패턴 내에서 참조자를 얻기 위해 <code>&amp;</code>대신 <code>ref</code>이 사용되는
이유는 18장에서 자세히 다룰 것입니다. 짧게 설명하면, <code>&amp;</code>는 참조자를 매치하고 그 값을 제공하지만,
<code>ref</code>는 값을 매치하여 그 참조자를 제공합니다.</p>
<p>매치 가드 내에서 확인하고자 하는 조건문은 <code>error.kind()</code>에 의해 반환된 값이 <code>ErrorKind</code> 열거형의
<code>NotFound</code> variant인가 하는 것입니다. 만일 그렇다면, <code>File::create</code>로 파일 생성을 시도합니다.
그러나, <code>File::create</code> 또한 실패할 수 있기 때문에, 안쪽에 <code>match</code> 구문을 바깥쪽과 마찬가지로 추가할
필요가 있습니다! 파일이 열수 없을 때, 다른 에러 메세지가 출력될 것입니다. 바깥쪽 <code>match</code>의 마지막 갈래는
똑같이 남아서, 파일을 못 찾는 에러 외에 다른 어떤 에러에 대해서도 패닉을 일으킵니다.</p>
<a class="header" href="print.html#에러가-났을-때-패닉을-위한-숏컷-unwrap과-expect" id="에러가-났을-때-패닉을-위한-숏컷-unwrap과-expect"><h3>에러가 났을 때 패닉을 위한 숏컷: <code>unwrap</code>과 <code>expect</code></h3></a>
<p><code>match</code>의 사용은 충분히 잘 동작하지만, 살짝 장황하기도 하고 의도를 항상 잘 전달하는 것도 아닙니다.
<code>Result&lt;T, E&gt;</code> 타입은 다양한 것을 하기 위해 정의된 수많은 헬퍼 메소드를 가지고 있습니다. 그 중 하나인
<code>unwrap</code> 이라 부르는 메소드는 Listing 9-3에서 작성한 <code>match</code> 구문과 비슷한구현을 한 숏컷
메소드입니다. 만일 <code>Result</code> 값이 <code>Ok</code> variant라면, <code>unwrap</code>은 <code>Ok</code> 내의 값을 반환할 것입니다.
만일 <code>Result</code>가 <code>Err</code> variant라면, <code>unwrap</code>은 우리를 위해 <code>panic!</code> 매크로를 호출할 것입니다.</p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<p><em>hello.txt</em> 파일이 없는 상태에서 이 코드를 실행시키면, <code>unwrap</code> 메소드에 의한 <code>panic!</code>
호출로부터의 에러 메세지를 보게 될 것입니다:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
/stable-dist-rustc/build/src/libcore/result.rs:868
</code></pre>
<p>또한 <code>unwrap</code>과 유사하면서 우리가 <code>panic!</code> 에러 메세지를 선택할 수 있게 해주는 또다른 메소드인
<code>expect</code>도 있습니다. <code>unwrap</code>대신 <code>expect</code>를 이용하고 좋은 에러 메세지를 제공하는 것은 여러분의
의도를 전달해주고 패닉의 근원을 추적하는 걸 쉽게 해 줄수 있습니다. <code>expect</code>의 문법은 아래와 같이
생겼습니다:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
}
</code></pre></pre>
<p><code>expect</code>는 <code>unwrap</code>과 같은 식으로 사용됩니다: 파일 핸들을 리턴하거나 <code>panic!</code> 매크로를 호출하는
것이죠. <code>expect</code>가 <code>panic!</code> 호출에 사용하는 에러 메세지는 <code>unwrap</code>이 사용하는 기본 <code>panic!</code>
메세지 대신 <code>expect</code>에 넘기는 파라미터로 설정될 것입니다. 아래에 어떻게 생겼는지에 대한 예가 있습니다:</p>
<pre><code class="language-text">thread 'main' panicked at 'Failed to open hello.txt: Error { repr: Os { code:
2, message: &quot;No such file or directory&quot; } }',
/stable-dist-rustc/build/src/libcore/result.rs:868
</code></pre>
<a class="header" href="print.html#에러-전파하기" id="에러-전파하기"><h3>에러 전파하기</h3></a>
<p>실패할지도 모르는 무언가를 호출하는 구현을 가진 함수를 작성할때, 이 함수 내에서 에러를 처리하는 대신,
호출자가 에러를 알게 하여 그쪽에서 어떻게 할지 결정하도록 할 수 있습니다. 이는 에러 <em>전파하기</em>로 알려져
있으며, 에러가 어떻게 처리해야 좋을지 좌우해야 할 상황에서, 여러분의 코드 내용 내에서 이용 가능한 것들보다
더 많은 정보와 로직을 가지고 있을 수도 있는 호출하는 코드쪽에 더 많은 제어권을 줍니다.</p>
<p>예를 들면, Listing 9-5는 파일로부터 사용자 이름을 읽는 함수를 작성한 것입니다. 만일 파일이 존재하지
않거나 읽을 수 없다면, 이 함수는 호출하는 코드쪽으로 해당 에러를 반환할 것입니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 9-5: <code>match</code>를 이용하여 호출 코드 쪽으로 에러를 반환하는 함수
</span></p>
<p>함수의 반환 타입부터 먼저 살펴봅시다: <code>Result&lt;String, io::Error&gt;</code>. 이는 함수가 <code>Result&lt;T, E&gt;</code>
타입의 값을 반환하는데 제네릭 파라미터 <code>T</code>는 구체적 타입(concrete type)인 <code>String</code>로 채워져 있고,
제네릭 타입 <code>E</code>는 구체적 타입인 <code>io::Error</code>로 채워져 있습니다. 만일 이 함수가 어떤 문제 없이 성공하면,
함수의 호출자는 <code>String</code>을 담은 값을 받을 것입니다 - 이 함수가 파일로부터 읽어들인 사용자 이름이겠지요.
만일 어떤 문제가 발생한다면, 함수의 호출자는 문제가 무엇이었는지에 대한 더 많은 정보를 담고 있는
<code>io::Error</code>의 인스턴스를 담은 <code>Err</code> 값을 받을 것입니다. 이 함수의 반환 타입으로서 <code>io::Error</code>를
선택했는데, 그 이유는 우리가 이 함수 내부에서 호출하고 있는 실패 가능한 연산 두 가지가 모두 이 타입의
에러 값을 반환하기 때문입니다: <code>File::open</code> 함수와 <code>read_to_string</code> 메소드 말이죠.</p>
<p>함수의 본체는 <code>File::open</code> 함수를 호출하면서 시작합니다. 그 다음에는 Listing 9-3에서 본 <code>match</code>와
유사한 식으로 <code>match</code>을 이용해서 <code>Result</code> 값을 처리하는데, <code>Err</code> 경우에 <code>panic!</code>을 호출하는 대신
이 함수를 일찍 끝내고 <code>File::open</code>으로부터의 에러 값을 마치 이 함수의 에러 값인것처럼 호출자에게
전달합니다. 만일 <code>File::open</code>이 성공하면, 파일 핸들을 <code>f</code>에 저장하고 계속합니다.</p>
<p>그 뒤 변수 <code>s</code>에 새로운 <code>String</code>을 생성하고 파일의 콘텐츠를 읽어 <code>s</code>에 넣기 위해 <code>f</code>에 있는
파일 핸들의 <code>read_to_string</code> 메소드를 호출합니다. <code>File::open</code>가 성공하더라도 <code>read_to_string</code>
메소드가 실패할 수 있기 때문에 이 함수 또한 <code>Result</code>를 반환합니다. 따라서 이 <code>Result</code>를 처리하기
위해서 또다른 <code>match</code>가 필요합니다: 만일 <code>read_to_string</code>이 성공하면, 우리의 함수가 성공한
것이고, 이제 <code>s</code> 안에 있는 파일로부터 읽어들인 사용자 이름을 <code>Ok</code>에 싸서 반환합니다. 만일
<code>read_to_string</code>이 실패하면, <code>File::open</code>의 반환값을 처리했던 <code>match</code>에서 에러값을
반환하는 것과 같은 방식으로 에러 값을 반환합니다. 하지만 여기서는 명시적으로 <code>return</code>이라 말할 필요는
없는데, 그 이유는 이 함수의 마지막 표현식이기 때문입니다.</p>
<p>그러면 이 코드를 호출하는 코드는 사용자 이름을 담은 <code>Ok</code> 값 혹은 <code>io::Error</code>를 담은 <code>Err</code> 값을
얻는 처리를 하게 될 것입니다. 호출자가 이 값을을 가지고 어떤 일을 할 것인지 우리는 알지 못합니다.
만일 그들이 <code>Err</code> 값을 얻었다면, 예를 들면 <code>panic!</code>을 호출하여 프로그램을 종료시키는 선택을 할
수도 있고, 기본 사용자 이름을 사용할 수도 있으며, 혹은 파일이 아닌 다른 어딘가에서 사용자 이름을
찾을 수도 있습니다. 호출자가 정확히 어떤 것을 시도하려 하는지에 대한 충분한 정보가 없기 때문에,
우리는 모든 성공 혹은 에러 정보를 위로 전파하여 호출자가 그들에 맞는 처리를 하도록 합니다.</p>
<p>러스트에서 에러를 전파하는 패턴은 너무 흔하여 이를 더 쉽게 해주는 전용 문법이 있습니다: 바로 <code>?</code> 입니다.</p>
<a class="header" href="print.html#에러를-전파하기-위한-숏컷-" id="에러를-전파하기-위한-숏컷-"><h3>에러를 전파하기 위한 숏컷: <code>?</code></h3></a>
<p>Listing 9-6은 Listing 9-5과 같은 기능을 가진 <code>read_username_from_file</code>의 구현을 보여주는데,
다만 이 구현은 물음표 연산자를 이용하고 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
#}</code></pre></pre>
<p><span class="caption">Listing 9-6: <code>?</code>를 이용하여 에러를 호출 코드쪽으로 반환하는 함수</span></p>
<p><code>Result</code> 값 뒤의 <code>?</code>는 Listing 9-5에서 <code>Result</code> 값을 다루기 위해 정의했던 <code>match</code> 표현식과
정확히 같은 방식으로 동작하게끔 정의되어 있습니다. 만일 <code>Result</code>의 값이 <code>Ok</code>라면, <code>Ok</code> 내의 값이
이 표현식으로부터 얻어지고 프로그램이 계속됩니다. 만일 값이 <code>Err</code>라면, 우리가 <code>return</code> 키워드를
사용하여 에러 값을 호출자에게 전파하는 것과 같이 전체 함수로부터 <code>Err</code> 내의 값이 반환될 것입니다.</p>
<p>Listing 9-6의 내용에서, <code>File::open</code> 호출 부분의 끝에 있는 <code>?</code>는 <code>Ok</code>내의 값을 변수 <code>f</code>에게
반환해줄 것입니다. 만일 에러가 발생하면 <code>?</code>는 전체 함수로부터 일찍 빠져나와 호출자에게 어떤 <code>Err</code> 값을
줄 것입니다. <code>read_to_string</code> 호출의 끝부분에 있는 <code>?</code>도 같은 것이 적용되어 있습니다.</p>
<p><code>?</code>는 많은 수의 보일러플레이트(boilerplate)를 제거해주고 이 함수의 구현을 더 단순하게 만들어 줍니다.
심지어는 <code>?</code> 뒤에 바로 메소드 호출을 연결하는 식으로 이 코드를 더 줄일 수도 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
#}</code></pre></pre>
<p>새로운 <code>String</code>을 만들어 <code>s</code>에 넣는 부분을 함수의 시작 부분으로 옮겼습니다; 이 부분은 달라진 것이
없습니다. <code>f</code> 변수를 만드는 대신, <code>File::open(&quot;hello.txt&quot;)?</code>의 결과 바로 뒤에
<code>read_to_string</code>의 호출을 연결시켰습니다. <code>read_to_string</code> 호출의 끝에는 여전히 <code>?</code>가
남아있고, <code>File::open</code>과 <code>read_to_string</code>이 모두 에러를 반환하지 않고 성공할 때
<code>s</code> 안의 사용자 이름을 담은 <code>Ok</code>를 여전히 반환합니다. 함수의 기능 또한 Lsting 9-5와
Listing 9-6의 것과 동일하고, 다만 작성하기에 더 인체공학적인 방법이라는 차이만 있을 뿐입니다.</p>
<a class="header" href="print.html#는-result를-반환하는-함수에서만-사용될-수-있습니다" id="는-result를-반환하는-함수에서만-사용될-수-있습니다"><h3><code>?</code>는 <code>Result</code>를 반환하는 함수에서만 사용될 수 있습니다</h3></a>
<p><code>?</code>는 <code>Result</code> 타입을 반환하는 함수에서만 사용이 가능한데, 이것이 Listing 9-5에 정의된 <code>match</code>
표현식과 정확히 동일한 방식으로 동작하도록 정의되어 있기 때문입니다. <code>Result</code> 반환 타입을 요구하는
<code>match</code> 부분은 <code>return Err(e)</code>이며, 따라서 함수의 반환 타입은 반드시 이 <code>return</code>과 호환 가능한
<code>Result</code>가 되어야 합니다.</p>
<p><code>main</code>의 반환 타입이 <code>()</code>라는 것을 상기하면서, 만약 <code>main</code> 함수 내에서 <code>?</code>를 사용하면 어떤일이 생길지
살펴봅시다:</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<!-- NOTE: as of 2016-12-21, the error message when calling `?` in a function
that doesn't return a result is STILL confusing. Since we want to only explain
`?` now, I've changed the example, but if you try running this code you WON'T
get the error message below.
I'm bugging people to try and get
https://github.com/rust-lang/rust/issues/35946 fixed soon, hopefully before this
chapter gets through copy editing-- at that point I'll make sure to update this
error message. /Carol -->
<p>이걸 컴파일하면, 아래와 같은 에러 메세지가 뜹니다:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt;
  |
3 |     let f = File::open(&quot;hello.txt&quot;)?;
  |             ^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found enum
`std::result::Result`
  |
  = note: expected type `()`
  = note:    found type `std::result::Result&lt;_, _&gt;`
</code></pre>
<p>이 에러는 잘못 매칭된 타입이 있음을 지적합니다: <code>main</code> 함수의 반환 타입은 <code>()</code>인데, <code>?</code>는
<code>Result</code>를 반환할지도 모른다는 것이죠. <code>Result</code>를 반환하지 않는 함수 내에서 여러분이 <code>Result</code>를
반환하는 다른 함수를 호출한다면, 여러분은 이를 처리하는데 있어 <code>?</code>를 이용하여 호출자에게 가능한 에러를
전파하는 대신, <code>match</code> 혹은 <code>Result</code> 메소드 중 하나를 이용할 필요가 있을 것입니다.
(역주: 현재는 좀 더 친절하게 상황을 설명하는 에러 메세지가 나오지만, 맥락은 유사합니다.)</p>
<p><code>panic!</code>을 호출하거나 <code>Result</code>를 반환하는 것의 자세한 부분을 논의했으니, 어떤 경우에 어떤 방법을
사용하는 것이 적합할지를 어떻게 결정하는가에 대한 주제로 돌아갑시다.</p>
<a class="header" href="print.html#panic이냐-panic이-아니냐-그것이-문제로다" id="panic이냐-panic이-아니냐-그것이-문제로다"><h2><code>panic!</code>이냐, <code>panic!</code>이 아니냐, 그것이 문제로다</h2></a>
<p>그러면 언제 <code>panic!</code>을 써야하고 언제 <code>Result</code>를 반환할지 어떻게 결정해야 할까요? 코드가 패닉을
일으킬때는 복구할 방법이 없습니다. 복구 가능한 방법이 있든 혹은 그렇지 않든 여러분은 어떤 에러 상황에
대해 <code>panic!</code>을 호출하는 것을 택할수 있지만, 그렇다면 여러분은 여러분의 코드를 호출하는 사람에게
현 상황은 복구 불가능한 것이라고 결정을 내리는 겁니다. 여러분이 <code>Result</code> 값을 반환하는 선택을 한다면,
호출자에게 결단을 내려주기 보다는 옵션을 제공하는 것입니다. 그들은 그들의 상황에 적합한 방식으로
복구를 시도할 수도 있고, 혹은 현재 상황의 <code>Err</code>은 복구 불가능하다고 사실상 결론을 내려서
<code>panic!</code>을 호출하여 여러분이 만든 복구 가능한 에러를 복구 불가능한 것으로 바꿔놓을 수도 있습니다.
그러므로, 여러분이 실패할지도 모르는 함수를 정의할 때는 <code>Result</code>을 반환하는 것이 기본적으로 좋은
선택입니다.</p>
<p><code>Result</code>를 반환하는 대신 패닉을 일으키는 코드를 작성하는 것이 더 적합한 몇 가지 상황이 있지만,
덜 일반적입니다. 예제, 프로토타입 코드 및 테스트의 경우, 그리고 실패할 리 없는 메소드라는 것을
사람으로서의 여러분이라면 알수 있지만 컴파일러는 이유를 파악할 수 없는 경우들을 보면서 패닉을
일으키는 것이 왜 적합한지를 논의해보고, 라이브러리 코드에 패닉을 추가해야 할지를 어떻게 결정할까에 대한
일반적인 가이드라인을 내림으로서 결론지어 봅시다.</p>
<a class="header" href="print.html#예제-프로토타입-코드-그리고-테스트-패닉을-일으켜도-완전-괜찮습니다" id="예제-프로토타입-코드-그리고-테스트-패닉을-일으켜도-완전-괜찮습니다"><h3>예제, 프로토타입 코드, 그리고 테스트: 패닉을 일으켜도 완전 괜찮습니다</h3></a>
<p>여러분이 어떤 개념을 그려내기 위한 예제를 작성중이라면, 강건한 에러 처리 코드를 예제 안에 넣는 것은
또한 예제를 덜 깨끗하게 만들 수 있습니다. 예제 코드 내에서는 <code>panic!</code>을 일으킬 수 있는 <code>unwrap</code>
같은 메소드를 호출하는 것이 여러분의 어플리케이션이 에러를 처리하고자 하는 방법에 대한 플레이스홀더로서의
의미를 갖는데, 이는 여러분의 코드의 나머지 부분이 어떤 것을 하는지에 따라 달라질 수 있습니다.</p>
<p>비슷한 상황에서, 여러분이 에러를 어떻게 처리할지 결정할 준비가 되기 전에는, <code>unwrap</code>과 <code>expect</code>
메소드가 프로토타이핑을 할때 매우 편리합니다. 이 함수들은 여러분의 코드를 더 강건하게 만들 준비가 되었을
때를 위해서 명확한 표시를 남겨 둡니다.</p>
<p>만일 테스트 내에서 메소드 호출이 실패한다면, 해당 메소드가 테스트 중인 기능이 아니더라도 전체 테스트를
실패시키도록 합니다. <code>panic!</code>은 테스트가 어떻게 실패하는지 표시해주기 때문에, <code>unwrap</code>이나
<code>expect</code>를 호출하는 것은 정확하게 하고자 하는 일과 일치합니다.</p>
<a class="header" href="print.html#컴파일러보다-어려분이-더-많은-정보를-가지고-있을-때" id="컴파일러보다-어려분이-더-많은-정보를-가지고-있을-때"><h3>컴파일러보다 어려분이 더 많은 정보를 가지고 있을 때</h3></a>
<p><code>Result</code>가 <code>Ok</code> 값을 가지고 있을 거라 확신할 다른 논리를 가지고 있지만, 그 논리가 컴파일러에 의해
이해할 수 있는 것이 아닐 때라면, <code>unwrap</code>을 호출하는 것이 또한 적절할 수 있습니다. 여러분은 여전히
처리할 필요가 있는 <code>Result</code> 값을 가지고 있습니다: 여러분의 특정한 상황에서 논리적으로 불가능할지라도,
여러분이 호출하고 있는 연산이 무엇이든간에 일반적으로는 여전히 실패할 가능성이 있습니다. 만일 여러분이
수동적으로 <code>Err</code> variant를 결코 발생시키지 않는 코드를 조사하여 확신할 수 있다면, <code>unwrap</code>을
호출하는 것이 완벽히 허용됩니다. 여기 예제가 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::net::IpAddr;

let home = &quot;127.0.0.1&quot;.parse::&lt;IpAddr&gt;().unwrap();
#}</code></pre></pre>
<p>여기서는 하드코딩된 스트링을 파싱하여 <code>IpAddr</code> 인스턴스를 만드는 중입니다. 우리는 <code>127.0.0.1</code>이
유효한 IP 주소임을 볼 수 있으므로, 여기서 <code>unwrap</code>을 사용하는 것은 허용됩니다. 그러나, 하드코딩된
유효한 스트링을 갖고 있다는 것이 <code>parse</code> 메소드의 반환 타입을 변경해주지는 않습니다: 우리는 여전히
<code>Result</code> 값을 갖게되고, 컴파일러는 마치 <code>Err</code> variant가 나올 가능성이 여전히 있는 것처럼
우리가 <code>Result</code>를 처리하도록 할 것인데, 그 이유는 이 스트링이 항상 유효한 IP 주소라는 것을
알 수 있을만큼 컴파일러가 똑똑하지는 않기 때문입니다. 만일 IP 주소 스트링이 프로그램 내에 하드코딩된
것 대신 사용자로부터 입력되었다면, 그래서 실패할 가능성이 <em>생겼다면</em>, 우리는 대신 더 강건한 방식으로
<code>Result</code>를 처리할 필요가 분명히 있습니다.</p>
<a class="header" href="print.html#에러-처리를-위한-가이드라인" id="에러-처리를-위한-가이드라인"><h3>에러 처리를 위한 가이드라인</h3></a>
<p>여러분이 결국 나쁜 상태에 처하게 될 가능성이 있을 때는 여러분의 코드에 <code>panic!</code>을 넣는 것이
바람직한데 - 이 글에서 말하는 나쁜 상태란 어떤 가정, 보장, 계약, 혹은 불변성이 깨질 때를 뜻하는
것으로, 이를테면 유효하지 않은 값이나 모순되는 값, 혹은 찾을 수 없는 값이 여러분의 코드를 통과할
경우를 말합니다 - 아래에 쓰여진 상황중 하나 혹은 그 이상일 경우라면 말이죠:</p>
<ul>
<li>이 나쁜 상태란 것이 가끔 벌어질 것으로 <em>예상되는</em> 무언가가 아닙니다</li>
<li>그 시점 이후의 코드는 이 나쁜 상태에 있지 않아야만 할 필요가 있습니다</li>
<li>여러분이 사용하고 있는 타입 내에 이 정보를 집어 넣을만한 뾰족한 수가 없습니다</li>
</ul>
<p>만일 어떤 사람이 여러분의 코드를 호출하고 타당하지 않은 값을 집어넣었다면, <code>panic!</code>을 써서 여러분의
라이브러리를 사용하고 있는 사람에게 그들의 코드 내의 버그를 알려서 개발하는 동안 이를 고칠 수 있게끔
하는 것이 최선책일 수도 있습니다. 비슷한 식으로, 만일 여러분의 제어권을 벗어난 외부 코드를 호출하고
있고, 이것이 여러분이 고칠 방법이 없는 유효하지 않은 상태를 반환한다면, <code>panic!</code>이 종종 적합합니다.</p>
<p>나쁜 상태에 도달했지만, 여러분이 얼마나 코드를 잘 작성했던 간에 일어날 것으로 예상될 때라면 <code>panic!</code>을
호출하는 것보다 <code>Result</code>를 반환하는 것이 여전히 더 적합합니다. 이에 대한 예는 기형적인 데이터가 주어지는
파서나, 속도 제한에 달했음을 나타내는 상태를 반환하는 HTTP 요청 등을 포함합니다. 이러한 경우, 여러분은
이러한 나쁜 상태를 위로 전파하여 위해 호출자가 그 문제를 어떻게 처리할지를 결정할 수 있도록 하기 위해서
<code>Result</code>를 반환하는 방식으로 실패가 예상 가능한 것임을 알려줘야 합니다. <code>panic!</code>에 빠지는 것은
이러한 경우를 처리하는 최선의 방식이 아닐 것입니다.</p>
<p>여러분의 코드가 어떤 값에 대해 연산을 수행할 때, 여러분의 코드는 해당 값이 유효한지를 먼저 검사하고,
만일 그렇지 않다면 <code>panic!</code>을 호출해야 합니다. 이는 주로 안전상의 이유를 위한 것입니다: 유효하지
않은 데이터 상에서 어떤 연산을 시도하는 것은 여러분의 코드를 취약점에 노출시킬 수 있습니다. 이는
여러분이 범위를 벗어난 배열 접근을 시도했을 경우 표준 라이브러리가 <code>panic!</code>을 호출하는 주된 이유입니다:
현제의 데이터 구조가 소유하지 않은 메모리를 접근 시도하는 것은 흔한 보안 문제입니다. 함수는 종종
<em>계약</em>을 갖고 있습니다: 입력이 특정 요구사항을 만족시킬 경우에만 함수의 행동이 보장됩니다. 이 계약을
위반했을 때 패닉에 빠지는 것은 사리에 맞는데, 그 이유는 계약 위반이 언제나 호출자 쪽의 버그임을 나타내고,
이는 호출자가 명시적으로 처리하도록 하는 종류의 버그가 아니기 때문입니다. 사실, 호출하는 쪽의 코드가
복구시킬 합리적인 방법은 없습니다: 호출하는 <em>프로그래머</em>는 그 코드를 고칠 필요가 있습니다. 함수에 대한
계약은, 특히 계약 위반이 패닉의 원인이 될 때는, 그 함수에 대한 API 문서에 설명되어야 합니다.</p>
<p>하지만 여러분의 모든 함수들 내에서 수많은 에러 검사를 한다는 것은 장황하고 짜증날 것입니다. 다행스럽게도,
러스트의 타입 시스템이 (그리고 컴파일러가 하는 타입 검사 기능이) 이러분을 위해 수많은 검사를 해줄 수
있습니다. 여러분의 함수가 특정한 타입을 파라미터로 갖고 있다면, 여러분이 유효한 값을 갖는다는 것을
컴파일러가 이미 보장했음을 아는 상태로 여러분의 코드 로직을 진행할 수 있습니다. 예를 들면, 만약
여러분이 <code>Option</code>이 아닌 어떤 타입을 갖고 있다면, 여러분의 프로그램은 <em>아무것도 아닌 것</em>이 아닌
<em>무언가</em>를 갖고 있음을 예측합니다. 그러면 여러분의 코드는 <code>Some</code>과 <code>None</code> variant에 대한 두
경우를 처리하지 않아도 되며, 분명히 값을 가지고 있는 하나의 경우만 있을 것입니다. 여러분의 함수에
아무것도 넘기지 않는 시도를 하는 코드는 컴파일 조차 되지 않을 것이고, 따라서 여러분의 함수는
그러한 경우에 대해서 런타임에 검사하지 않아도 됩니다. 또다른 예로는 <code>u32</code>와 같은 부호없는 정수를
이용하는 것이 있는데, 이는 파라미터가 절대 음수가 아님을 보장합니다.</p>
<a class="header" href="print.html#유효성을-위한-커스텀-타입-생성하기" id="유효성을-위한-커스텀-타입-생성하기"><h3>유효성을 위한 커스텀 타입 생성하기</h3></a>
<p>러스트의 타입 시스템을 이용하여 유효한 값을 보장하는 아이디어에서 한발 더 나가서, 유효성을 위한
커스텀 타입을 생성하는 것을 살펴봅시다. 2장의 추리 게임을 상기해 보시면, 우리의 코드는 사용자에게
1부터 100사이의 숫자를 추측하도록 요청했었죠. 우리는 실제로는 사용자의 추측값이 우리의 비밀 숫자와
비교하기 전에 해당 값이 유효한지 결코 확인하지 않았고, 오직 양수임을 확인했습니다. 이 경우, 결과는
매우 끔찍하지는 않았습니다: “Too high”나 “Too low”라고 표시했던 출력은 여전히 맞을 것입니다.
하지만 사용자에게 유효한 추측값을 안내해주고, 사용자가 예를 들어 글자를 입력했을 때에 비해 사용자가
범위 밖의 값을 추측했을 때 다른 동작을 하는 것은 쓸모있는 향상일 것입니다.</p>
<p>이를 위한 한가지 방법은 <code>u32</code> 대신 <code>i32</code>로서 추측값을 파싱하여 음수가 입력될 가능성을 허용하고,
숫자가 범위 내에 있는지에 대한 검사를 추가하는 것일테지요:</p>
<pre><code class="language-rust ignore">loop {
    // snip

    let guess: i32 = match guess.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; continue,
    };

    if guess &lt; 1 || guess &gt; 100 {
        println!(&quot;The secret number will be between 1 and 100.&quot;);
        continue;
    }

    match guess.cmp(&amp;secret_number) {
    // snip
}
</code></pre>
<p><code>if</code> 표현식은 우리의 값이 범위 밖에 있는지 검사하고, 사용자에게 문제점을 말해주고, <code>continue</code>를
호출하여 루프의 다음 반복을 시작하고 다른 추측값을 요청해줍니다. <code>if</code> 표현식 이후에는, <code>guess</code>가
1과 100 사이의 값이라는 것을 아는 상태에서 <code>guess</code>와 비밀 숫자의 비교를 진행할 수 있습니다.</p>
<p>하지만, 이는 이상적인 해결책이 아닙니다: 만일 프로그램이 오직 1과 100 사이의 값에서만 동작하는 것이
전적으로 중요하고, 많은 함수가 이러한 요구사항을 가지고 있다면, 모든 함수 내에서 이렇게 검사를 하는 것은
지루할 것입니다. (그리고 잠재적으로 성능에 영향을 줄 것입니다.)</p>
<p>대신, 우리는 새로운 타입을 만들어서, 유효성 확인을 모든 곳에서 반복하는 것보다는 차라리 그 타입의
인스턴스를 생성하는 함수 내에 유효성 확인을 넣을 수 있습니다. 이 방식에서, 함수가 그 시그니처 내에서
새로운 타입을 이용하고 받은 값을 자신있게 사용하는 것은 안전합니다. Listing 9-8은 <code>new</code> 함수가
1과 100 사이의 값을 받았을 때에만 인스턴스를 생성하는 <code>Guess</code> 타입을 정의하는 한가지 방법을
보여줍니다:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }

    pub fn value(&amp;self) -&gt; u32 {
        self.value
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 9-8: 1과 100 사이의 값일 때만 계속되는 <code>Guess</code> 타입
</span></p>
<p>먼저 <code>u32</code>를 갖는 <code>value</code>라는 이름의 항목을 가진 <code>Guess</code>라는 이름의 구조체를 선언하였습니다.
이것이 숫자가 저장될 곳입니다.</p>
<p>그런뒤 <code>Guess</code> 값의 인스턴스를 생성하는 <code>new</code>라는 이름의 연관 함수를 구현하였습니다.
<code>new</code> 함수는 <code>u32</code> 타입의 값인 <code>value</code>를 파라미터를 갖고 <code>Guess</code>를 반환하도록 정의
되었습니다. <code>new</code> 함수의 본체에 있는 코드는 <code>value</code>가 1부터 100 사이의 값인지 확인하는
테스트를 합니다. 만일 <code>value</code>가 이 테스트에 통과하지 못하면 <code>panic!</code>을 호출하며,
이는 이 코드를 호출하는 프로그래머에게 고쳐야할 버그가 있음을 알려주는데, 범위 밖의 <code>value</code>를
가지고 <code>Guess</code>를 생성하는 것은 <code>Guess::new</code>가 필요로 하는 계약을 위반하기 때문입니다.
<code>Guess::new</code>가 패닉을 일으킬 수도 있는 조건은 공개된 API 문서 내에 다뤄져야 합니다;
여러분이 만드는 API 문서 내에서 <code>panic!</code>의 가능성을 가리키는 것에 대한 문서 관례는 14장에서
다룰 것입니다. 만일 <code>value</code>가 테스트를 통과한다면, <code>value</code> 항목을 <code>value</code> 파라미터로
설정한 새로운 <code>Guess</code>를 생성하여 이 <code>Guess</code>를 반환합니다.</p>
<p>다음으로, <code>self</code>를 빌리고, 파라미터를 갖지 않으며, <code>u32</code>를 반환하는 <code>value</code>라는 이름의 메소드를
구현했습니다. 이러한 종류 메소드를 종종 <em>게터(getter)</em> 라고 부르는데, 그 이유는 이런 함수의 목적이
객체의 항목으로부터 어떤 데이터를 가져와서 이를 반환하는 것이기 때문입니다. 이 공개 메소드는 <code>Guess</code>
구조체의 <code>value</code> 항목이 비공개이기 때문에 필요합니다. <code>value</code> 항목이 비공개라서 <code>Guess</code> 구조체를
이용하는 코드가 <code>value</code>를 직접 설정하지 못하도록 하는 것은 중요합니다: 모듈 밖의 호출자는 <em>반드시</em>
<code>Guess::new</code> 함수를 이용하여 새로운 <code>Guess</code>의 인스턴스를 만들어야 하는데, 이는 <code>Guess</code>가
<code>Guess::new</code> 함수의 조건들을 확인한 적이 없는 <code>value</code>를 갖는 방법이 없음을 보장합니다.</p>
<p>그러면 파라미터를 가지고 있거나 오직 1에서 100 사이의 숫자를 반환하는 함수는 <code>u32</code> 보다는 <code>Guess</code>를
얻거나 반환하는 시그니처로 선언되고, 더 이상의 확인이 필요치 않을 것입니다.</p>
<a class="header" href="print.html#정리-3" id="정리-3"><h2>정리</h2></a>
<p>러스트의 에러 처리 기능은 여러분이 더 강건한 코드를 작성하는데 도움을 주도록 설계되었습니다.
<code>panic!</code> 매크로는 여러분의 프로그램이 처리 불가능한 상태에 놓어있음에 대한 신호를 주고, 여러분이
유효하지 않거나 잘못된 값으로 계속 진행하는 시도를 하는 대신 실행을 멈추게끔 해줍니다. <code>Result</code>
열거형은 러스트의 타입 시스템을 이용하여 여러분의 코드가 복구할 수 있는 방법으로 연산이 실패할 수도
있음을 알려줍니다. 또한 <code>Result</code>를 이용하면 여러분의 코드를 호출하는 코드에게 잠재적인 성공이나
실패를 처리해야할 필요가 있음을 알려줄 수 있습니다. <code>panic!</code>과 <code>Result</code>를 적합한 상황에서
사용하는 것은 여러분의 코드가 불가피한 문제에 직면했을 때도 더 신뢰할 수 있도록 해줄 것입니다.</p>
<p>이제 표준 라이브러리가 <code>Option</code>과 <code>Result</code> 열거형을 가지고 제네릭을 사용하는 유용한 방식들을
보았으니, 제네릭이 어떤 식으로 동작하고 여러분의 코드에 어떻게 이용할 수 있는지에 대해 이야기해
보겠습니다.</p>
<a class="header" href="print.html#generic-types-traits-and-lifetimes" id="generic-types-traits-and-lifetimes"><h1>Generic Types, Traits, and Lifetimes</h1></a>
<p>Every programming language has tools to deal effectively with duplication of
concepts; in Rust, one of those tools is <em>generics</em>. Generics are abstract
stand-ins for concrete types or other properties. When we're writing and
compiling the code we can express properties of generics, such as their
behavior or how they relate to other generics, without needing to know what
will actually be in their place.</p>
<p>In the same way that a function takes parameters whose value we don't know in
order to write code once that will be run on multiple concrete values, we can
write functions that take parameters of some generic type instead of a concrete
type like <code>i32</code> or <code>String</code>. We've already used generics in Chapter 6 with
<code>Option&lt;T&gt;</code>, Chapter 8 with <code>Vec&lt;T&gt;</code> and <code>HashMap&lt;K, V&gt;</code>, and Chapter 9 with
<code>Result&lt;T, E&gt;</code>. In this chapter, we'll explore how to define our own types,
functions, and methods with generics!</p>
<p>First, we're going to review the mechanics of extracting a function that
reduces code duplication. Then we'll use the same mechanics to make a generic
function out of two functions that only differ in the types of their
parameters. We'll go over using generic types in struct and enum definitions
too.</p>
<p>After that, we'll discuss <em>traits</em>, which are a way to define behavior in a
generic way. Traits can be combined with generic types in order to constrain a
generic type to those types that have a particular behavior, rather than any
type at all.</p>
<p>Finally, we'll discuss <em>lifetimes</em>, which are a kind of generic that let us
give the compiler information about how references are related to each other.
Lifetimes are the feature in Rust that allow us to borrow values in many
situations and still have the compiler check that references will be valid.</p>
<a class="header" href="print.html#removing-duplication-by-extracting-a-function" id="removing-duplication-by-extracting-a-function"><h2>Removing Duplication by Extracting a Function</h2></a>
<p>Before getting into generics syntax, let's first review a technique for dealing
with duplication that doesn't use generic types: extracting a function. Once
that's fresh in our minds, we'll use the same mechanics with generics to
extract a generic function! In the same way that you recognize duplicated code
to extract into a function, you'll start to recognize duplicated code that can
use generics.</p>
<p>Consider a small program that finds the largest number in a list, shown in
Listing 10-1:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let numbers = vec![34, 50, 25, 100, 65];

    let mut largest = numbers[0];

    for number in numbers {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
#  assert_eq!(largest, 100);
}
</code></pre></pre>
<p><span class="caption">Listing 10-1: Code to find the largest number in a list
of numbers</span></p>
<p>This code takes a list of integers, stored here in the variable <code>numbers</code>. It
puts the first item in the list in a variable named <code>largest</code>. Then it iterates
through all the numbers in the list, and if the current value is greater than
the number stored in <code>largest</code>, it replaces the value in <code>largest</code>. If the
current value is smaller than the largest value seen so far, <code>largest</code> is not
changed. When all the items in the list have been considered, <code>largest</code> will
hold the largest value, which in this case is 100.</p>
<p>If we needed to find the largest number in two different lists of numbers, we
could duplicate the code in Listing 10-1 and have the same logic exist in two
places in the program, as in Listing 10-2:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let numbers = vec![34, 50, 25, 100, 65];

    let mut largest = numbers[0];

    for number in numbers {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);

    let numbers = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = numbers[0];

    for number in numbers {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre></pre>
<p><span class="caption">Listing 10-2: Code to find the largest number in <em>two</em>
lists of numbers</span></p>
<p>While this code works, duplicating code is tedious and error-prone, and means
we have multiple places to update the logic if we need to change it.</p>
<!-- Are we safe assuming the reader will be familiar with the term
"abstraction" in this context, or do we want to give a brief definition? -->
<!-- Yes, our audience will be familiar with this term. /Carol -->
<p>To eliminate this duplication, we can create an abstraction, which in this case
will be in the form of a function that operates on any list of integers given
to the function in a parameter. This will increase the clarity of our code and
let us communicate and reason about the concept of finding the largest number
in a list independently of the specific places this concept is used.</p>
<p>In the program in Listing 10-3, we've extracted the code that finds the largest
number into a function named <code>largest</code>. This program can find the largest
number in two different lists of numbers, but the code from Listing 10-1 only
exists in one spot:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let numbers = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;numbers);
    println!(&quot;The largest number is {}&quot;, result);
#    assert_eq!(result, 100);

    let numbers = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;numbers);
    println!(&quot;The largest number is {}&quot;, result);
#    assert_eq!(result, 6000);
}
</code></pre></pre>
<p><span class="caption">Listing 10-3: Abstracted code to find the largest number
in two lists</span></p>
<p>The function has a parameter, <code>list</code>, which represents any concrete slice of
<code>i32</code> values that we might pass into the function. The code in the function
definition operates on the <code>list</code> representation of any <code>&amp;[i32]</code>. When we call
the <code>largest</code> function, the code actually runs on the specific values that we
pass in.</p>
<p>The mechanics we went through to get from Listing 10-2 to Listing 10-3 were
these steps:</p>
<ol>
<li>We noticed there was duplicate code.</li>
<li>We extracted the duplicate code into the body of the function, and specified
the inputs and return values of that code in the function signature.</li>
<li>We replaced the two concrete places that had the duplicated code to call the
function instead.</li>
</ol>
<p>We can use these same steps with generics to reduce code duplication in
different ways in different scenarios. In the same way that the function body
is now operating on an abstract <code>list</code> instead of concrete values, code using
generics will operate on abstract types. The concepts powering generics are the
same concepts you already know that power functions, just applied in different
ways.</p>
<p>What if we had two functions, one that found the largest item in a slice of
<code>i32</code> values and one that found the largest item in a slice of <code>char</code> values?
How would we get rid of that duplication? Let's find out!</p>
<a class="header" href="print.html#generic-data-types" id="generic-data-types"><h2>Generic Data Types</h2></a>
<p>Using generics where we usually place types, like in function signatures or
structs, lets us create definitions that we can use for many different concrete
data types. Let's take a look at how to define functions, structs, enums, and
methods using generics, and at the end of this section we'll discuss the
performance of code using generics.</p>
<a class="header" href="print.html#using-generic-data-types-in-function-definitions" id="using-generic-data-types-in-function-definitions"><h3>Using Generic Data Types in Function Definitions</h3></a>
<p>We can define functions that use generics in the signature of the function
where the data types of the parameters and return value go. In this way, the
code we write can be more flexible and provide more functionality to callers of
our function, while not introducing code duplication.</p>
<p>Continuing with our <code>largest</code> function, Listing 10-4 shows two functions
providing the same functionality to find the largest value in a slice. The
first function is the one we extracted in Listing 10-3 that finds the largest
<code>i32</code> in a slice. The second function finds the largest <code>char</code> in a slice:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let numbers = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;numbers);
    println!(&quot;The largest number is {}&quot;, result);
#    assert_eq!(result, 100);

    let chars = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;chars);
    println!(&quot;The largest char is {}&quot;, result);
#    assert_eq!(result, 'y');
}
</code></pre></pre>
<p><span class="caption">Listing 10-4: Two functions that differ only in their
names and the types in their signatures</span></p>
<p>Here, the functions <code>largest_i32</code> and <code>largest_char</code> have the exact same body,
so it would be nice if we could turn these two functions into one and get rid
of the duplication. Luckily, we can do that by introducing a generic type
parameter!</p>
<p>To parameterize the types in the signature of the one function we're going to
define, we need to create a name for the type parameter, just like how we give
names for the value parameters to a function. We're going to choose the name
<code>T</code>. Any identifier can be used as a type parameter name, but we're choosing
<code>T</code> because Rust's type naming convention is CamelCase. Generic type parameter
names also tend to be short by convention, often just one letter. Short for
&quot;type&quot;, <code>T</code> is the default choice of most Rust programmers.</p>
<p>When we use a parameter in the body of the function, we have to declare the
parameter in the signature so that the compiler knows what that name in the
body means. Similarly, when we use a type parameter name in a function
signature, we have to declare the type parameter name before we use it. Type
name declarations go in angle brackets between the name of the function and the
parameter list.</p>
<p>The function signature of the generic <code>largest</code> function we're going to define
will look like this:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>We would read this as: the function <code>largest</code> is generic over some type <code>T</code>. It
has one parameter named <code>list</code>, and the type of <code>list</code> is a slice of values of
type <code>T</code>. The <code>largest</code> function will return a value of the same type <code>T</code>.</p>
<p>Listing 10-5 shows the unified <code>largest</code> function definition using the generic
data type in its signature, and shows how we'll be able to call <code>largest</code> with
either a slice of <code>i32</code> values or <code>char</code> values. Note that this code won't
compile yet!</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let numbers = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;numbers);
    println!(&quot;The largest number is {}&quot;, result);

    let chars = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;chars);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Listing 10-5: A definition of the <code>largest</code> function that
uses generic type parameters but doesn't compile yet</span></p>
<p>If we try to compile this code right now, we'll get this error:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
  |
5 |         if item &gt; largest {
  |            ^^^^
  |
note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>The note mentions <code>std::cmp::PartialOrd</code>, which is a <em>trait</em>. We're going to
talk about traits in the next section, but briefly, what this error is saying
is that the body of <code>largest</code> won't work for all possible types that <code>T</code> could
be; since we want to compare values of type <code>T</code> in the body, we can only use
types that know how to be ordered. The standard library has defined the trait
<code>std::cmp::PartialOrd</code> that types can implement to enable comparisons. We'll
come back to traits and how to specify that a generic type has a particular
trait in the next section, but let's set this example aside for a moment and
explore other places we can use generic type parameters first.</p>
<!-- Liz: this is the reason we had the topics in the order we did in the first
draft of this chapter; it's hard to do anything interesting with generic types
in functions unless you also know about traits and trait bounds. I think this
ordering could work out okay, though, and keep a stronger thread with the
`longest` function going through the whole chapter, but we do pause with a
not-yet-compiling example here, which I know isn't ideal either. Let us know
what you think. /Carol -->
<a class="header" href="print.html#using-generic-data-types-in-struct-definitions" id="using-generic-data-types-in-struct-definitions"><h3>Using Generic Data Types in Struct Definitions</h3></a>
<p>We can define structs to use a generic type parameter in one or more of the
struct's fields with the <code>&lt;&gt;</code> syntax too. Listing 10-6 shows the definition and
use of a <code>Point</code> struct that can hold <code>x</code> and <code>y</code> coordinate values of any type:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listing 10-6: A <code>Point</code> struct that holds <code>x</code> and <code>y</code>
values of type <code>T</code></span></p>
<p>The syntax is similar to using generics in function definitions. First, we have
to declare the name of the type parameter within angle brackets just after the
name of the struct. Then we can use the generic type in the struct definition
where we would specify concrete data types.</p>
<p>Note that because we've only used one generic type in the definition of
<code>Point</code>, what we're saying is that the <code>Point</code> struct is generic over some type
<code>T</code>, and the fields <code>x</code> and <code>y</code> are <em>both</em> that same type, whatever it ends up
being. If we try to create an instance of a <code>Point</code> that has values of
different types, as in Listing 10-7, our code won't compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre>
<p><span class="caption">Listing 10-7: The fields <code>x</code> and <code>y</code> must be the same
type because both have the same generic data type <code>T</code></span></p>
<p>If we try to compile this, we'll get the following error:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt;
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integral variable, found
  floating-point variable
  |
  = note: expected type `{integer}`
  = note:    found type `{float}`
</code></pre>
<p>When we assigned the integer value 5 to <code>x</code>, the compiler then knows for this
instance of <code>Point</code> that the generic type <code>T</code> will be an integer. Then when we
specified 4.0 for <code>y</code>, which is defined to have the same type as <code>x</code>, we get a
type mismatch error.</p>
<p>If we wanted to define a <code>Point</code> struct where <code>x</code> and <code>y</code> could have different
types but still have those types be generic, we can use multiple generic type
parameters. In listing 10-8, we've changed the definition of <code>Point</code> to be
generic over types <code>T</code> and <code>U</code>. The field <code>x</code> is of type <code>T</code>, and the field <code>y</code>
is of type <code>U</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listing 10-8: A <code>Point</code> generic over two types so that
<code>x</code> and <code>y</code> may be values of different types</span></p>
<p>Now all of these instances of <code>Point</code> are allowed! You can use as many generic
type parameters in a definition as you want, but using more than a few gets
hard to read and understand. If you get to a point of needing lots of generic
types, it's probably a sign that your code could use some restructuring to be
separated into smaller pieces.</p>
<a class="header" href="print.html#using-generic-data-types-in-enum-definitions" id="using-generic-data-types-in-enum-definitions"><h3>Using Generic Data Types in Enum Definitions</h3></a>
<p>Similarly to structs, enums can be defined to hold generic data types in their
variants. We used the <code>Option&lt;T&gt;</code> enum provided by the standard library in
Chapter 6, and now its definition should make more sense. Let's take another
look:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<p>In other words, <code>Option&lt;T&gt;</code> is an enum generic in type <code>T</code>. It has two
variants: <code>Some</code>, which holds one value of type <code>T</code>, and a <code>None</code> variant that
doesn't hold any value. The standard library only has to have this one
definition to support the creation of values of this enum that have any
concrete type. The idea of &quot;an optional value&quot; is a more abstract concept than
one specific type, and Rust lets us express this abstract concept without lots
of duplication.</p>
<p>Enums can use multiple generic types as well. The definition of the <code>Result</code>
enum that we used in Chapter 9 is one example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p>The <code>Result</code> enum is generic over two types, <code>T</code> and <code>E</code>. <code>Result</code> has two
variants: <code>Ok</code>, which holds a value of type <code>T</code>, and <code>Err</code>, which holds a value
of type <code>E</code>. This definition makes it convenient to use the <code>Result</code> enum
anywhere we have an operation that might succeed (and return a value of some
type <code>T</code>) or fail (and return an error of some type <code>E</code>). Recall Listing 9-2
when we opened a file: in that case, <code>T</code> was filled in with the type
<code>std::fs::File</code> when the file was opened successfully and <code>E</code> was filled in
with the type <code>std::io::Error</code> when there were problems opening the file.</p>
<p>When you recognize situations in your code with multiple struct or enum
definitions that differ only in the types of the values they hold, you can
remove the duplication by using the same process we used with the function
definitions to introduce generic types instead.</p>
<a class="header" href="print.html#using-generic-data-types-in-method-definitions" id="using-generic-data-types-in-method-definitions"><h3>Using Generic Data Types in Method Definitions</h3></a>
<p>Like we did in Chapter 5, we can implement methods on structs and enums that
have generic types in their definitions. Listing 10-9 shows the <code>Point&lt;T&gt;</code>
struct we defined in Listing 10-6. We've then defined a method named <code>x</code> on
<code>Point&lt;T&gt;</code> that returns a reference to the data in the field <code>x</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p><span class="caption">Listing 10-9: Implementing a method named <code>x</code> on the
<code>Point&lt;T&gt;</code> struct that will return a reference to the <code>x</code> field, which is of
type <code>T</code>.</span></p>
<p>Note that we have to declare <code>T</code> just after <code>impl</code>, so that we can use it when
we specify that we're implementing methods on the type <code>Point&lt;T&gt;</code>.</p>
<p>Generic type parameters in a struct definition aren't always the same generic
type parameters you want to use in that struct's method signatures. Listing
10-10 defines a method <code>mixup</code> on the <code>Point&lt;T, U&gt;</code> struct from Listing 10-8.
The method takes another <code>Point</code> as a parameter, which might have different
types than the <code>self</code> <code>Point</code> that we're calling <code>mixup</code> on. The method creates
a new <code>Point</code> instance that has the <code>x</code> value from the <code>self</code> <code>Point</code> (which is
of type <code>T</code>) and the <code>y</code> value from the passed-in <code>Point</code> (which is of type
<code>W</code>):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c'};

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p><span class="caption">Listing 10-10: Methods that use different generic types
than their struct's definition</span></p>
<p>In <code>main</code>, we've defined a <code>Point</code> that has an <code>i32</code> for <code>x</code> (with value <code>5</code>)
and an <code>f64</code> for <code>y</code> (with value <code>10.4</code>). <code>p2</code> is a <code>Point</code> that has a string
slice for <code>x</code> (with value <code>&quot;Hello&quot;</code>) and a <code>char</code> for <code>y</code> (with value <code>c</code>).
Calling <code>mixup</code> on <code>p1</code> with the argument <code>p2</code> gives us <code>p3</code>, which will have
an <code>i32</code> for <code>x</code>, since <code>x</code> came from <code>p1</code>. <code>p3</code> will have a <code>char</code> for <code>y</code>,
since <code>y</code> came from <code>p2</code>. The <code>println!</code> will print <code>p3.x = 5, p3.y = c</code>.</p>
<p>Note that the generic parameters <code>T</code> and <code>U</code> are declared after <code>impl</code>, since
they go with the struct definition. The generic parameters <code>V</code> and <code>W</code> are
declared after <code>fn mixup</code>, since they are only relevant to the method.</p>
<a class="header" href="print.html#performance-of-code-using-generics" id="performance-of-code-using-generics"><h3>Performance of Code Using Generics</h3></a>
<p>You may have been reading this section and wondering if there's a run-time cost
to using generic type parameters. Good news: the way that Rust has implemented
generics means that your code will not run any slower than if you had specified
concrete types instead of generic type parameters!</p>
<p>Rust accomplishes this by performing <em>monomorphization</em> of code using generics
at compile time. Monomorphization is the process of turning generic code into
specific code with the concrete types that are actually used filled in.</p>
<p>What the compiler does is the opposite of the steps that we performed to create
the generic function in Listing 10-5. The compiler looks at all the places that
generic code is called and generates code for the concrete types that the
generic code is called with.</p>
<p>Let's work through an example that uses the standard library's <code>Option</code> enum:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let integer = Some(5);
let float = Some(5.0);
#}</code></pre></pre>
<p>When Rust compiles this code, it will perform monomorphization. The compiler
will read the values that have been passed to <code>Option</code> and see that we have two
kinds of <code>Option&lt;T&gt;</code>: one is <code>i32</code>, and one is <code>f64</code>. As such, it will expand
the generic definition of <code>Option&lt;T&gt;</code> into <code>Option_i32</code> and <code>Option_f64</code>,
thereby replacing the generic definition with the specific ones.</p>
<p>The monomorphized version of our code that the compiler generates looks like
this, with the uses of the generic <code>Option</code> replaced with the specific
definitions created by the compiler:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>We can write the non-duplicated code using generics, and Rust will compile that
into code that specifies the type in each instance. That means we pay no
runtime cost for using generics; when the code runs, it performs just like it
would if we had duplicated each particular definition by hand. The process of
monomorphization is what makes Rust's generics extremely efficient at runtime.</p>
<a class="header" href="print.html#traits-defining-shared-behavior" id="traits-defining-shared-behavior"><h2>Traits: Defining Shared Behavior</h2></a>
<p>Traits allow us to use another kind of abstraction: they let us abstract over
behavior that types can have in common. A <em>trait</em> tells the Rust compiler about
functionality a particular type has and might share with other types. In
situations where we use generic type parameters, we can use <em>trait bounds</em> to
specify, at compile time, that the generic type may be any type that implements
a trait and therefore has the behavior we want to use in that situation.</p>
<blockquote>
<p>Note: <em>Traits</em> are similar to a feature often called 'interfaces' in other
languages, though with some differences.</p>
</blockquote>
<a class="header" href="print.html#defining-a-trait" id="defining-a-trait"><h3>Defining a Trait</h3></a>
<p>The behavior of a type consists of the methods we can call on that type.
Different types share the same behavior if we can call the same methods on all
of those types. Trait definitions are a way to group method signatures together
in order to define a set of behaviors necessary to accomplish some purpose.</p>
<p>For example, say we have multiple structs that hold various kinds and amounts
of text: a <code>NewsArticle</code> struct that holds a news story filed in a particular
place in the world, and a <code>Tweet</code> that can have at most 140 characters in its
content along with metadata like whether it was a retweet or a reply to another
tweet.</p>
<p>We want to make a media aggregator library that can display summaries of data
that might be stored in a <code>NewsArticle</code> or <code>Tweet</code> instance. The behavior we
need each struct to have is that it's able to be summarized, and that we can
ask for that summary by calling a <code>summary</code> method on an instance. Listing
10-11 shows the definition of a <code>Summarizable</code> trait that expresses this
concept:</p>
<p><span class="filename">Filename: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summarizable {
    fn summary(&amp;self) -&gt; String;
}
#}</code></pre></pre>
<p><span class="caption">Listing 10-11: Definition of a <code>Summarizable</code> trait that
consists of the behavior provided by a <code>summary</code> method</span></p>
<p>We declare a trait with the <code>trait</code> keyword, then the trait's name, in this
case <code>Summarizable</code>. Inside curly braces we declare the method signatures that
describe the behaviors that types that implement this trait will need to have,
in this case <code>fn summary(&amp;self) -&gt; String</code>. After the method signature, instead
of providing an implementation within curly braces, we put a semicolon. Each
type that implements this trait must then provide its own custom behavior for
the body of the method, but the compiler will enforce that any type that has
the <code>Summarizable</code> trait will have the method <code>summary</code> defined for it with
this signature exactly.</p>
<p>A trait can have multiple methods in its body, with the method signatures
listed one per line and each line ending in a semicolon.</p>
<a class="header" href="print.html#implementing-a-trait-on-a-type" id="implementing-a-trait-on-a-type"><h3>Implementing a Trait on a Type</h3></a>
<p>Now that we've defined the <code>Summarizable</code> trait, we can implement it on the
types in our media aggregator that we want to have this behavior. Listing 10-12
shows an implementation of the <code>Summarizable</code> trait on the <code>NewsArticle</code> struct
that uses the headline, the author, and the location to create the return value
of <code>summary</code>. For the <code>Tweet</code> struct, we've chosen to define <code>summary</code> as the
username followed by the whole text of the tweet, assuming that tweet content
is already limited to 140 characters.</p>
<p><span class="filename">Filename: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Summarizable {
#     fn summary(&amp;self) -&gt; String;
# }
#
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summarizable for NewsArticle {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summarizable for Tweet {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 10-12: Implementing the <code>Summarizable</code> trait on
the <code>NewsArticle</code> and <code>Tweet</code> types</span></p>
<p>Implementing a trait on a type is similar to implementing methods that aren't
related to a trait. The difference is after <code>impl</code>, we put the trait name that
we want to implement, then say <code>for</code> and the name of the type that we want to
implement the trait for. Within the <code>impl</code> block, we put the method signatures
that the trait definition has defined, but instead of putting a semicolon after
each signature, we put curly braces and fill in the method body with the
specific behavior that we want the methods of the trait to have for the
particular type.</p>
<p>Once we've implemented the trait, we can call the methods on instances of
<code>NewsArticle</code> and <code>Tweet</code> in the same manner that we call methods that aren't
part of a trait:</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summary());
</code></pre>
<p>This will print <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>.</p>
<p>Note that because we've defined the <code>Summarizable</code> trait and the <code>NewsArticle</code>
and <code>Tweet</code> types all in the same <code>lib.rs</code> in Listing 10-12, they're all in the
same scope. If this <code>lib.rs</code> is for a crate we've called <code>aggregator</code>, and
someone else wants to use our crate's functionality plus implement the
<code>Summarizable</code> trait on their <code>WeatherForecast</code> struct, their code would need
to import the <code>Summarizable</code> trait into their scope first before they could
implement it, like in Listing 10-13:</p>
<p><span class="filename">Filename: lib.rs</span></p>
<pre><code class="language-rust ignore">extern crate aggregator;

use aggregator::Summarizable;

struct WeatherForecast {
    high_temp: f64,
    low_temp: f64,
    chance_of_precipitation: f64,
}

impl Summarizable for WeatherForecast {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;The high will be {}, and the low will be {}. The chance of
        precipitation is {}%.&quot;, self.high_temp, self.low_temp,
        self.chance_of_precipitation)
    }
}
</code></pre>
<p><span class="caption">Listing 10-13: Bringing the <code>Summarizable</code> trait from our
<code>aggregator</code> crate into scope in another crate</span></p>
<p>This code also assumes <code>Summarizable</code> is a public trait, which it is because we
put the <code>pub</code> keyword before <code>trait</code> in Listing 10-11.</p>
<p>One restriction to note with trait implementations: we may implement a trait on
a type as long as either the trait or the type are local to our crate. In other
words, we aren't allowed to implement external traits on external types. We
can't implement the <code>Display</code> trait on <code>Vec</code>, for example, since both <code>Display</code>
and <code>Vec</code> are defined in the standard library. We are allowed to implement
standard library traits like <code>Display</code> on a custom type like <code>Tweet</code> as part of
our <code>aggregator</code> crate functionality. We could also implement <code>Summarizable</code> on
<code>Vec</code> in our <code>aggregator</code> crate, since we've defined <code>Summarizable</code> there. This
restriction is part of what's called the <em>orphan rule</em>, which you can look up
if you're interested in type theory. Briefly, it's called the orphan rule
because the parent type is not present. Without this rule, two crates could
implement the same trait for the same type, and the two implementations would
conflict: Rust wouldn't know which implementation to use. Because Rust enforces
the orphan rule, other people's code can't break your code and vice versa.</p>
<a class="header" href="print.html#default-implementations" id="default-implementations"><h3>Default Implementations</h3></a>
<p>Sometimes it's useful to have default behavior for some or all of the methods
in a trait, instead of making every implementation on every type define custom
behavior. When we implement the trait on a particular type, we can choose to
keep or override each method's default behavior.</p>
<p>Listing 10-14 shows how we could have chosen to specify a default string for
the <code>summary</code> method of the <code>Summarize</code> trait instead of only choosing to only
define the method signature like we did in Listing 10-11:</p>
<p><span class="filename">Filename: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summarizable {
    fn summary(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 10-14: Definition of a <code>Summarizable</code> trait with
a default implementation of the <code>summary</code> method</span></p>
<p>If we wanted to use this default implementation to summarize instances of
<code>NewsArticle</code> instead of defining a custom implementation like we did in
Listing 10-12, we would specify an empty <code>impl</code> block:</p>
<pre><code class="language-rust ignore">impl Summarizable for NewsArticle {}
</code></pre>
<p>Even though we're no longer choosing to define the <code>summary</code> method on
<code>NewsArticle</code> directly, since the <code>summary</code> method has a default implementation
and we specified that <code>NewsArticle</code> implements the <code>Summarizable</code> trait, we can
still call the <code>summary</code> method on an instance of <code>NewsArticle</code>:</p>
<pre><code class="language-rust ignore">let article = NewsArticle {
    headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
    location: String::from(&quot;Pittsburgh, PA, USA&quot;),
    author: String::from(&quot;Iceburgh&quot;),
    content: String::from(&quot;The Pittsburgh Penguins once again are the best
    hockey team in the NHL.&quot;),
};

println!(&quot;New article available! {}&quot;, article.summary());
</code></pre>
<p>This code prints <code>New article available! (Read more...)</code>.</p>
<p>Changing the <code>Summarizable</code> trait to have a default implementation for
<code>summary</code> does not require us to change anything about the implementations of
<code>Summarizable</code> on <code>Tweet</code> in Listing 10-12 or <code>WeatherForecast</code> in Listing
10-13: the syntax for overriding a default implementation is exactly the same
as the syntax for implementing a trait method that doesn't have a default
implementation.</p>
<p>Default implementations are allowed to call the other methods in the same
trait, even if those other methods don't have a default implementation. In this
way, a trait can provide a lot of useful functionality and only require
implementers to specify a small part of it. We could choose to have the
<code>Summarizable</code> trait also have an <code>author_summary</code> method whose implementation
is required, then a <code>summary</code> method that has a default implementation that
calls the <code>author_summary</code> method:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summarizable {
    fn author_summary(&amp;self) -&gt; String;

    fn summary(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.author_summary())
    }
}
#}</code></pre></pre>
<p>In order to use this version of <code>Summarizable</code>, we're only required to define
<code>author_summary</code> when we implement the trait on a type:</p>
<pre><code class="language-rust ignore">impl Summarizable for Tweet {
    fn author_summary(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
</code></pre>
<p>Once we define <code>author_summary</code>, we can call <code>summary</code> on instances of the
<code>Tweet</code> struct, and the default implementation of <code>summary</code> will call the
definition of <code>author_summary</code> that we've provided.</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summary());
</code></pre>
<p>This will print <code>1 new tweet: (Read more from @horse_ebooks...)</code>.</p>
<p>Note that it is not possible to call the default implementation from an
overriding implementation.</p>
<a class="header" href="print.html#trait-bounds" id="trait-bounds"><h3>Trait Bounds</h3></a>
<p>Now that we've defined traits and implemented those traits on types, we can use
traits with generic type parameters. We can constrain generic types so that
rather than being any type, the compiler will ensure that the type will be
limited to those types that implement a particular trait and thus have the
behavior that we need the types to have. This is called specifying <em>trait
bounds</em> on a generic type.</p>
<p>For example, in Listing 10-12, we implemented the <code>Summarizable</code> trait on the
types <code>NewsArticle</code> and <code>Tweet</code>. We can define a function <code>notify</code> that calls
the <code>summary</code> method on its parameter <code>item</code>, which is of the generic type <code>T</code>.
To be able to call <code>summary</code> on <code>item</code> without getting an error, we can use
trait bounds on <code>T</code> to specify that <code>item</code> must be of a type that implements
the <code>Summarizable</code> trait:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summarizable&gt;(item: T) {
    println!(&quot;Breaking news! {}&quot;, item.summary());
}
</code></pre>
<p>Trait bounds go with the declaration of the generic type parameter, after a
colon and within the angle brackets. Because of the trait bound on <code>T</code>, we can
call <code>notify</code> and pass in any instance of <code>NewsArticle</code> or <code>Tweet</code>. The
external code from Listing 10-13 that's using our <code>aggregator</code> crate can call
our <code>notify</code> function and pass in an instance of <code>WeatherForecast</code>, since
<code>Summarizable</code> is implemented for <code>WeatherForecast</code> as well. Code that calls
<code>notify</code> with any other type, like a <code>String</code> or an <code>i32</code>, won't compile, since
those types do not implement <code>Summarizable</code>.</p>
<p>We can specify multiple trait bounds on a generic type by using <code>+</code>. If we
needed to be able to use display formatting on the type <code>T</code> in a function as
well as the <code>summary</code> method, we can use the trait bounds <code>T: Summarizable + Display</code>. This means <code>T</code> can be any type that implements both <code>Summarizable</code>
and <code>Display</code>.</p>
<p>For functions that have multiple generic type parameters, each generic has its
own trait bounds. Specifying lots of trait bound information in the angle
brackets between a function's name and its parameter list can get hard to read,
so there's an alternate syntax for specifying trait bounds that lets us move
them to a <code>where</code> clause after the function signature. So instead of:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {
</code></pre>
<p>We can write this instead with a <code>where</code> clause:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>This is less cluttered and makes this function's signature look more similar to
a function without lots of trait bounds, in that the function name, parameter
list, and return type are close together.</p>
<a class="header" href="print.html#fixing-the-largest-function-with-trait-bounds" id="fixing-the-largest-function-with-trait-bounds"><h3>Fixing the <code>largest</code> Function with Trait Bounds</h3></a>
<p>So any time you want to use behavior defined by a trait on a generic, you need
to specify that trait in the generic type parameter's type bounds. We can now
fix the definition of the <code>largest</code> function that uses a generic type parameter
from Listing 10-5! When we set that code aside, we were getting this error:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
  |
5 |         if item &gt; largest {
  |            ^^^^
  |
note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>In the body of <code>largest</code> we wanted to be able to compare two values of type <code>T</code>
using the greater-than operator. That operator is defined as a default method
on the standard library trait <code>std::cmp::PartialOrd</code>. So in order to be able to
use the greater-than operator, we need to specify <code>PartialOrd</code> in the trait
bounds for <code>T</code> so that the <code>largest</code> function will work on slices of any type
that can be compared. We don't need to bring <code>PartialOrd</code> into scope because
it's in the prelude.</p>
<pre><code class="language-rust ignore">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>If we try to compile this, we'll get different errors:</p>
<pre><code class="language-text">error[E0508]: cannot move out of type `[T]`, a non-copy array
 --&gt; src/main.rs:4:23
  |
4 |     let mut largest = list[0];
  |         -----------   ^^^^^^^ cannot move out of here
  |         |
  |         hint: to prevent move, use `ref largest` or `ref mut largest`

error[E0507]: cannot move out of borrowed content
 --&gt; src/main.rs:6:9
  |
6 |     for &amp;item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
</code></pre>
<p>The key to this error is <code>cannot move out of type [T], a non-copy array</code>.
With our non-generic versions of the <code>largest</code> function, we were only trying to
find the largest <code>i32</code> or <code>char</code>. As we discussed in Chapter 4, types like
<code>i32</code> and <code>char</code> that have a known size can be stored on the stack, so they
implement the <code>Copy</code> trait. When we changed the <code>largest</code> function to be
generic, it's now possible that the <code>list</code> parameter could have types in it
that don't implement the <code>Copy</code> trait, which means we wouldn't be able to move
the value out of <code>list[0]</code> and into the <code>largest</code> variable.</p>
<p>If we only want to be able to call this code with types that are <code>Copy</code>, we can
add <code>Copy</code> to the trait bounds of <code>T</code>! Listing 10-15 shows the complete code of
a generic <code>largest</code> function that will compile as long as the types of the
values in the slice that we pass into <code>largest</code> implement both the <code>PartialOrd</code>
and <code>Copy</code> traits, like <code>i32</code> and <code>char</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::cmp::PartialOrd;

fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let numbers = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;numbers);
    println!(&quot;The largest number is {}&quot;, result);

    let chars = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;chars);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Listing 10-15: A working definition of the <code>largest</code>
function that works on any generic type that implements the <code>PartialOrd</code> and
<code>Copy</code> traits</span></p>
<p>If we don't want to restrict our <code>largest</code> function to only types that
implement the <code>Copy</code> trait, we could specify that <code>T</code> has the trait bound
<code>Clone</code> instead of <code>Copy</code> and clone each value in the slice when we want the
<code>largest</code> function to have ownership. Using the <code>clone</code> function means we're
potentially making more heap allocations, though, and heap allocations can be
slow if we're working with large amounts of data. Another way we could
implement <code>largest</code> is for the function to return a reference to a <code>T</code> value in
the slice. If we change the return type to be <code>&amp;T</code> instead of <code>T</code> and change
the body of the function to return a reference, we wouldn't need either the
<code>Clone</code> or <code>Copy</code> trait bounds and we wouldn't be doing any heap allocations.
Try implementing these alternate solutions on your own!</p>
<p>Traits and trait bounds let us write code that uses generic type parameters in
order to reduce duplication, but still specify to the compiler exactly what
behavior our code needs the generic type to have. Because we've given the trait
bound information to the compiler, it can check that all the concrete types
used with our code provide the right behavior. In dynamically typed languages,
if we tried to call a method on a type that the type didn't implement, we'd get
an error at runtime. Rust moves these errors to compile time so that we're
forced to fix the problems before our code is even able to run. Additionally,
we don't have to write code that checks for behavior at runtime since we've
already checked at compile time, which improves performance compared to other
languages without having to give up the flexibility of generics.</p>
<p>There's another kind of generics that we've been using without even realizing
it called <em>lifetimes</em>. Rather than helping us ensure that a type has the
behavior we need it to have, lifetimes help us ensure that references are valid
as long as we need them to be. Let's learn how lifetimes do that.</p>
<a class="header" href="print.html#validating-references-with-lifetimes" id="validating-references-with-lifetimes"><h2>Validating References with Lifetimes</h2></a>
<p>When we talked about references in Chapter 4, we left out an important detail:
every reference in Rust has a <em>lifetime</em>, which is the scope for which that
reference is valid. Most of the time lifetimes are implicit and inferred, just
like most of the time types are inferred. Similarly to when we have to annotate
types because multiple types are possible, there are cases where the lifetimes
of references could be related in a few different ways, so Rust needs us to
annotate the relationships using generic lifetime parameters so that it can
make sure the actual references used at runtime will definitely be valid.</p>
<p>Yes, it's a bit unusual, and will be different to tools you've used in other
programming languages. Lifetimes are, in some ways, Rust's most distinctive
feature.</p>
<p>Lifetimes are a big topic that can't be covered in entirety in this chapter, so
we'll cover common ways you might encounter lifetime syntax in this chapter to
get you familiar with the concepts. Chapter 19 will contain more advanced
information about everything lifetimes can do.</p>
<a class="header" href="print.html#lifetimes-prevent-dangling-references" id="lifetimes-prevent-dangling-references"><h3>Lifetimes Prevent Dangling References</h3></a>
<p>The main aim of lifetimes is to prevent dangling references, which will cause a
program to reference data other than the data we're intending to reference.
Consider the program in Listing 10-16, with an outer scope and an inner scope.
The outer scope declares a variable named <code>r</code> with no initial value, and the
inner scope declares a variable named <code>x</code> with the initial value of 5. Inside
the inner scope, we attempt to set the value of <code>r</code> as a reference to <code>x</code>. Then
the inner scope ends, and we attempt to print out the value in <code>r</code>:</p>
<pre><code class="language-rust ignore">{
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {}&quot;, r);
}
</code></pre>
<p><span class="caption">Listing 10-16: An attempt to use a reference whose value
has gone out of scope</span></p>
<blockquote>
<a class="header" href="print.html#uninitialized-variables-cannot-be-used" id="uninitialized-variables-cannot-be-used"><h4>Uninitialized Variables Cannot Be Used</h4></a>
<p>The next few examples declare variables without giving them an initial value,
so that the variable name exists in the outer scope. This might appear to be
in conflict with Rust not having null. However, if we try to use a variable
before giving it a value, we'll get a compile-time error. Try it out!</p>
</blockquote>
<p>When we compile this code, we'll get an error:</p>
<pre><code class="language-text">error: `x` does not live long enough
   |
6  |         r = &amp;x;
   |              - borrow occurs here
7  |     }
   |     ^ `x` dropped here while still borrowed
...
10 | }
   | - borrowed value needs to live until here
</code></pre>
<p>The variable <code>x</code> doesn't &quot;live long enough.&quot; Why not? Well, <code>x</code> is going to go
out of scope when we hit the closing curly brace on line 7, ending the inner
scope. But <code>r</code> is valid for the outer scope; its scope is larger and we say
that it &quot;lives longer.&quot; If Rust allowed this code to work, <code>r</code> would be
referencing memory that was deallocated when <code>x</code> went out of scope, and
anything we tried to do with <code>r</code> wouldn't work correctly. So how does Rust
determine that this code should not be allowed?</p>
<a class="header" href="print.html#the-borrow-checker" id="the-borrow-checker"><h4>The Borrow Checker</h4></a>
<p>The part of the compiler called the <em>borrow checker</em> compares scopes to
determine that all borrows are valid. Listing 10-17 shows the same example from
Listing 10-16 with annotations showing the lifetimes of the variables:</p>
<pre><code class="language-rust ignore">{
    let r;         // -------+-- 'a
                   //        |
    {              //        |
        let x = 5; // -+-----+-- 'b
        r = &amp;x;    //  |     |
    }              // -+     |
                   //        |
    println!(&quot;r: {}&quot;, r); // |
                   //        |
                   // -------+
}
</code></pre>
<p><span class="caption">Listing 10-17: Annotations of the lifetimes of <code>r</code> and
<code>x</code>, named <code>'a</code> and <code>'b</code> respectively</span></p>
<!-- Just checking I'm reading this right: the inside block is the b lifetime,
correct? I want to leave a note for production, make sure we can make that
clear -->
<!-- Yes, the inside block for the `'b` lifetime starts with the `let x = 5;`
line and ends with the first closing curly brace on the 7th line. Do you think
the text art comments work or should we make an SVG diagram that has nicer
looking arrows and labels? /Carol -->
<p>We've annotated the lifetime of <code>r</code> with <code>'a</code> and the lifetime of <code>x</code> with
<code>'b</code>. As you can see, the inner <code>'b</code> block is much smaller than the outer <code>'a</code>
lifetime block. At compile time, Rust compares the size of the two lifetimes
and sees that <code>r</code> has a lifetime of <code>'a</code>, but that it refers to an object with
a lifetime of <code>'b</code>. The program is rejected because the lifetime <code>'b</code> is
shorter than the lifetime of <code>'a</code>: the subject of the reference does not live
as long as the reference.</p>
<p>Let's look at an example in Listing 10-18 that doesn't try to make a dangling
reference and compiles without any errors:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let x = 5;            // -----+-- 'b
                          //      |
    let r = &amp;x;           // --+--+-- 'a
                          //   |  |
    println!(&quot;r: {}&quot;, r); //   |  |
                          // --+  |
}                         // -----+
#}</code></pre></pre>
<p><span class="caption">Listing 10-18: A valid reference because the data has a
longer lifetime than the reference</span></p>
<p>Here, <code>x</code> has the lifetime <code>'b</code>, which in this case is larger than <code>'a</code>. This
means <code>r</code> can reference <code>x</code>: Rust knows that the reference in <code>r</code> will always
be valid while <code>x</code> is valid.</p>
<p>Now that we've shown where the lifetimes of references are in a concrete
example and discussed how Rust analyzes lifetimes to ensure references will
always be valid, let's talk about generic lifetimes of parameters and return
values in the context of functions.</p>
<a class="header" href="print.html#generic-lifetimes-in-functions" id="generic-lifetimes-in-functions"><h3>Generic Lifetimes in Functions</h3></a>
<p>Let's write a function that will return the longest of two string slices. We
want to be able to call this function by passing it two string slices, and we
want to get back a string slice. The code in Listing 10-19 should print <code>The longest string is abcd</code> once we've implemented the <code>longest</code> function:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Listing 10-19: A <code>main</code> function that calls the <code>longest</code>
function to find the longest of two string slices</span></p>
<p>Note that we want the function to take string slices (which are references, as
we talked about in Chapter 4) since we don't want the <code>longest</code> function to
take ownership of its arguments. We want the function to be able to accept
slices of a <code>String</code> (which is the type of the variable <code>string1</code>) as well as
string literals (which is what variable <code>string2</code> contains).</p>
<!-- why is `a` a slice and `b` a literal? You mean "a" from the string "abcd"? -->
<!-- I've changed the variable names to remove ambiguity between the variable
name `a` and the "a" from the string "abcd". `string1` is not a slice, it's a
`String`, but we're going to pass a slice that refers to that `String` to the
`longest` function (`string1.as_str()` creates a slice that references the
`String` stored in `string1`). We chose to have `string2` be a literal since
the reader might have code with both `String`s and string literals, and the way
most readers first get into problems with lifetimes is involving string slices,
so we wanted to demonstrate the flexibility of taking string slices as
arguments but the issues you might run into because string slices are
references.
All of the `String`/string slice/string literal concepts here are covered
thoroughly in Chapter 4, which is why we put two back references here (above
and below). If these topics are confusing you in this context, I'd be
interested to know if rereading Chapter 4 clears up that confusion.
/Carol -->
<p>Refer back to the &quot;String Slices as Arguments&quot; section of Chapter 4 for more
discussion about why these are the arguments we want.</p>
<p>If we try to implement the <code>longest</code> function as shown in Listing 10-20, it
won't compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<p><span class="caption">Listing 10-20: An implementation of the <code>longest</code>
function that returns the longest of two string slices, but does not yet
compile</span></p>
<p>Instead we get the following error that talks about lifetimes:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
   |
1  | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
   |                                 ^ expected lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the
   signature does not say whether it is borrowed from `x` or `y`
</code></pre>
<p>The help text is telling us that the return type needs a generic lifetime
parameter on it because Rust can't tell if the reference being returned refers
to <code>x</code> or <code>y</code>. Actually, we don't know either, since the <code>if</code> block in the body
of this function returns a reference to <code>x</code> and the <code>else</code> block returns a
reference to <code>y</code>!</p>
<p>As we're defining this function, we don't know the concrete values that will be
passed into this function, so we don't know whether the <code>if</code> case or the <code>else</code>
case will execute. We also don't know the concrete lifetimes of the references
that will be passed in, so we can't look at the scopes like we did in Listings
10-17 and 10-18 in order to determine that the reference we return will always
be valid. The borrow checker can't determine this either, because it doesn't
know how the lifetimes of <code>x</code> and <code>y</code> relate to the lifetime of the return
value. We're going to add generic lifetime parameters that will define the
relationship between the references so that the borrow checker can perform its
analysis.</p>
<a class="header" href="print.html#lifetime-annotation-syntax" id="lifetime-annotation-syntax"><h3>Lifetime Annotation Syntax</h3></a>
<p>Lifetime annotations don't change how long any of the references involved live.
In the same way that functions can accept any type when the signature specifies
a generic type parameter, functions can accept references with any lifetime
when the signature specifies a generic lifetime parameter. What lifetime
annotations do is relate the lifetimes of multiple references to each other.</p>
<p>Lifetime annotations have a slightly unusual syntax: the names of lifetime
parameters must start with an apostrophe <code>'</code>. The names of lifetime parameters
are usually all lowercase, and like generic types, their names are usually very
short. <code>'a</code> is the name most people use as a default. Lifetime parameter
annotations go after the <code>&amp;</code> of a reference, and a space separates the lifetime
annotation from the reference's type.</p>
<p>Here's some examples: we've got a reference to an <code>i32</code> without a lifetime
parameter, a reference to an <code>i32</code> that has a lifetime parameter named <code>'a</code>,
and a mutable reference to an <code>i32</code> that also has the lifetime <code>'a</code>:</p>
<pre><code class="language-rust ignore">&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime
</code></pre>
<p>One lifetime annotation by itself doesn't have much meaning: lifetime
annotations tell Rust how the generic lifetime parameters of multiple
references relate to each other. If we have a function with the parameter
<code>first</code> that is a reference to an <code>i32</code> that has the lifetime <code>'a</code>, and the
function has another parameter named <code>second</code> that is another reference to an
<code>i32</code> that also has the lifetime <code>'a</code>, these two lifetime annotations that have
the same name indicate that the references <code>first</code> and <code>second</code> must both live
as long as the same generic lifetime.</p>
<a class="header" href="print.html#lifetime-annotations-in-function-signatures" id="lifetime-annotations-in-function-signatures"><h3>Lifetime Annotations in Function Signatures</h3></a>
<p>Let's look at lifetime annotations in the context of the <code>longest</code> function
we're working on. Just like generic type parameters, generic lifetime
parameters need to be declared within angle brackets between the function name
and the parameter list. The constraint we want to tell Rust about for the
references in the parameters and the return value is that they all must have
the same lifetime, which we'll name <code>'a</code> and add to each reference as shown in
Listing 10-21:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 10-21: The <code>longest</code> function definition that
specifies all the references in the signature must have the same lifetime,
<code>'a</code></span></p>
<p>This will compile and will produce the result we want when used with the <code>main</code>
function in Listing 10-19.</p>
<p>The function signature now says that for some lifetime <code>'a</code>, the function will
get two parameters, both of which are string slices that live at least as long
as the lifetime <code>'a</code>. The function will return a string slice that also will
last at least as long as the lifetime <code>'a</code>. This is the contract we are telling
Rust we want it to enforce.</p>
<p>By specifying the lifetime parameters in this function signature, we are not
changing the lifetimes of any values passed in or returned, but we are saying
that any values that do not adhere to this contract should be rejected by the
borrow checker. This function does not know (or need to know) exactly how long
<code>x</code> and <code>y</code> will live, but only needs to know that there is some scope that
can be substituted for <code>'a</code> that will satisfy this signature.</p>
<p>When annotating lifetimes in functions, the annotations go on the function
signature, and not in any of the code in the function body. This is because
Rust is able to analyze the code within the function without any help, but when
a function has references to or from code outside that function, the lifetimes
of the arguments or return values will potentially be different each time the
function is called. This would be incredibly costly and often impossible for
Rust to figure out. In this case, we need to annotate the lifetimes ourselves.</p>
<p>When concrete references are passed to <code>longest</code>, the concrete lifetime that
gets substituted for <code>'a</code> is the part of the scope of <code>x</code> that overlaps with
the scope of <code>y</code>. Since scopes always nest, another way to say this is that the
generic lifetime <code>'a</code> will get the concrete lifetime equal to the smaller of
the lifetimes of <code>x</code> and <code>y</code>. Because we've annotated the returned reference
with the same lifetime parameter <code>'a</code>, the returned reference will therefore be
guaranteed to be valid as long as the shorter of the lifetimes of <code>x</code> and <code>y</code>.</p>
<p>Let's see how this restricts the usage of the <code>longest</code> function by passing in
references that have different concrete lifetimes. Listing 10-22 is a
straightforward example that should match your intuition from any language:
<code>string1</code> is valid until the end of the outer scope, <code>string2</code> is valid until
the end of the inner scope, and <code>result</code> references something that is valid
until the end of the inner scope. The borrow checker approves of this code; it
will compile and print <code>The longest string is long string is long</code> when run:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
#     if x.len() &gt; y.len() {
#         x
#     } else {
#         y
#     }
# }
#
fn main() {
    let string1 = String::from(&quot;long string is long&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;The longest string is {}&quot;, result);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 10-22: Using the <code>longest</code> function with
references to <code>String</code> values that have different concrete lifetimes</span></p>
<p>Next, let's try an example that will show that the lifetime of the reference in
<code>result</code> must be the smaller lifetime of the two arguments. We'll move the
declaration of the <code>result</code> variable outside the inner scope, but leave the
assignment of the value to the <code>result</code> variable inside the scope with
<code>string2</code>. Next, we'll move the <code>println!</code> that uses <code>result</code> outside of the
inner scope, after it has ended. The code in Listing 10-23 will not compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Listing 10-23: Attempting to use <code>result</code> after <code>string2</code>
has gone out of scope won't compile</span></p>
<p>If we try to compile this, we'll get this error:</p>
<pre><code class="language-text">error: `string2` does not live long enough
   |
6  |         result = longest(string1.as_str(), string2.as_str());
   |                                            ------- borrow occurs here
7  |     }
   |     ^ `string2` dropped here while still borrowed
8  |     println!(&quot;The longest string is {}&quot;, result);
9  | }
   | - borrowed value needs to live until here
</code></pre>
<p>The error is saying that in order for <code>result</code> to be valid for the <code>println!</code>,
<code>string2</code> would need to be valid until the end of the outer scope. Rust knows
this because we annotated the lifetimes of the function parameters and return
values with the same lifetime parameter, <code>'a</code>.</p>
<p>We can look at this code as humans and see that <code>string1</code> is longer, and
therefore <code>result</code> will contain a reference to <code>string1</code>. Because <code>string1</code> has
not gone out of scope yet, a reference to <code>string1</code> will still be valid for the
<code>println!</code>. However, what we've told Rust with the lifetime parameters is that
the lifetime of the reference returned by the <code>longest</code> function is the same as
the smaller of the lifetimes of the references passed in. Therefore, the borrow
checker disallows the code in Listing 10-23 as possibly having an invalid
reference.</p>
<p>Try designing some more experiments that vary the values and lifetimes of the
references passed in to the <code>longest</code> function and how the returned reference
is used. Make hypotheses about whether your experiments will pass the borrow
checker or not before you compile, then check to see if you're right!</p>
<a class="header" href="print.html#thinking-in-terms-of-lifetimes" id="thinking-in-terms-of-lifetimes"><h3>Thinking in Terms of Lifetimes</h3></a>
<p>The exact way to specify lifetime parameters depends on what your function is
doing. For example, if we changed the implementation of the <code>longest</code> function
to always return the first argument rather than the longest string slice, we
wouldn't need to specify a lifetime on the <code>y</code> parameter. This code compiles:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
#}</code></pre></pre>
<p>In this example, we've specified a lifetime parameter <code>'a</code> for the parameter
<code>x</code> and the return type, but not for the parameter <code>y</code>, since the lifetime of
<code>y</code> does not have any relationship with the lifetime of <code>x</code> or the return value.</p>
<p>When returning a reference from a function, the lifetime parameter for the
return type needs to match the lifetime parameter of one of the arguments. If
the reference returned does <em>not</em> refer to one of the arguments, the only other
possibility is that it refers to a value created within this function, which
would be a dangling reference since the value will go out of scope at the end
of the function. Consider this attempted implementation of the <code>longest</code>
function that won't compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}
</code></pre>
<p>Even though we've specified a lifetime parameter <code>'a</code> for the return type, this
implementation fails to compile because the return value lifetime is not
related to the lifetime of the parameters at all. Here's the error message we
get:</p>
<pre><code class="language-text">error: `result` does not live long enough
  |
3 |     result.as_str()
  |     ^^^^^^ does not live long enough
4 | }
  | - borrowed value only lives until here
  |
note: borrowed value must be valid for the lifetime 'a as defined on the block
at 1:44...
  |
1 | fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
  |                                             ^
</code></pre>
<p>The problem is that <code>result</code> will go out of scope and get cleaned up at the end
of the <code>longest</code> function, and we're trying to return a reference to <code>result</code>
from the function. There's no way we can specify lifetime parameters that would
change the dangling reference, and Rust won't let us create a dangling
reference. In this case, the best fix would be to return an owned data type
rather than a reference so that the calling function is then responsible for
cleaning up the value.</p>
<p>Ultimately, lifetime syntax is about connecting the lifetimes of various
arguments and return values of functions. Once they're connected, Rust has
enough information to allow memory-safe operations and disallow operations that
would create dangling pointers or otherwise violate memory safety.</p>
<a class="header" href="print.html#lifetime-annotations-in-struct-definitions" id="lifetime-annotations-in-struct-definitions"><h3>Lifetime Annotations in Struct Definitions</h3></a>
<p>Up until now, we've only defined structs to hold owned types. It is possible
for structs to hold references, but we need to add a lifetime annotation on
every reference in the struct's definition. Listing 10-24 has a struct named
<code>ImportantExcerpt</code> that holds a string slice:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.')
        .next()
        .expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt { part: first_sentence };
}
</code></pre></pre>
<p><span class="caption">Listing 10-24: A struct that holds a reference, so its
definition needs a lifetime annotation</span></p>
<p>This struct has one field, <code>part</code>, that holds a string slice, which is a
reference. Just like with generic data types, we have to declare the name of
the generic lifetime parameter inside angle brackets after the name of the
struct so that we can use the lifetime parameter in the body of the struct
definition.</p>
<p>The <code>main</code> function here creates an instance of the <code>ImportantExcerpt</code> struct
that holds a reference to the first sentence of the <code>String</code> owned by the
variable <code>novel</code>.</p>
<a class="header" href="print.html#lifetime-elision" id="lifetime-elision"><h3>Lifetime Elision</h3></a>
<p>In this section, we've learned that every reference has a lifetime, and we need
to specify lifetime parameters for functions or structs that use references.
However, in Chapter 4 we had a function in the &quot;String Slices&quot; section, shown
again in Listing 10-25, that compiled without lifetime annotations:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<p><span class="caption">Listing 10-25: A function we defined in Chapter 4 that
compiled without lifetime annotations, even though the parameter and return
type are references</span></p>
<p>The reason this function compiles without lifetime annotations is historical:
in early versions of pre-1.0 Rust, this indeed wouldn't have compiled. Every
reference needed an explicit lifetime. At that time, the function signature
would have been written like this:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>After writing a lot of Rust code, the Rust team found that Rust programmers
were typing the same lifetime annotations over and over in particular
situations. These situations were predictable and followed a few deterministic
patterns. The Rust team then programmed these patterns into the Rust compiler's
code so that the borrow checker can infer the lifetimes in these situations
without forcing the programmer to explicitly add the annotations.</p>
<p>We mention this piece of Rust history because it's entirely possible that more
deterministic patterns will emerge and be added to the compiler. In the future,
even fewer lifetime annotations might be required.</p>
<p>The patterns programmed into Rust's analysis of references are called the
<em>lifetime elision rules</em>. These aren't rules for programmers to follow; the
rules are a set of particular cases that the compiler will consider, and if
your code fits these cases, you don't need to write the lifetimes explicitly.</p>
<p>The elision rules don't provide full inference: if Rust deterministically
applies the rules but there's still ambiguity as to what lifetimes the
references have, it won't guess what the lifetime of the remaining references
should be. In this case, the compiler will give you an error that can be
resolved by adding the lifetime annotations that correspond to your intentions
for how the references relate to each other.</p>
<p>First, some definitions: Lifetimes on function or method parameters are called
<em>input lifetimes</em>, and lifetimes on return values are called <em>output lifetimes</em>.</p>
<p>Now, on to the rules that the compiler uses to figure out what lifetimes
references have when there aren't explicit annotations. The first rule applies
to input lifetimes, and the second two rules apply to output lifetimes. If the
compiler gets to the end of the three rules and there are still references that
it can't figure out lifetimes for, the compiler will stop with an error.</p>
<ol>
<li>
<p>Each parameter that is a reference gets its own lifetime parameter. In other
words, a function with one parameter gets one lifetime parameter: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>, a function with two arguments gets two separate
lifetime parameters: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>, and so on.</p>
</li>
<li>
<p>If there is exactly one input lifetime parameter, that lifetime is assigned
to all output lifetime parameters: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
</li>
<li>
<p>If there are multiple input lifetime parameters, but one of them is <code>&amp;self</code>
or <code>&amp;mut self</code> because this is a method, then the lifetime of <code>self</code> is
assigned to all output lifetime parameters. This makes writing methods much
nicer.</p>
</li>
</ol>
<p>Let's pretend we're the compiler and apply these rules to figure out what the
lifetimes of the references in the signature of the <code>first_word</code> function in
Listing 10-25 are. The signature starts without any lifetimes associated with
the references:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Then we (as the compiler) apply the first rule, which says each parameter gets
its own lifetime. We're going to call it <code>'a</code> as usual, so now the signature is:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<p>On to the second rule, which applies because there is exactly one input
lifetime. The second rule says the lifetime of the one input parameter gets
assigned to the output lifetime, so now the signature is:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Now all the references in this function signature have lifetimes, and the
compiler can continue its analysis without needing the programmer to annotate
the lifetimes in this function signature.</p>
<p>Let's do another example, this time with the <code>longest</code> function that had no
lifetime parameters when we started working with in Listing 10-20:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Pretending we're the compiler again, let's apply the first rule: each parameter
gets its own lifetime. This time we have two parameters, so we have two
lifetimes:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<p>Looking at the second rule, it doesn't apply since there is more than one input
lifetime. Looking at the third rule, this also does not apply because this is a
function rather than a method, so none of the parameters are <code>self</code>. So we're
out of rules, but we haven't figured out what the return type's lifetime is.
This is why we got an error trying to compile the code from Listing 10-20: the
compiler worked through the lifetime elision rules it knows, but still can't
figure out all the lifetimes of the references in the signature.</p>
<p>Because the third rule only really applies in method signatures, let's look at
lifetimes in that context now, and see why the third rule means we don't have
to annotate lifetimes in method signatures very often.</p>
<a class="header" href="print.html#lifetime-annotations-in-method-definitions" id="lifetime-annotations-in-method-definitions"><h3>Lifetime Annotations in Method Definitions</h3></a>
<!-- Is this different to the reference lifetime annotations, or just a
finalized explanation? -->
<!-- This is about lifetimes on references in method signatures, which is where
the 3rd lifetime elision rule kicks in. It can also be confusing where lifetime
parameters need to be declared and used since the lifetime parameters could go
with the struct's fields or with references passed into or returned from
methods. /Carol -->
<p>When we implement methods on a struct with lifetimes, the syntax is again the
same as that of generic type parameters that we showed in Listing 10-10: the
place that lifetime parameters are declared and used depends on whether the
lifetime parameter is related to the struct fields or the method arguments and
return values.</p>
<p>Lifetime names for struct fields always need to be declared after the <code>impl</code>
keyword and then used after the struct's name, since those lifetimes are part
of the struct's type.</p>
<p>In method signatures inside the <code>impl</code> block, references might be tied to the
lifetime of references in the struct's fields, or they might be independent. In
addition, the lifetime elision rules often make it so that lifetime annotations
aren't necessary in method signatures. Let's look at some examples using the
struct named <code>ImportantExcerpt</code> that we defined in Listing 10-24.</p>
<p>First, here's a method named <code>level</code>. The only parameter is a reference to
<code>self</code>, and the return value is just an <code>i32</code>, not a reference to anything:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct ImportantExcerpt&lt;'a&gt; {
#     part: &amp;'a str,
# }
#
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
#}</code></pre></pre>
<p>The lifetime parameter declaration after <code>impl</code> and use after the type name is
required, but we're not required to annotate the lifetime of the reference to
<code>self</code> because of the first elision rule.</p>
<p>Here's an example where the third lifetime elision rule applies:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct ImportantExcerpt&lt;'a&gt; {
#     part: &amp;'a str,
# }
#
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
#}</code></pre></pre>
<p>There are two input lifetimes, so Rust applies the first lifetime elision rule
and gives both <code>&amp;self</code> and <code>announcement</code> their own lifetimes. Then, because
one of the parameters is <code>&amp;self</code>, the return type gets the lifetime of <code>&amp;self</code>,
and all lifetimes have been accounted for.</p>
<a class="header" href="print.html#the-static-lifetime" id="the-static-lifetime"><h3>The Static Lifetime</h3></a>
<p>There is <em>one</em> special lifetime we need to discuss: <code>'static</code>. The <code>'static</code>
lifetime is the entire duration of the program. All string literals have the
<code>'static</code> lifetime, which we can choose to annotate as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
#}</code></pre></pre>
<p>The text of this string is stored directly in the binary of your program and
the binary of your program is always available. Therefore, the lifetime of all
string literals is <code>'static</code>.</p>
<!-- How would you add a static lifetime (below)? -->
<!-- Just like you'd specify any lifetime, see above where it shows `&'static str`. /Carol -->
<p>You may see suggestions to use the <code>'static</code> lifetime in error message help
text, but before specifying <code>'static</code> as the lifetime for a reference, think
about whether the reference you have is one that actually lives the entire
lifetime of your program or not (or even if you want it to live that long, if
it could). Most of the time, the problem in the code is an attempt to create a
dangling reference or a mismatch of the available lifetimes, and the solution
is fixing those problems, not specifying the <code>'static</code> lifetime.</p>
<a class="header" href="print.html#generic-type-parameters-trait-bounds-and-lifetimes-together" id="generic-type-parameters-trait-bounds-and-lifetimes-together"><h3>Generic Type Parameters, Trait Bounds, and Lifetimes Together</h3></a>
<p>Let's briefly look at the syntax of specifying generic type parameters, trait
bounds, and lifetimes all in one function!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a str
    where T: Display
{
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p>This is the <code>longest</code> function from Listing 10-21 that returns the longest of
two string slices, but with an extra argument named <code>ann</code>. The type of <code>ann</code> is
the generic type <code>T</code>, which may be filled in by any type that implements the
<code>Display</code> trait as specified by the <code>where</code> clause. This extra argument will be
printed out before the function compares the lengths of the string slices,
which is why the <code>Display</code> trait bound is necessary. Because lifetimes are a
type of generic, the declarations of both the lifetime parameter <code>'a</code> and the
generic type parameter <code>T</code> go in the same list within the angle brackets after
the function name.</p>
<a class="header" href="print.html#summary-2" id="summary-2"><h2>Summary</h2></a>
<p>We covered a lot in this chapter! Now that you know about generic type
parameters, traits and trait bounds, and generic lifetime parameters, you're
ready to write code that isn't duplicated but can be used in many different
situations. Generic type parameters mean the code can be applied to different
types. Traits and trait bounds ensure that even though the types are generic,
those types will have the behavior the code needs. Relationships between the
lifetimes of references specified by lifetime annotations ensure that this
flexible code won't have any dangling references. And all of this happens at
compile time so that run-time performance isn't affected!</p>
<p>Believe it or not, there's even more to learn in these areas: Chapter 17 will
discuss trait objects, which are another way to use traits. Chapter 19 will be
covering more complex scenarios involving lifetime annotations. Chapter 20 will
get to some advanced type system features. Up next, though, let's talk about
how to write tests in Rust so that we can make sure our code using all these
features is working the way we want it to!</p>
<a class="header" href="print.html#testing" id="testing"><h1>Testing</h1></a>
<blockquote>
<p>Program testing can be a very effective way to show the presence of bugs, but
it is hopelessly inadequate for showing their absence.</p>
<p>Edsger W. Dijkstra, &quot;The Humble Programmer&quot; (1972)</p>
</blockquote>
<p>Correctness in our programs means that our code does what we intend for it to
do. Rust is a programming language that cares a lot about correctness, but
correctness is a complex topic and isn't easy to prove. Rust's type system
shoulders a huge part of this burden, but the type system cannot catch every
kind of incorrectness. As such, Rust includes support for writing software
tests within the language itself.</p>
<p>As an example, say we write a function called <code>add_two</code> that adds two to a
number passed to it. This function's signature accepts an integer as a
parameter and returns an integer as a result. When we implement and compile
that function, Rust will do all the type checking and borrow checking that
we've seen so far. Those checks will make sure that, for instance, we aren't
passing a <code>String</code> value or an invalid reference to this function. What Rust
<em>can't</em> check is that this function will do precisely what we intend: return
the parameter plus two, rather than, say, the parameter plus 10 or the
parameter minus 50! That's where tests come in.</p>
<p>We can write tests that assert, for example, that when we pass <code>3</code> to the
<code>add_two</code> function, we get <code>5</code> back. We can run these tests whenever we make
changes to our code to make sure any existing correct behavior has not changed.</p>
<p>Testing is a complex skill, and we cannot hope to cover everything about how to
write good tests in one chapter of a book, so here we'll just discuss the
mechanics of Rust's testing facilities. We'll talk about the annotations and
macros available to you when writing your tests, the default behavior and
options provided for running your tests, and how to organize tests into unit
tests and integration tests.</p>
<a class="header" href="print.html#how-to-write-tests" id="how-to-write-tests"><h2>How to Write Tests</h2></a>
<p>Tests are Rust functions that verify non-test code is functioning in the
program in the expected manner. The bodies of test functions typically contain
some setup, running the code we want to test, then asserting that the results
are what we expect. Let's look at the features Rust provides specifically for
writing tests: the <code>test</code> attribute, a few macros, and the <code>should_panic</code>
attribute.</p>
<a class="header" href="print.html#the-anatomy-of-a-test-function" id="the-anatomy-of-a-test-function"><h3>The Anatomy of a Test Function</h3></a>
<p>At its simplest, a test in Rust is a function that's annotated with the <code>test</code>
attribute. Attributes are metadata about pieces of Rust code: the <code>derive</code>
attribute that we used with structs in Chapter 5 is one example. To make a
function into a test function, we add <code>#[test]</code> on the line before <code>fn</code>. When
we run our tests with the <code>cargo test</code> command, Rust will build a test runner
binary that runs the functions annotated with the <code>test</code> attribute and reports
on whether each test function passes or fails.</p>
<!-- is it annotated with `test` by the user, or only automatically? I think
it's the latter, and has edited with a more active tone to make that clear, but
please change if I'm wrong -->
<!-- What do you mean by "only automatically"? The reader should be typing in
`#[test] on their own when they add new test functions; there's nothing special
about that text. I'm not sure what part of this chapter implied "only
automatically", can you point out where that's happening if we haven't taken
care of it? /Carol -->
<p>We saw in Chapter 7 that when you make a new library project with Cargo, a test
module with a test function in it is automatically generated for us. This is to
help us get started writing our tests, since we don't have to go look up the
exact structure and syntax of test functions every time we start a new project.
We can add as many additional test functions and as many test modules as we
want, though!</p>
<p>We're going to explore some aspects of how tests work by experimenting with the
template test generated for us, without actually testing any code. Then we'll
write some real-world tests that call some code that we've written and assert
that its behavior is correct.</p>
<p>Let's create a new library project called <code>adder</code>:</p>
<pre><code class="language-text">$ cargo new adder
     Created library `adder` project
$ cd adder
</code></pre>
<p>The contents of the <code>src/lib.rs</code> file in your adder library should be as
follows:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-1: The test module and function generated
automatically for us by <code>cargo new</code> </span></p>
<p>For now, let's ignore the top two lines and focus on the function to see how it
works. Note the <code>#[test]</code> annotation before the <code>fn</code> line: this attribute
indicates this is a test function, so that the test runner knows to treat this
function as a test. We could also have non-test functions in the <code>tests</code> module
to help set up common scenarios or perform common operations, so we need to
indicate which functions are tests with the <code>#[test]</code> attribute.</p>
<p>The function currently has no body, which means there is no code to fail the
test; an empty test is a passing test! Let's run it and see that this test
passes.</p>
<p>The <code>cargo test</code> command runs all tests we have in our project, as shown in
Listing 11-2:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.22 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p><span class="caption">Listing 11-2: The output from running the one
automatically generated test </span></p>
<p>Cargo compiled and ran our test. After the <code>Compiling</code>, <code>Finished</code>, and
<code>Running</code> lines, we see the line <code>running 1 test</code>. The next line shows the name
of the generated test function, called <code>it_works</code>, and the result of running
that test, <code>ok</code>. Then we see the overall summary of running the tests: <code>test result: ok.</code> means all the tests passed. <code>1 passed; 0 failed</code> adds up the
number of tests that passed or failed.</p>
<p>We don't have any tests we've marked as ignored, so the summary says <code>0 ignored</code>. We're going to talk about ignoring tests in the next section on
different ways to run tests. The <code>0 measured</code> statistic is for benchmark tests
that measure performance. Benchmark tests are, as of this writing, only
available in nightly Rust. See Appendix D for more information about nightly
Rust.</p>
<p>The next part of the test output that starts with <code>Doc-tests adder</code> is for the
results of any documentation tests. We don't have any documentation tests yet,
but Rust can compile any code examples that appear in our API documentation.
This feature helps us keep our docs and our code in sync! We'll be talking
about how to write documentation tests in the &quot;Documentation Comments&quot; section
of Chapter 14. We're going to ignore the <code>Doc-tests</code> output for now.</p>
<!-- I might suggest changing the name of the function, could be misconstrued
as part of the test output! -->
<!-- `it_works` is always the name that `cargo new` generates for the first
test function, though. We wanted to show the reader what happens when you run
the tests immediately after generating a new project; they pass without you
needing to change anything. I've added a bit to walk through changing the
function name and seeing how the output changes; I hope that's sufficient.
/Carol -->
<p>Let's change the name of our test and see how that changes the test output.
Give the <code>it_works</code> function a different name, such as <code>exploration</code>, like so:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
    }
}
#}</code></pre></pre>
<p>And run <code>cargo test</code> again. In the output, we'll now see <code>exploration</code> instead
of <code>it_works</code>:</p>
<pre><code class="language-text">running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Let's add another test, but this time we'll make a test that fails! Tests fail
when something in the test function panics. We talked about the simplest way to
cause a panic in Chapter 9: call the <code>panic!</code> macro! Type in the new test so
that your <code>src/lib.rs</code> now looks like Listing 11-3:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
    }

    #[test]
    fn another() {
        panic!(&quot;Make this test fail&quot;);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-3: Adding a second test; one that will fail
since we call the <code>panic!</code> macro </span></p>
<p>And run the tests again with <code>cargo test</code>. The output should look like Listing
11-4, which shows that our <code>exploration</code> test passed and <code>another</code> failed:</p>
<pre><code class="language-text">running 2 tests
test tests::exploration ... ok
test tests::another ... FAILED

failures:

---- tests::another stdout ----
    thread 'tests::another' panicked at 'Make this test fail', src/lib.rs:9
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured

error: test failed
</code></pre>
<p><span class="caption">Listing 11-4: Test results when one test passes and one
test fails </span></p>
<p>Instead of <code>ok</code>, the line <code>test tests::another</code> says <code>FAILED</code>. We have two new
sections between the individual results and the summary: the first section
displays the detailed reason for the test failures. In this case, <code>another</code>
failed because it <code>panicked at 'Make this test fail'</code>, which happened on
<em>src/lib.rs</em> line 9. The next section lists just the names of all the failing
tests, which is useful when there are lots of tests and lots of detailed
failing test output. We can use the name of a failing test to run just that
test in order to more easily debug it; we'll talk more about ways to run tests
in the next section.</p>
<p>Finally, we have the summary line: overall, our test result is <code>FAILED</code>. We had
1 test pass and 1 test fail.</p>
<p>Now that we've seen what the test results look like in different scenarios,
let's look at some macros other than <code>panic!</code> that are useful in tests.</p>
<a class="header" href="print.html#checking-results-with-the-assert-macro" id="checking-results-with-the-assert-macro"><h3>Checking Results with the <code>assert!</code> Macro</h3></a>
<p>The <code>assert!</code> macro, provided by the standard library, is useful when you want
to ensure that some condition in a test evaluates to <code>true</code>. We give the
<code>assert!</code> macro an argument that evaluates to a boolean. If the value is <code>true</code>,
<code>assert!</code> does nothing and the test passes. If the value is <code>false</code>, <code>assert!</code>
calls the <code>panic!</code> macro, which causes the test to fail. This is one macro that
helps us check that our code is functioning in the way we intend.</p>
<!-- what kind of thing can be passed as an argument? Presumably when we use it
for real we won't pass it `true` or `false` as an argument, but some condition
that will evaluate to true or false? In which case, should below be phrased "If
the argument evaluates to true" and an explanation of that? Or maybe even a
working example would be better, this could be misleading -->
<!-- We were trying to really break it down, to show just how the `assert!`
macro works and what it looks like for it to pass or fail, before we got into
calling actual code. We've changed this section to move a bit faster and just
write actual tests instead. /Carol -->
<p>Remember all the way back in Chapter 5, Listing 5-9, where we had a <code>Rectangle</code>
struct and a <code>can_hold</code> method, repeated here in Listing 11-5. Let's put this
code in <em>src/lib.rs</em> instead of <em>src/main.rs</em> and write some tests for it using
the <code>assert!</code> macro.</p>
<!-- Listing 5-9 wasn't marked as such; I'll fix it the next time I get Chapter
5 for editing. /Carol -->
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
pub struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &gt; other.length &amp;&amp; self.width &gt; other.width
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-5: The <code>Rectangle</code> struct and its <code>can_hold</code>
method from Chapter 5 </span></p>
<p>The <code>can_hold</code> method returns a boolean, which means it's a perfect use case
for the <code>assert!</code> macro. In Listing 11-6, let's write a test that exercises the
<code>can_hold</code> method by creating a <code>Rectangle</code> instance that has a length of 8 and
a width of 7, and asserting that it can hold another <code>Rectangle</code> instance that
has a length of 5 and a width of 1:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(larger.can_hold(&amp;smaller));
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-6: A test for <code>can_hold</code> that checks that a
larger rectangle indeed holds a smaller rectangle </span></p>
<p>Note that we've added a new line inside the <code>tests</code> module: <code>use super::*;</code>.
The <code>tests</code> module is a regular module that follows the usual visibility rules
we covered in Chapter 7. Because we're in an inner module, we need to bring the
code under test in the outer module into the scope of the inner module. We've
chosen to use a glob here so that anything we define in the outer module is
available to this <code>tests</code> module.</p>
<p>We've named our test <code>larger_can_hold_smaller</code>, and we've created the two
<code>Rectangle</code> instances that we need. Then we called the <code>assert!</code> macro and
passed it the result of calling <code>larger.can_hold(&amp;smaller)</code>. This expression is
supposed to return <code>true</code>, so our test should pass. Let's find out!</p>
<pre><code class="language-text">running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>It does pass! Let's add another test, this time asserting that a smaller
rectangle cannot hold a larger rectangle:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(larger.can_hold(&amp;smaller));
    }

    #[test]
    fn smaller_can_not_hold_larger() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
#}</code></pre></pre>
<p>Because the correct result of the <code>can_hold</code> function in this case is <code>false</code>,
we need to negate that result before we pass it to the <code>assert!</code> macro. This
way, our test will pass if <code>can_hold</code> returns <code>false</code>:</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_can_not_hold_larger ... ok
test tests::larger_can_hold_smaller ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Two passing tests! Now let's see what happens to our test results if we
introduce a bug in our code. Let's change the implementation of the <code>can_hold</code>
method to have a less-than sign when it compares the lengths where it's
supposed to have a greater-than sign:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
pub struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &lt; other.length &amp;&amp; self.width &gt; other.width
    }
}
#}</code></pre></pre>
<p>Running the tests now produces:</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_can_not_hold_larger ... ok
test tests::larger_can_hold_smaller ... FAILED

failures:

---- tests::larger_can_hold_smaller stdout ----
    thread 'tests::larger_can_hold_smaller' panicked at 'assertion failed:
    larger.can_hold(&amp;smaller)', src/lib.rs:22
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Our tests caught the bug! Since <code>larger.length</code> is 8 and <code>smaller.length</code> is 5,
the comparison of the lengths in <code>can_hold</code> now returns <code>false</code> since 8 is not
less than 5.</p>
<a class="header" href="print.html#testing-equality-with-the-assert_eq-and-assert_ne-macros" id="testing-equality-with-the-assert_eq-and-assert_ne-macros"><h3>Testing Equality with the <code>assert_eq!</code> and <code>assert_ne!</code> Macros</h3></a>
<p>A common way to test functionality is to take the result of the code under test
and the value we expect the code to return and check that they're equal. We
could do this using the <code>assert!</code> macro and passing it an expression using the
<code>==</code> operator. However, this is such a common test that the standard library
provides a pair of macros to perform this test more conveniently: <code>assert_eq!</code>
and <code>assert_ne!</code>. These macros compare two arguments for equality or
inequality, respectively. They'll also print out the two values if the
assertion fails, so that it's easier to see <em>why</em> the test failed, while the
<code>assert!</code> macro only tells us that it got a <code>false</code> value for the <code>==</code>
expression, not the values that lead to the <code>false</code> value.</p>
<p>In Listing 11-7, let's write a function named <code>add_two</code> that adds two to its
parameter and returns the result. Then let's test this function using the
<code>assert_eq!</code> macro:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-7: Testing the function <code>add_two</code> using the
<code>assert_eq!</code> macro </span></p>
<p>Let's check that it passes!</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>The first argument we gave to the <code>assert_eq!</code> macro, 4, is equal to the result
of calling <code>add_two(2)</code>. We see a line for this test that says <code>test tests::it_adds_two ... ok</code>, and the <code>ok</code> text indicates that our test passed!</p>
<p>Let's introduce a bug into our code to see what it looks like when a test that
uses <code>assert_eq!</code> fails. Change the implementation of the <code>add_two</code> function to
instead add 3:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
#}</code></pre></pre>
<p>And run the tests again:</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
    thread 'tests::it_adds_two' panicked at 'assertion failed: `(left ==
    right)` (left: `4`, right: `5`)', src/lib.rs:11
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Our test caught the bug! The <code>it_adds_two</code> test failed with the message <code>assertion failed: `(left == right)` (left: `4`, right: `5`)</code>. This message is
useful and helps us get started debugging: it says the <code>left</code> argument to
<code>assert_eq!</code> was 4, but the <code>right</code> argument, where we had <code>add_two(2)</code>, was 5.</p>
<p>Note that in some languages and test frameworks, the parameters to the
functions that assert two values are equal are called <code>expected</code> and <code>actual</code>
and the order in which we specify the arguments matters. However, in Rust,
they're called <code>left</code> and <code>right</code> instead, and the order in which we specify
the value we expect and the value that the code under test produces doesn't
matter. We could have written the assertion in this test as
<code>assert_eq!(add_two(2), 4)</code>, which would result in a failure message that says
<code>assertion failed: `(left == right)` (left: `5`, right: `4`)</code>.</p>
<p>The <code>assert_ne!</code> macro will pass if the two values we give to it are not equal
and fail if they are equal. This macro is most useful for cases when we're not
sure exactly what a value <em>will</em> be, but we know what the value definitely
<em>won't</em> be, if our code is functioning as we intend. For example, if we have a
function that is guaranteed to change its input in some way, but the way in
which the input is changed depends on the day of the week that we run our
tests, the best thing to assert might be that the output of the function is not
equal to the input.</p>
<p>Under the surface, the <code>assert_eq!</code> and <code>assert_ne!</code> macros use the operators
<code>==</code> and <code>!=</code>, respectively. When the assertions fail, these macros print their
arguments using debug formatting, which means the values being compared must
implement the <code>PartialEq</code> and <code>Debug</code> traits. All of the primitive types and
most of the standard library types implement these traits. For structs and
enums that you define, you'll need to implement <code>PartialEq</code> in order to be able
to assert that values of those types are equal or not equal. You'll need to
implement <code>Debug</code> in order to be able to print out the values in the case that
the assertion fails. Because both of these traits are derivable traits, as we
mentioned in Chapter 5, this is usually as straightforward as adding the
<code>#[derive(PartialEq, Debug)]</code> annotation to your struct or enum definition. See
Appendix C for more details about these and other derivable traits.</p>
<a class="header" href="print.html#custom-failure-messages" id="custom-failure-messages"><h3>Custom Failure Messages</h3></a>
<p>We can also add a custom message to be printed with the failure message as
optional arguments to <code>assert!</code>, <code>assert_eq!</code>, and <code>assert_ne!</code>. Any arguments
specified after the one required argument to <code>assert!</code> or the two required
arguments to <code>assert_eq!</code> and <code>assert_ne!</code> are passed along to the <code>format!</code>
macro that we talked about in Chapter 8, so you can pass a format string that
contains <code>{}</code> placeholders and values to go in the placeholders. Custom
messages are useful in order to document what an assertion means, so that when
the test fails, we have a better idea of what the problem is with the code.</p>
<p>For example, let's say we have a function that greets people by name, and we
want to test that the name we pass into the function appears in the output:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}
#}</code></pre></pre>
<p>The requirements for this program haven't been agreed upon yet, and we're
pretty sure the <code>Hello</code> text at the beginning of the greeting will change. We
decided we don't want to have to update the test for the name when that
happens, so instead of checking for exact equality to the value returned from
the <code>greeting</code> function, we're just going to assert that the output contains
the text of the input parameter.</p>
<p>Let's introduce a bug into this code to see what this test failure looks like,
by changing <code>greeting</code> to not include <code>name</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}
#}</code></pre></pre>
<p>Running this test produces:</p>
<pre><code class="language-text">running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
    thread 'tests::greeting_contains_name' panicked at 'assertion failed:
    result.contains(&quot;Carol&quot;)', src/lib.rs:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::greeting_contains_name
</code></pre>
<p>This just tells us that the assertion failed and which line the assertion is
on. A more useful failure message in this case would print the value we did get
from the <code>greeting</code> function. Let's change the test function to have a custom
failure message made from a format string with a placeholder filled in with the
actual value we got from the <code>greeting</code> function:</p>
<pre><code class="language-rust ignore">#[test]
fn greeting_contains_name() {
    let result = greeting(&quot;Carol&quot;);
    assert!(
        result.contains(&quot;Carol&quot;),
        &quot;Greeting did not contain name, value was `{}`&quot;, result
    );
}
</code></pre>
<p>Now if we run the test again, we'll get a much more informative error message:</p>
<pre><code class="language-text">---- tests::greeting_contains_name stdout ----
    thread 'tests::greeting_contains_name' panicked at 'Greeting did not contain
    name, value was `Hello`', src/lib.rs:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>We can see the value we actually got in the test output, which would help us
debug what happened instead of what we were expecting to happen.</p>
<a class="header" href="print.html#checking-for-panics-with-should_panic" id="checking-for-panics-with-should_panic"><h3>Checking for Panics with <code>should_panic</code></h3></a>
<p>In addition to checking that our code returns the correct values we expect,
it's also important to check that our code handles error conditions as we
expect. For example, consider the <code>Guess</code> type that we created in Chapter 9 in
Listing 9-8. Other code that uses <code>Guess</code> is depending on the guarantee that
<code>Guess</code> instances will only contain values between 1 and 100. We can write a
test that ensures that attempting to create a <code>Guess</code> instance with a value
outside that range panics.</p>
<p>We can do this by adding another attribute, <code>should_panic</code>, to our test
function. This attribute makes a test pass if the code inside the function
panics, and the test will fail if the code inside the function does not panic.</p>
<p>Listing 11-8 shows how we'd write a test that checks the error conditions of
<code>Guess::new</code> happen when we expect:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-8: Testing that a condition will cause a
<code>panic!</code> </span></p>
<p>The <code>#[should_panic]</code> attribute goes after the <code>#[test]</code> attribute and before
the test function it applies to. Let's see what it looks like when this test
passes:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Looks good! Now let's introduce a bug in our code, by removing the condition
that the <code>new</code> function will panic if the value is greater than 100:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Guess {
#     value: u32,
# }
#
impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1  {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}
#}</code></pre></pre>
<p>If we run the test from Listing 11-8, it will fail:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>We don't get a very helpful message in this case, but once we look at the test
function, we can see that it's annotated with <code>#[should_panic]</code>. The failure we
got means that the code in the function, <code>Guess::new(200)</code>, did not cause a
panic.</p>
<p><code>should_panic</code> tests can be imprecise, however, because they only tell us that
the code has caused some panic. A <code>should_panic</code> test would pass even if the
test panics for a different reason than the one we were expecting to happen. To
make <code>should_panic</code> tests more precise, we can add an optional <code>expected</code>
parameter to the <code>should_panic</code> attribute. The test harness will make sure that
the failure message contains the provided text. For example, consider the
modified code for <code>Guess</code> in Listing 11-9 where the <code>new</code> function panics with
different messages depending on whether the value was too small or too large:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                   value);
        } else if value &gt; 100 {
            panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;,
                   value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-9: Testing that a condition will cause a
<code>panic!</code> with a particular panic message </span></p>
<p>This test will pass, because the value we put in the <code>expected</code> parameter of
the <code>should_panic</code> attribute is a substring of the message that the
<code>Guess::new</code> function panics with. We could have specified the whole panic
message that we expect, which in this case would be <code>Guess value must be less than or equal to 100, got 200.</code> It depends on how much of the panic message is
unique or dynamic and how precise you want your test to be. In this case, a
substring of the panic message is enough to ensure that the code in the
function that gets run is the <code>else if value &gt; 100</code> case.</p>
<p>To see what happens when a <code>should_panic</code> test with an <code>expected</code> message
fails, let's again introduce a bug into our code by swapping the bodies of the
<code>if value &lt; 1</code> and the <code>else if value &gt; 100</code> blocks:</p>
<pre><code class="language-rust ignore">if value &lt; 1 {
    panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;, value);
} else if value &gt; 100 {
    panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;, value);
}
</code></pre>
<p>This time when we run the <code>should_panic</code> test, it will fail:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
    thread 'tests::greater_than_100' panicked at 'Guess value must be greater
    than or equal to 1, got 200.', src/lib.rs:10
note: Run with `RUST_BACKTRACE=1` for a backtrace.
note: Panic did not include expected string 'Guess value must be less than or
equal to 100'

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>The failure message indicates that this test did indeed panic as we expected,
but the panic message <code>did not include expected string 'Guess value must be less than or equal to 100'</code>. We can see the panic message that we did get,
which in this case was <code>Guess value must be greater than or equal to 1, got</code> We could then start figuring out where our bug was!</p>
<p>Now that we've gone over ways to write tests, let's look at what is happening
when we run our tests and talk about the different options we can use with
<code>cargo test</code>.</p>
<a class="header" href="print.html#controlling-how-tests-are-run" id="controlling-how-tests-are-run"><h2>Controlling How Tests are Run</h2></a>
<p>Just as <code>cargo run</code> compiles your code and then runs the resulting binary,
<code>cargo test</code> compiles your code in test mode and runs the resulting test
binary. There are options you can use to change the default behavior of <code>cargo test</code>. For example, the default behavior of the binary produced by <code>cargo test</code>
is to run all the tests in parallel and capture output generated during test
runs, preventing it from being displayed to make it easier to read the output
related to the test results. You can change this default behavior by specifying
command line options.</p>
<p>Some command line options can be passed to <code>cargo test</code>, and some need to be
passed instead to the resulting test binary. To separate these two types of
arguments, you list the arguments that go to <code>cargo test</code>, then the separator
<code>--</code>, and then the arguments that go to the test binary. Running <code>cargo test --help</code> will tell you about the options that go with <code>cargo test</code>, and running
<code>cargo test -- --help</code> will tell you about the options that go after the
separator <code>--</code>.</p>
<a class="header" href="print.html#running-tests-in-parallel-or-consecutively" id="running-tests-in-parallel-or-consecutively"><h3>Running Tests in Parallel or Consecutively</h3></a>
<!-- Are we safe assuming the reader will know enough about threads in this
context? -->
<!-- Yes /Carol -->
<p>When multiple tests are run, by default they run in parallel using threads.
This means the tests will finish running faster, so that we can get faster
feedback on whether or not our code is working. Since the tests are running at
the same time, you should take care that your tests do not depend on each other
or on any shared state, including a shared environment such as the current
working directory or environment variables.</p>
<p>For example, say each of your tests runs some code that creates a file on disk
named <code>test-output.txt</code> and writes some data to that file. Then each test reads
the data in that file and asserts that the file contains a particular value,
which is different in each test. Because the tests are all run at the same
time, one test might overwrite the file between when another test writes and
reads the file. The second test will then fail, not because the code is
incorrect, but because the tests have interfered with each other while running
in parallel. One solution would be to make sure each test writes to a different
file; another solution is to run the tests one at a time.</p>
<p>If you don't want to run the tests in parallel, or if you want more
fine-grained control over the number of threads used, you can send the
<code>--test-threads</code> flag and the number of threads you want to use to the test
binary. For example:</p>
<pre><code class="language-text">$ cargo test -- --test-threads=1
</code></pre>
<p>We set the number of test threads to 1, telling the program not to use any
parallelism. This will take longer than running them in parallel, but the tests
won't be potentially interfering with each other if they share state.</p>
<a class="header" href="print.html#showing-function-output" id="showing-function-output"><h3>Showing Function Output</h3></a>
<p>By default, if a test passes, Rust's test library captures anything printed to
standard output. For example, if we call <code>println!</code> in a test and the test
passes, we won't see the <code>println!</code> output in the terminal: we'll only see the
line that says the test passed. If a test fails, we'll see whatever was printed
to standard output with the rest of the failure message.</p>
<p>For example, Listing 11-10 has a silly function that prints out the value of
its parameter and then returns 10. We then have a test that passes and a test
that fails:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!(&quot;I got the value {}&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-10: Tests for a function that calls <code>println!</code>
</span></p>
<p>The output we'll see when we run these tests with <code>cargo test</code> is:</p>
<pre><code class="language-text">running 2 tests
test tests::this_test_will_pass ... ok
test tests::this_test_will_fail ... FAILED

failures:

---- tests::this_test_will_fail stdout ----
    I got the value 8
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left ==
right)` (left: `5`, right: `10`)', src/lib.rs:19
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Note that nowhere in this output do we see <code>I got the value 4</code>, which is what
gets printed when the test that passes runs. That output has been captured. The
output from the test that failed, <code>I got the value 8</code>, appears in the section
of the test summary output that also shows the cause of the test failure.</p>
<p>If we want to be able to see printed values for passing tests as well, the
output capture behavior can be disabled by using the <code>--nocapture</code> flag:</p>
<pre><code class="language-text">$ cargo test -- --nocapture
</code></pre>
<p>Running the tests from Listing 11-10 again with the <code>--nocapture</code> flag now
shows:</p>
<pre><code class="language-text">running 2 tests
I got the value 4
I got the value 8
test tests::this_test_will_pass ... ok
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left ==
right)` (left: `5`, right: `10`)', src/lib.rs:19
note: Run with `RUST_BACKTRACE=1` for a backtrace.
test tests::this_test_will_fail ... FAILED

failures:

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Note that the output for the tests and the test results is interleaved; this is
because the tests are running in parallel as we talked about in the previous
section. Try using both the <code>--test-threads=1</code> option and the <code>--nocapture</code>
function and see what the output looks like then!</p>
<a class="header" href="print.html#running-a-subset-of-tests-by-name" id="running-a-subset-of-tests-by-name"><h3>Running a Subset of Tests by Name</h3></a>
<p>Sometimes, running a full test suite can take a long time. If you're working on
code in a particular area, you might want to run only the tests pertaining to
that code. You can choose which tests to run by passing <code>cargo test</code> the name
or names of the test/s you want to run as an argument.</p>
<p>To demonstrate how to run a subset of tests, we'll create three tests for our
<code>add_two</code> function as shown in Listing 11-11 and choose which ones to run:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-11: Three tests with a variety of names</span></p>
<p>If we run the tests without passing any arguments, as we've already seen, all
the tests will run in parallel:</p>
<pre><code class="language-text">running 3 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<a class="header" href="print.html#running-single-tests" id="running-single-tests"><h4>Running Single Tests</h4></a>
<p>We can pass the name of any test function to <code>cargo test</code> to run only that test:</p>
<pre><code class="language-text">$ cargo test one_hundred
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>We can't specify the names of multiple tests in this way, only the first value
given to <code>cargo test</code> will be used.</p>
<a class="header" href="print.html#filtering-to-run-multiple-tests" id="filtering-to-run-multiple-tests"><h4>Filtering to Run Multiple Tests</h4></a>
<p>However, we can specify part of a test name, and any test whose name matches
that value will get run. For example, since two of our tests' names contain
<code>add</code>, we can run those two by running <code>cargo test add</code>:</p>
<pre><code class="language-text">$ cargo test add
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 2 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>This ran all tests with <code>add</code> in the name. Also note that the module in which
tests appear becomes part of the test's name, so we can run all the tests in a
module by filtering on the module's name.</p>
<!-- in what kind of situation might you need to run only some tests, when you
have lots and lots in a program? -->
<!-- We covered this in the first paragraph of the "Running a Subset of Tests
by Name" section, do you think it should be repeated so soon? Most people who
use tests have sufficient motivation for wanting to run a subset of the tests,
they just need to know how to do it with Rust, so we don't think this is a
point that needs to be emphasized multiple times. /Carol -->
<a class="header" href="print.html#ignore-some-tests-unless-specifically-requested" id="ignore-some-tests-unless-specifically-requested"><h3>Ignore Some Tests Unless Specifically Requested</h3></a>
<p>Sometimes a few specific tests can be very time-consuming to execute, so you
might want to exclude them during most runs of <code>cargo test</code>. Rather than
listing as arguments all tests you do want to run, we can instead annotate the
time consuming tests with the <code>ignore</code> attribute to exclude them:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn it_works() {
    assert!(true);
}

#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
#}</code></pre></pre>
<p>We add the <code>#[ignore]</code> line to the test we want to exclude, after <code>#[test]</code>.
Now if we run our tests, we'll see <code>it_works</code> runs, but <code>expensive_test</code> does
not:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p><code>expensive_test</code> is listed as <code>ignored</code>. If we want to run only the ignored
tests, we can ask for them to be run with <code>cargo test -- --ignored</code>:</p>
<!-- what does the double `-- --` mean? That seems interesting -->
<!-- We covered that in the second paragraph after the "Controlling How Tests
are Run" heading, and this section is beneath that heading, so I don't think a
back reference is needed /Carol -->
<!-- is that right, this way the program knows to run only the test with
`ignore` if we add this, or it knows to run all tests? -->
<!-- Is this unclear from the output that shows `expensive_test` was run and
the `it_works` test does not appear? I'm not sure how to make this clearer.
/Carol -->
<pre><code class="language-text">$ cargo test -- --ignored
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>By controlling which tests run, you can make sure your <code>cargo test</code> results
will be fast. When you're at a point that it makes sense to check the results
of the <code>ignored</code> tests and you have time to wait for the results, you can
choose to run <code>cargo test -- --ignored</code> instead.</p>
<a class="header" href="print.html#test-organization" id="test-organization"><h2>Test Organization</h2></a>
<p>As mentioned at the start of the chapter, testing is a large discipline, and
different people use different terminology and organization. The Rust community
tends to think about tests in terms of two main categories: <em>unit tests</em> and
<em>integration tests</em>. Unit tests are smaller and more focused, testing one
module in isolation at a time, and can test private interfaces. Integration
tests are entirely external to your library, and use your code in the same way
any other external code would, using only the public interface and exercising
multiple modules per test.</p>
<p>Both kinds of tests are important to ensure that the pieces of your library are
doing what you expect them to separately and together.</p>
<a class="header" href="print.html#unit-tests" id="unit-tests"><h3>Unit Tests</h3></a>
<p>The purpose of unit tests is to test each unit of code in isolation from the
rest of the code, in order to be able to quickly pinpoint where code is and is
not working as expected. We put unit tests in the <em>src</em> directory, in each file
with the code that they're testing. The convention is that we create a module
named <code>tests</code> in each file to contain the test functions, and we annotate the
module with <code>cfg(test)</code>.</p>
<a class="header" href="print.html#the-tests-module-and-cfgtest" id="the-tests-module-and-cfgtest"><h4>The Tests Module and <code>#[cfg(test)]</code></h4></a>
<p>The <code>#[cfg(test)]</code> annotation on the tests module tells Rust to compile and run
the test code only when we run <code>cargo test</code>, and not when we run <code>cargo build</code>.
This saves compile time when we only want to build the library, and saves space
in the resulting compiled artifact since the tests are not included. We'll see
that since integration tests go in a different directory, they don't need the
<code>#[cfg(test)]</code> annotation. Because unit tests go in the same files as the code,
though, we use <code>#[cfg(test)]</code>to specify that they should not be included in the
compiled result.</p>
<p>Remember that when we generated the new <code>adder</code> project in the first section of
this chapter, Cargo generated this code for us:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
    }
}
#}</code></pre></pre>
<p>This is the automatically generated test module. The attribute <code>cfg</code> stands for
<em>configuration</em>, and tells Rust that the following item should only be included
given a certain configuration. In this case, the configuration is <code>test</code>,
provided by Rust for compiling and running tests. By using this attribute,
Cargo only compiles our test code if we actively run the tests with <code>cargo test</code>. This includes any helper functions that might be within this module, in
addition to the functions annotated with <code>#[test]</code>.</p>
<a class="header" href="print.html#testing-private-functions" id="testing-private-functions"><h4>Testing Private Functions</h4></a>
<p>There's debate within the testing community about whether private functions
should be tested directly or not, and other languages make it difficult or
impossible to test private functions. Regardless of which testing ideology you
adhere to, Rust's privacy rules do allow you to test private functions.
Consider the code in Listing 11-12 with the private function <code>internal_adder</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-12: Testing a private function</span></p>
<!-- I'm not clear on why we would assume this might not be fine, why are we
highlighting this specifically? -->
<!-- We're addressing experience that the reader might bring with them from
other languages where this is not allowed; I added a sentence mentioning "other
languages" at the beginning of this section. Also testing private functions
from integration tests is not allowed, so if you did want to do this, you'd
have to do it in unit tests. /Carol -->
<p>Note that the <code>internal_adder</code> function is not marked as <code>pub</code>, but because
tests are just Rust code and the <code>tests</code> module is just another module, we can
import and call <code>internal_adder</code> in a test just fine. If you don't think
private functions should be tested, there's nothing in Rust that will compel
you to do so.</p>
<a class="header" href="print.html#integration-tests" id="integration-tests"><h3>Integration Tests</h3></a>
<p>In Rust, integration tests are entirely external to your library. They use your
library in the same way any other code would, which means they can only call
functions that are part of your library's public API. Their purpose is to test
that many parts of your library work correctly together. Units of code that
work correctly by themselves could have problems when integrated, so test
coverage of the integrated code is important as well. To create integration
tests, you first need a <em>tests</em> directory.</p>
<a class="header" href="print.html#the-tests-directory" id="the-tests-directory"><h4>The <em>tests</em> Directory</h4></a>
<p>To write integration tests for our code, we need to make a <em>tests</em> directory at
the top level of our project directory, next to <em>src</em>. Cargo knows to look for
integration test files in this directory. We can then make as many test files
as we'd like in this directory, and Cargo will compile each of the files as an
individual crate.</p>
<p>Let's give it a try! Keep the code from Listing 11-12 in <em>src/lib.rs</em>. Make a
<em>tests</em> directory, then make a new file named <em>tests/integration_test.rs</em>, and
enter the code in Listing 11-13.</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">extern crate adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p><span class="caption">Listing 11-13: An integration test of a function in the
<code>adder</code> crate </span></p>
<p>We've added <code>extern crate adder</code> at the top, which we didn't need in the unit
tests. This is because each test in the <code>tests</code> directory is an entirely
separate crate, so we need to import our library into each of them. Integration
tests use the library like any other consumer of it would, by importing the
crate and using only the public API.</p>
<p>We don't need to annotate any code in <em>tests/integration_test.rs</em> with
<code>#[cfg(test)]</code>. Cargo treats the <code>tests</code> directory specially and will only
compile files in this directory if we run <code>cargo test</code>. Let's try running
<code>cargo test</code> now:</p>
<pre><code class="language-text">cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running target/debug/deps/adder-abcabcabc

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/debug/deps/integration_test-ce99bcc2479f4607

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<!-- what are the doc tests? How do we tell the difference between unit and
integration tests here? -->
<!-- We mentioned documentation tests in the beginning of this chapter /Carol
-->
<p>Now we have three sections of output: the unit tests, the integration test, and
the doc tests. The first section for the unit tests is the same as we have been
seeing: one line for each unit test (we have one named <code>internal</code> that we added
in Listing 11-12), then a summary line for the unit tests.</p>
<p>The integration tests section starts with the line that says <code>Running target/debug/deps/integration-test-ce99bcc2479f4607</code> (the hash at the end of
your output will be different). Then there's a line for each test function in
that integration test, and a summary line for the results of the integration
test just before the <code>Doc-tests adder</code> section starts.</p>
<p>Note that adding more unit test functions in any <em>src</em> file will add more test
result lines to the unit tests section. Adding more test functions to the
integration test file we created will add more lines to the integration test
section. Each integration test file gets its own section, so if we add more
files in the <em>tests</em> directory, there will be more integration test sections.</p>
<p>We can still run a particular integration test function by specifying the test
function's name as an argument to <code>cargo test</code>. To run all of the tests in a
particular integration test file, use the <code>--test</code> argument of <code>cargo test</code>
followed by the name of the file:</p>
<pre><code class="language-text">$ cargo test --test integration_test
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/integration_test-952a27e0126bb565

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>This tests only the file that we specified from the <em>tests</em> directory.</p>
<a class="header" href="print.html#submodules-in-integration-tests" id="submodules-in-integration-tests"><h4>Submodules in Integration Tests</h4></a>
<p>As you add more integration tests, you may want to make more than one file in
the <em>tests</em> directory to help organize them; for example, to group the test
functions by the functionality they're testing. As we mentioned, each file in
the <em>tests</em> directory is compiled as its own separate crate.</p>
<p>Treating each integration test file as its own crate is useful to create
separate scopes that are more like the way end users will be using your crate.
However, this means files in the <em>tests</em> directory don't share the same
behavior as files in <em>src</em> do that we learned about in Chapter 7 regarding how
to separate code into modules and files.</p>
<p>The different behavior of files in the <em>tests</em> directory is usually most
noticeable if you have a set of helper functions that would be useful in
multiple integration test files, and you try to follow the steps from Chapter 7
to extract them into a common module. For example, if we create
<em>tests/common.rs</em> and place this function named <code>setup</code> in it, where we could
put some code that we want to be able to call from multiple test functions in
multiple test files:</p>
<p><span class="filename">Filename: tests/common.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn setup() {
    // setup code specific to your library's tests would go here
}
#}</code></pre></pre>
<p>If we run the tests again, we'll see a new section in the test output for the
<em>common.rs</em> file, even though this file doesn't contain any test functions, nor
are we calling the <code>setup</code> function from anywhere:</p>
<pre><code class="language-text">running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/debug/deps/common-b8b07b6f1be2db70

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured

     Running target/debug/deps/integration_test-d993c68b431d39df

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<!-- The new section is lines 6-10, will ghost everything else in libreoffice
/Carol -->
<p>Having <code>common</code> show up in the test results with <code>running 0 tests</code> displayed
for it is not what we wanted; we just wanted to be able to share some code with
the other integration test files.</p>
<p>In order to not have <code>common</code> show up in the test output, we need to use the
other method of extracting code into a file that we learned about in Chapter 7:
instead of creating <em>tests/common.rs</em>, we'll create <em>tests/common/mod.rs</em>. When
we move the <code>setup</code> function code into <em>tests/common/mod.rs</em> and get rid of the
<em>tests/common.rs</em> file, the section in the test output will no longer show up.
Files in subdirectories of the <em>tests</em> directory do not get compiled as
separate crates or have sections in the test output.</p>
<p>Once we have <em>tests/common/mod.rs</em>, we can use it from any of the integration
test files as a module. Here's an example of calling the <code>setup</code> function from
the <code>it_adds_two</code> test in <em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">extern crate adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>Note the <code>mod common;</code> declaration is the same as the module declarations we
did in Chapter 7. Then in the test function, we can call the <code>common::setup()</code>
function.</p>
<a class="header" href="print.html#integration-tests-for-binary-crates" id="integration-tests-for-binary-crates"><h4>Integration Tests for Binary Crates</h4></a>
<p>If our project is a binary crate that only contains a <em>src/main.rs</em> and does
not have a <em>src/lib.rs</em>, we aren't able to create integration tests in the
<em>tests</em> directory and use <code>extern crate</code> to import functions defined in
<em>src/main.rs</em>. Only library crates expose functions that other crates are able
to call and use; binary crates are meant to be run on their own.</p>
<p>This is one of the reasons Rust projects that provide a binary have a
straightforward <em>src/main.rs</em> that calls logic that lives in <em>src/lib.rs</em>. With
that structure, integration tests <em>can</em> test the library crate by using <code>extern crate</code> to cover the important functionality. If the important functionality
works, the small amount of code in <em>src/main.rs</em> will work as well, and that
small amount of code does not need to be tested.</p>
<a class="header" href="print.html#summary-3" id="summary-3"><h2>Summary</h2></a>
<p>Rust's testing features provide a way to specify how code should function to
ensure it continues to work as we expect even as we make changes. Unit tests
exercise different parts of a library separately and can test private
implementation details. Integration tests cover the use of many parts of the
library working together, and they use the library's public API to test the
code in the same way external code will use it. Even though Rust's type system
and ownership rules help prevent some kinds of bugs, tests are still important
to help reduce logic bugs having to do with how your code is expected to behave.</p>
<p>Let's put together the knowledge from this chapter and other previous chapters
and work on a project in the next chapter!</p>
<a class="header" href="print.html#an-io-project-building-a-small-grep" id="an-io-project-building-a-small-grep"><h1>An I/O Project Building a Small Grep</h1></a>
<!-- We might need a more descriptive title, something that captures the new
elements we're introducing -- are we going to cover things like environment
variables more in later chapters, or is this the only place we explain how to
use them? -->
<!-- This is the only place we were planning on explaining both environment
variables and printing to standard error. These are things that people commonly
want to know how to do in Rust, but there's not much more than what we've said
here about them, people just want to know how to do them in Rust. We realize
that those sections make this chapter long, but think it's worth it to include
information that people want. We've gotten really positive feedback from people
who have read this chapter online; people who like learning through projects
have really enjoyed this chapter. /Carol-->
<p>This chapter is both a recap of the many skills you've learned so far and an
exploration of a few more standard library features. We're going to build a
command-line tool that interacts with file and command line input/output to
practice some of the Rust you now have under your belt.</p>
<p>Rust's speed, safety, 'single binary' output, and cross-platform support make
it a good language for creating command line tools, so for our project we'll
make our own version of the classic command line tool <code>grep</code>. Grep is an
acronym for &quot;Globally search a Regular Expression and Print.&quot; In the simplest
use case, <code>grep</code> searches a specified file for a specified string using the
following steps:</p>
<ul>
<li>Take as arguments a filename and a string.</li>
<li>Read the file.</li>
<li>Find lines in the file that contain the string argument.</li>
<li>Print out those lines.</li>
</ul>
<p>We'll also show how to use environment variables and print to standard error
instead of standard out; these techniques are commonly used in command line
tools.</p>
<p>One Rust community member, Andrew Gallant, has already created a
fully-featured, very fast version of <code>grep</code>, called <code>ripgrep</code>. By comparison,
our version of <code>grep</code> will be fairly simple, this chapter will give you some of
the background knowledge to help you understand a real-world project like
<code>ripgrep</code>.</p>
<p>This project will bring together a number of concepts you've learned so far:</p>
<ul>
<li>Organizing code (using what we learned in modules, Chapter 7)</li>
<li>Using vectors and strings (collections, Chapter 8)</li>
<li>Handling errors (Chapter 9)</li>
<li>Using traits and lifetimes where appropriate (Chapter 10)</li>
<li>Writing tests (Chapter 11)</li>
</ul>
<p>We'll also briefly introduce closures, iterators, and trait objects, which
Chapters 13 and 17 will cover in detail.</p>
<p>Let's create a new project with, as always, <code>cargo new</code>. We're calling our
project <code>greprs</code> to distinguish from the <code>grep</code> tool that you may already have
on your system:</p>
<pre><code class="language-text">$ cargo new --bin greprs
     Created binary (application) `greprs` project
$ cd greprs
</code></pre>
<a class="header" href="print.html#accepting-command-line-arguments" id="accepting-command-line-arguments"><h2>Accepting Command Line Arguments</h2></a>
<p>Our first task is to make <code>greprs</code> able to accept its two command line
arguments: the filename and a string to search for. That is, we want to be able
to run our program with <code>cargo run</code>, a string to search for, and a path to a
file to search in, like so:</p>
<pre><code class="language-text">$ cargo run searchstring example-filename.txt
</code></pre>
<p>Right now, the program generated by <code>cargo new</code> ignores any arguments we give
it. There are some existing libraries on crates.io that can help us accept
command line arguments, but since we're learning, let's implement this
ourselves.</p>
<!--Below -- I'm not clear what we need the args function for, yet, can you set
it out more concretely? Otherwise, will it make more sense in context of the
code later? Is this function needed to allow our function to accept arguments,
is that was "args" is for? -->
<!-- We mentioned in the intro to this chapter that grep takes as arguments a
filename and a string. I've added an example of how we want to run our
resulting tool and what we want the behavior to be, please let me know if this
doesn't clear it up. /Carol-->
<a class="header" href="print.html#reading-the-argument-values" id="reading-the-argument-values"><h3>Reading the Argument Values</h3></a>
<p>In order to be able to get the values of command line arguments passed to our
program, we'll need to call a function provided in Rust's standard library:
<code>std::env::args</code>. This function returns an <em>iterator</em> of the command line
arguments that were given to our program. We haven't discussed iterators yet,
and we'll cover them fully in Chapter 13, but for our purposes now we only need
to know two things about iterators:</p>
<ol>
<li>Iterators produce a series of values.</li>
<li>We can call the <code>collect</code> function on an iterator to turn it into a vector
containing all of the elements the iterator produces.</li>
</ol>
<p>Let's give it a try: use the code in Listing 12-1 to read any command line
arguments passed to our <code>greprs</code> program and collect them into a vector.</p>
<!-- Give what a try, here, what are we making? Can you lay that out? I've
tried above but I'm not sure it's complete -->
<!-- We're not creating anything, we're just reading. I'm not sure if I've made
this clearer. /Carol -->
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);
}
</code></pre></pre>
<p>Listing 12-1: Collect the command line arguments into a vector and print them
out</p>
<!-- Will add wingdings in libreoffice /Carol -->
<p>First, we bring the <code>std::env</code> module into scope with a <code>use</code> statement so that
we can use its <code>args</code> function. Notice the <code>std::env::args</code> function is nested
in two levels of modules. As we talked about in Chapter 7, in cases where the
desired function is nested in more than one module, it's conventional to bring
the parent module into scope, rather than the function itself. This lets us
easily use other functions from <code>std::env</code>. It's also less ambiguous than
adding <code>use std::env::args;</code> then calling the function with just <code>args</code>; that
might look like a function that's defined in the current module.</p>
<!-- We realized that we need to add the following caveat to fully specify
the behavior of `std::env::args` /Carol -->
<!-- PROD: START BOX -->
<blockquote>
<p>Note: <code>std::env::args</code> will panic if any argument contains invalid Unicode.
If you need to accept arguments containing invalid Unicode, use
<code>std::env::args_os</code> instead. That function returns <code>OsString</code> values instead
of <code>String</code> values. We've chosen to use <code>std::env::args</code> here for simplicity
because <code>OsString</code> values differ per-platform and are more complex to work
with than <code>String</code> values.</p>
</blockquote>
<!-- PROD: END BOX -->
<!--what is it we're making into a vector here, the arguments we pass?-->
<!-- The iterator of the arguments. /Carol -->
<p>On the first line of <code>main</code>, we call <code>env::args</code>, and immediately use <code>collect</code>
to turn the iterator into a vector containing all of the iterator's values. The
<code>collect</code> function can be used to create many kinds of collections, so we
explicitly annotate the type of <code>args</code> to specify that we want a vector of
strings. Though we very rarely need to annotate types in Rust, <code>collect</code> is one
function you do often need to annotate because Rust isn't able to infer what
kind of collection you want.</p>
<p>Finally, we print out the vector with the debug formatter, <code>:?</code>. Let's try
running our code with no arguments, and then with two arguments:</p>
<pre><code class="language-text">$ cargo run
[&quot;target/debug/greprs&quot;]

$ cargo run needle haystack
...snip...
[&quot;target/debug/greprs&quot;, &quot;needle&quot;, &quot;haystack&quot;]
</code></pre>
<!--Below --- This initially confused me, do you mean that the argument at
index 0 is taken up by the name of the binary, so we start arguments at 1 when
setting them? It seems like it's something like that, reading on, and I've
edited as such, can you check? -->
<!-- Mentioning the indexes here seemed repetitive with the text after Listing
12-2. We're not "setting" arguments here, we're saving the value in variables.
I've hopefully cleared this up without needing to introduce repetition.
/Carol-->
<p>You may notice that the first value in the vector is &quot;target/debug/greprs&quot;,
which is the name of our binary. The reasons for this are out of the scope of
this chapter, but we'll need to remember this as we save the two arguments we
need.</p>
<a class="header" href="print.html#saving-the-argument-values-in-variables" id="saving-the-argument-values-in-variables"><h3>Saving the Argument Values in Variables</h3></a>
<p>Printing out the value of the vector of arguments just illustrated that we're
able to access the values specified as command line arguments from our program.
That's not what we actually want to do, though, we want to save the values of
the two arguments in variables so that we can use the values in our program.
Let's do that as shown in Listing 12-2:</p>
<!-- By 'find the ones we care about' did you mean set particular arguments so
the user knows what to enter? I'm a little confused about what we are doing,
I've tried to clarify above -->
<!-- We're incrementally adding features and adding some code that helps the
reader be able to see and experience what the code is doing rather than just
taking our word for it. I've hopefully clarified below. /Carol -->
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    println!(&quot;Searching for {}&quot;, query);
    println!(&quot;In file {}&quot;, filename);
}
</code></pre></pre>
<p>Listing 12-2: Create variables to hold the query argument and filename argument</p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>As we saw when we printed out the vector, the program's name takes up the first
value in the vector at <code>args[0]</code>, so we're starting at index <code>1</code>. The first
argument <code>greprs</code> takes is the string we're searching for, so we put a
reference to the first argument in the variable <code>query</code>. The second argument
will be the filename, so we put a reference to the second argument in the
variable <code>filename</code>.</p>
<p>We're temporarily printing out the values of these variables, again to prove to
ourselves that our code is working as we intend. Let's try running this program
again with the arguments <code>test</code> and <code>sample.txt</code>:</p>
<pre><code class="language-text">$ cargo run test sample.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/greprs test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>Great, it's working! We're saving the values of the arguments that we need into
the right variables. Later we'll add some error handling to deal with
situations such as when the user provides no arguments, but for now we'll
ignore that and work on adding file reading capabilities instead.</p>
<a class="header" href="print.html#reading-a-file" id="reading-a-file"><h2>Reading a File</h2></a>
<p>Next, we're going to read the file that we specify in the filename command line
argument. First, we need a sample file to test it with---the best kind of file
to use to make sure that <code>greprs</code> is working is one with a small amount of text
over multiple lines with some repeated words. Listing 12-3 has an Emily
Dickinson poem that will work well! Create a file called <code>poem.txt</code> at the root
level of your project, and enter the poem &quot;I'm nobody! Who are you?&quot;:</p>
<p><span class="filename">Filename: poem.txt</span></p>
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us — don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">Listing 12-3: The poem &quot;I'm nobody! Who are you?&quot; by
Emily Dickinson that will make a good test case</span></p>
<!-- Public domain Emily Dickinson poem. This will work best with something
short, but that has multiple lines and some repetition. We could search through
code; that gets a bit meta and possibly confusing... Changes to this are most
welcome. /Carol -->
<!-- :D I like it! I'm all for keeping -->
<!-- Great! /Carol -->
<p>With that in place, edit <em>src/main.rs</em> and add code to open the file as shown
in Listing 12-4:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;
use std::fs::File;
use std::io::prelude::*;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    println!(&quot;Searching for {}&quot;, query);
    println!(&quot;In file {}&quot;, filename);

    let mut f = File::open(filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents).expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}
</code></pre></pre>
<p>Listing 12-4: Reading the contents of the file specified by the second argument</p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>First, we add some more <code>use</code> statements to bring in relevant parts of the
standard library: we need <code>std::fs::File</code> for dealing with files, and
<code>std::io::prelude::*</code> contains various traits that are useful when doing I/O,
including file I/O. In the same way that Rust has a general prelude that brings
certain things into scope automatically, the <code>std::io</code> module has its own
prelude of common things you'll need when working with I/O. Unlike the default
prelude, we must explicitly <code>use</code> the prelude in <code>std::io</code>.</p>
<p>In <code>main</code>, we've added three things: first, we get a mutable handle to the file
by calling the <code>File::open</code> function and passing it the value of the <code>filename</code>
variable. Second, we create a variable called <code>contents</code> and set it to a
mutable, empty <code>String</code>. This will hold the content of the file after we read
it in. Third, we call <code>read_to_string</code> on our file handle and pass a mutable
reference to <code>contents</code> as an argument.</p>
<p>After those lines, we've again added temporary <code>println!</code> that prints out the
value in <code>contents</code> after we've read the file so we can check that our program
is working so far.</p>
<p>Let's try running this code with any string as the first command line argument
(since we haven't implemented the searching part yet) and our <em>poem.txt</em> file
as the second argument:</p>
<pre><code class="language-text">$ cargo run the poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/greprs the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us — don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Great! Our code read in and printed out the content of the file. We've got a
few flaws though: the <code>main</code> function has multiple responsibilities, and we're
not handling errors as well as we could be. While our program is still small,
these flaws aren't a big problem, but as our program grows, it will be harder
to fix them cleanly. It's good practice to begin refactoring early on when
developing a program, as it's much easier to refactor smaller amounts of code,
so we'll do that now.</p>
<a class="header" href="print.html#refactoring-to-improve-modularity-and-error-handling" id="refactoring-to-improve-modularity-and-error-handling"><h2>Refactoring to Improve Modularity and Error Handling</h2></a>
<p>There are four problems that we'd like to fix to improve our program, and they
have to do with the way the program is structured and how it's handling
potential errors.</p>
<p>First, our <code>main</code> function now performs two tasks: it parses arguments and
opens up files. For such a small function, this isn't a huge problem. However,
if we keep growing our program inside of <code>main</code>, the number of separate tasks
the <code>main</code> function handles will grow. As a function gains responsibilities, it
gets harder to reason about, harder to test, and harder to change without
breaking one of its parts. It's better to separate out functionality so that
each function is responsible for one task.</p>
<p>This also ties into our second problem: while <code>query</code> and <code>filename</code> are
configuration variables to our program, variables like <code>f</code> and <code>contents</code> are
used to perform our program's logic. The longer <code>main</code> gets, the more variables
we're going to need to bring into scope; the more variables we have in scope,
the harder it is to keep track of the purpose of each. It's better to group the
configuration variables into one structure to make their purpose clear.</p>
<p>The third problem is that we've used <code>expect</code> to print out an error message if
opening the file fails, but the error message only says <code>file not found</code>. There
are a number of ways that opening a file can fail besides a missing file: for
example, the file might exist, but we might not have permission to open it.
Right now, if we're in that situation, we'd print the <code>file not found</code> error
message that would give the user the wrong advice!</p>
<p>Fourth, we use <code>expect</code> repeatedly to deal with different errors, and if the
user runs our programs without specifying enough arguments, they'll get an
&quot;index out of bounds&quot; error from Rust that doesn't clearly explain the problem.
It would be better if all our error handling code was in one place so that
future maintainers only have one place to consult in the code if the error
handling logic needs to change. Having all the error handling code in one place
will also help us to ensure that we're printing messages that will be
meaningful to our end users.</p>
<p>Let's address these problems by refactoring our project.</p>
<a class="header" href="print.html#separation-of-concerns-for-binary-projects" id="separation-of-concerns-for-binary-projects"><h3>Separation of Concerns for Binary Projects</h3></a>
<p>The organizational problem of having the <code>main</code> function responsible for
multiple tasks is common to many binary projects, so the Rust community has
developed a kind of guideline process for splitting up the separate concerns of
a binary program when <code>main</code> starts getting large. The process has the
following steps:</p>
<ol>
<li>Split your program into both a <em>main.rs</em> and a <em>lib.rs</em> and move your
program's logic into <em>lib.rs</em>.</li>
<li>While your command line parsing logic is small, it can remain in <em>main.rs</em>.</li>
<li>When the command line parsing logic starts getting complicated, extract it
from <em>main.rs</em> into <em>lib.rs</em> as well.</li>
<li>The responsibilities that remain in the <code>main</code> function after this process
should be:
<ul>
<li>Calling the command line parsing logic with the argument values</li>
<li>Setting up any other configuration</li>
<li>Calling a <code>run</code> function in <em>lib.rs</em></li>
<li>If <code>run</code> returns an error, handling that error</li>
</ul>
</li>
</ol>
<p>This pattern is all about separating concerns: <em>main.rs</em> handles running the
program, and <em>lib.rs</em> handles all of the logic of the task at hand. Because we
can't test the <code>main</code> function directly, this structure lets us test all of our
program's logic by moving it into functions in <em>lib.rs</em>. The only code that
remains in <em>main.rs</em> will be small enough to verify its correctness by reading
it. Let's re-work our program by following this process.</p>
<!--Since main is already handling the parsing of arguments, why do we need to
add a new function for it, can you say how that improves things? -->
<!-- Sorry, the steps we had were unclear. We've tried rewording. /Carol -->
<a class="header" href="print.html#extracting-the-argument-parser" id="extracting-the-argument-parser"><h3>Extracting the Argument Parser</h3></a>
<p>First, we'll extract the functionality for parsing arguments. Listing 12-5
shows the new start of <code>main</code> that calls a new function <code>parse_config</code>, which
we're still going to define in <em>src/main.rs</em> for the moment:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, filename) = parse_config(&amp;args);

    // ...snip...
}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let filename = &amp;args[2];

    (query, filename)
}
</code></pre>
<p><span class="caption">Listing 12-5: Extract a <code>parse_config</code> function from
<code>main</code></span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>We're still collecting the command line arguments into a vector, but instead of
assigning the argument value at index 1 to the variable <code>query</code> and the
argument value at index 2 to the variable <code>filename</code> within the <code>main</code>
function, we pass the whole vector to the <code>parse_config</code> function. The
<code>parse_config</code> function then holds the logic that knows which argument goes in
which variable, and passes the values back to <code>main</code>. We still create the
<code>query</code> and <code>filename</code> variables in <code>main</code>, but <code>main</code> no longer has the
responsibility of knowing how the command line arguments and variables
correspond.</p>
<p>This may seem like overkill for our small program, but we're refactoring in
small, incremental steps. After making this change, run the program again to
verify that the argument parsing still works. It's good to check your progress
often, as that will help you identify the cause of problems when they occur.</p>
<a class="header" href="print.html#grouping-configuration-values" id="grouping-configuration-values"><h4>Grouping Configuration Values</h4></a>
<p>We can take another small step to improve this function further. At the moment,
we're returning a tuple, but then we immediately break that tuple up into
individual parts again. This is a sign that perhaps we don't have the right
abstraction yet.</p>
<p>Another indicator that there's room for improvement is the <code>config</code> part of
<code>parse_config</code>, which implies that the two values we return are related and are
both part of one configuration value. We're not currently conveying this
meaning in the structure of the data other than grouping the two values into a
tuple: we could put the two values into one struct and give each of the struct
fields a meaningful name. This will make it easier for future maintainers of
this code to understand how the different values relate to each other and what
their purpose is.</p>
<!-- above -- I'm not sure why this is a problem --- because they aren't
currently bound together? And why does it imply that -->
<blockquote>
<p>Note: some people call this anti-pattern of using primitive values when a
complex type would be more appropriate <em>primitive obsession</em>.</p>
</blockquote>
<!-- Ah, I see, so the problems here stem from using simple types to do tasks
inefficiently, when a more complex task could handle it in ways that improve...
behavior? Readability? Can you say as much? -->
<!-- I've tried to clarify above. Note that when Rust programmers talk about
"efficiency", they usually mean "run-time performance", whereas here we're
talking about code design and maintainability and not addressing performance
at all. /Carol -->
<p>Listing 12-6 shows the addition of a struct named <code>Config</code> defined to have
fields named <code>query</code> and <code>filename</code>. We've also changed the <code>parse_config</code>
function to return an instance of the <code>Config</code> struct, and updated <code>main</code> to
use the struct fields rather than having separate variables:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"># use std::env;
# use std::fs::File;
#
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    // ...snip...
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
</code></pre></pre>
<p>Listing 12-6: Refactoring <code>parse_config</code> to return an instance of a <code>Config</code>
struct</p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>The signature of <code>parse_config</code> now indicates that it returns a <code>Config</code> value.
In the body of <code>parse_config</code>, where we used to return string slices that
reference <code>String</code> values in <code>args</code>, we've now chosen to define <code>Config</code> to
contain owned <code>String</code> values. The <code>args</code> variable in <code>main</code> is the owner of
the argument values and is only letting the <code>parse_config</code> function borrow
them, though, which means we'd violate Rust's borrowing rules if <code>Config</code> tried
to take ownership of the values in <code>args</code>.</p>
<p>There are a number of different ways we could manage the <code>String</code> data, and the
easiest, though somewhat inefficient, route is to call the <code>clone</code> method on
the values. This will make a full copy of the data for the <code>Config</code> instance to
own, which does take more time and memory than storing a reference to the
string data. However, cloning the data also makes our code very straightforward
since we don't have to manage the lifetimes of the references, so in this
circumstance giving up a little performance to gain simplicity is a worthwhile
trade-off.</p>
<!-- This box is intended to go right after the paragraph talking about `clone`
/Carol -->
<!-- PROD: START BOX -->
<blockquote>
<a class="header" href="print.html#the-tradeoffs-of-using-clone" id="the-tradeoffs-of-using-clone"><h4>The Tradeoffs of Using <code>clone</code></h4></a>
<p>There's a tendency among many Rustaceans to avoid using <code>clone</code> to fix
ownership problems because of its runtime cost. In Chapter 13 on iterators,
you'll learn how to use more efficient methods in this kind of situation, but
for now, it's okay to copy a few strings to keep making progress since we'll
only make these copies once, and our filename and query string are both very
small. It's better to have a working program that's a bit inefficient than
try to hyper-optimize code on your first pass. As you get more experienced
with Rust, it'll be easier to go straight to the desirable method, but for
now it's perfectly acceptable to call <code>clone</code>.</p>
</blockquote>
<!-- PROD: END BOX -->
<p>We've updated <code>main</code> so that it places the instance of <code>Config</code> that
<code>parse_config</code> returns into a variable named <code>config</code>, and updated the code
that previously used the separate <code>query</code> and <code>filename</code> variables so that is
now uses the fields on the <code>Config</code> struct instead.</p>
<p>Our code now more clearly conveys our intent that <code>query</code> and <code>filename</code> are
related and their purpose is to configure how the program will work. Any code
that uses these values knows to find them in the <code>config</code> instance in the
fields named for their purpose.</p>
<a class="header" href="print.html#creating-a-constructor-for-config" id="creating-a-constructor-for-config"><h4>Creating a Constructor for <code>Config</code></h4></a>
<!-- Can you lay out what we intend to do in this section? I wasn't sure even
at the end what we did and why --- why did we create it as parse_config to then
change it to new? -->
<!-- We're making small, incremental changes. In addition to being good
software development practice, we were hoping that by changing one thing at a
time, the process of improving code's design would be easier to follow rather
than just jumping to the best solution. We extracted code into a function, then
it was clearer that we should introduce a struct, then it was clear that the
function we extracted is really a constructor of `Config` and should be written
as such. This refactoring process should be familiar to software developers.
I've tried to add a little recap to the start of this section, I hope that
helps. /Carol -->
<p>So far, we've extracted the logic responsible for parsing the command line
arguments from <code>main</code> into the <code>parse_config</code> function, which helped us to see
that the <code>query</code> and <code>filename</code> values were related and that relationship
should be conveyed in our code. We then added a <code>Config</code> struct to name the
related purpose of <code>query</code> and <code>filename</code>, and to be able to return the values'
names as struct field names from the <code>parse_config</code> function.</p>
<p>So now that the purpose of the <code>parse_config</code> function is to create a <code>Config</code>
instance, we can change <code>parse_config</code> from being a plain function into a
function named <code>new</code> that is associated with the <code>Config</code> struct. Making this
change will make our code more idiomatic: we can create instances of types in
the standard library like <code>String</code> by calling <code>String::new</code>, and by changing
<code>parse_config</code> to be a <code>new</code> function associated with <code>Config</code>, we'll be able
to create instances of <code>Config</code> by calling <code>Config::new</code>. Listing 12-7 shows
the changes we'll need to make:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"># use std::env;
#
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);

    // ...snip...
}

# struct Config {
#     query: String,
#     filename: String,
# }
#
// ...snip...

impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
</code></pre></pre>
<p><span class="caption">Listing 12-7: Changing <code>parse_config</code> into
<code>Config::new</code></span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>We've updated <code>main</code> where we were calling <code>parse_config</code> to instead call
<code>Config::new</code>. We've changed the name of <code>parse_config</code> to <code>new</code> and moved it
within an <code>impl</code> block, which makes the <code>new</code> function associated with
<code>Config</code>. Try compiling this again to make sure it works.</p>
<a class="header" href="print.html#fixing-the-error-handling" id="fixing-the-error-handling"><h3>Fixing the Error Handling</h3></a>
<p>Now we'll work on fixing our error handling. Recall that we mentioned
attempting to access the values in the <code>args</code> vector at index 1 or index 2 will
cause the program to panic if the vector contains fewer than 3 items. Try
running the program without any arguments; it will look like this:</p>
<pre><code class="language-text">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/greprs`
thread 'main' panicked at 'index out of bounds: the len is 1
but the index is 1',  /stable-dist-rustc/build/src/libcollections/vec.rs:1307
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p><code>index out of bounds: the len is 1 but the index is 1</code> is an error message that
is intended for programmers, and won't really help our end users understand
what happened and what they should do instead. Let's fix that now.</p>
<a class="header" href="print.html#improving-the-error-message" id="improving-the-error-message"><h4>Improving the Error Message</h4></a>
<p>In Listing 12-8, we're adding a check in the <code>new</code> function to check that the
slice is long enough before accessing index 1 and 2. If the slice isn't long
enough, we panic with a better error message than the <code>index out of bounds</code>
message:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">// ...snip...
fn new(args: &amp;[String]) -&gt; Config {
    if args.len() &lt; 3 {
        panic!(&quot;not enough arguments&quot;);
    }
    // ...snip...
</code></pre>
<p><span class="caption">Listing 12-8: Adding a check for the number of
arguments</span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>This is similar to the <code>Guess::new</code> function we wrote in Listing 9-8, where we
called <code>panic!</code> if the <code>value</code> argument was out of the range of valid values.
Instead of checking for a range of values, we're checking that the length of
<code>args</code> is at least 3, and the rest of the function can operate under the
assumption that this condition has been met. If <code>args</code> has fewer than 3 items,
this condition will be true, and we call the <code>panic!</code> macro to end the program
immediately.</p>
<p>With these extra few lines of code in <code>new</code>, let's try running our program
without any arguments again and see what the error looks like now:</p>
<pre><code class="language-bash">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/greprs`
thread 'main' panicked at 'not enough arguments', src/main.rs:29
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>This output is better, we now have a reasonable error message. However, we also
have a bunch of extra information we don't want to give to our users. So
perhaps using the technique we used in Listing 9-8 isn't the best to use here;
a call to <code>panic!</code> is more appropriate for a programming problem rather than a
usage problem anyway, as we discussed in Chapter 9. Instead, we can use the
other technique we learned about in that chapter: returning a <code>Result</code> that can
indicate either success or an error.</p>
<!-- Below -- how does using new fix this, can you lay that our up front? -->
<!-- I'm not sure what you mean, we're already using `new` and the fix continues
to use `new`... /Carol -->
<a class="header" href="print.html#returning-a-result-from-new-instead-of-calling-panic" id="returning-a-result-from-new-instead-of-calling-panic"><h4>Returning a <code>Result</code> from <code>new</code> Instead of Calling <code>panic!</code></h4></a>
<p>We can choose to instead return a <code>Result</code> value that will contain a <code>Config</code>
instance in the successful case, and will describe the problem in the error
case. When <code>Config::new</code> is communicating to <code>main</code>, we can use Rust's way of
signaling that there was a problem using the <code>Result</code> type. Then we can change
<code>main</code> to convert an <code>Err</code> variant into a nicer error for our users, without
the surrounding text about <code>thread 'main'</code> and <code>RUST_BACKTRACE</code> that a call to
<code>panic!</code> causes.</p>
<p>Listing 12-9 shows the changes to the return value of <code>Config::new</code> and the
body of the function needed to return a <code>Result</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
</code></pre>
<p><span class="caption">Listing 12-9: Return a <code>Result</code> from <code>Config::new</code></span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<!-- what does returning a Result rather than a Config do? -->
<!-- This is what Chapter 9 was about, I've added a few more references
to that chapter to reinforce the connection /Carol -->
<p>Our <code>new</code> function now returns a <code>Result</code>, with a <code>Config</code> instance in the
success case and a <code>&amp;'static str</code> in the error case. Recall from &quot;The Static
Lifetime&quot; section in Chapter 10 that <code>&amp;'static str</code> is the type of string
literals, which is our error message type for now.</p>
<p>We've made two changes in the body of the <code>new</code> function: instead of calling
<code>panic!</code> when the user doesn't pass enough arguments, we now return an <code>Err</code>
value, and we've wrapped the <code>Config</code> return value in an <code>Ok</code>. These changes
make the function conform to its new type signature.</p>
<p>By having <code>Config::new</code> return an <code>Err</code> value, it allows the <code>main</code> function to
handle the <code>Result</code> value returned from the <code>new</code> function and exit the process
more cleanly in the error case.</p>
<a class="header" href="print.html#calling-confignew-and-handling-errors" id="calling-confignew-and-handling-errors"><h4>Calling <code>Config::new</code> and Handling Errors</h4></a>
<p>In order to handle the error case and print a user-friendly message, we need to
update <code>main</code> to handle the <code>Result</code> that <code>Config::new</code> is now returning as
shown in Listing 12-10. We're also going to implement by hand something that
<code>panic!</code> handled for us: exiting the command line tool with an error code of 1.
A nonzero exit status is a convention to signal to the process that called our
program that our program ended with an error state.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // ...snip...
</code></pre>
<p><span class="caption">Listing 12-10: Exiting with an error code if creating a
new <code>Config</code> fails</span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<!-- In the `main` function itself, we'll handle the `Result` value returned
from the `new` function and exit the process in a cleaner way if `Config::new`
returns an `Err` value.-->
<!-- I moved this line above to the previous section, it seems to at least
partially answer some of my earlier confusions, though I'm not following this
as well as I'd like so not sure if I have this right, can you confirm either
way whether that move makes sense? -->
<!-- That's fine /Carol -->
<p>In this listing, we're using a method we haven't covered before:
<code>unwrap_or_else</code>, which is defined on <code>Result&lt;T, E&gt;</code> by the standard library.
Using <code>unwrap_or_else</code> allows us to define some custom, non-<code>panic!</code> error
handling. If the <code>Result</code> is an <code>Ok</code> value, this method's behavior is similar
to <code>unwrap</code>: it returns the inner value <code>Ok</code> is wrapping. However, if the value
is an <code>Err</code> value, this method calls the code in the <em>closure</em>, which is an
anonymous function we define and pass as an argument to <code>unwrap_or_else</code>. We'll
be covering closures in more detail in Chapter 13. What you need to know for
now is that <code>unwrap_or_else</code> will pass the inner value of the <code>Err</code>, which in
this case is the static string <code>not enough arguments</code> that we added in Listing
12-9, to our closure in the argument <code>err</code> that appears between the vertical
pipes. The code in the closure can then use the <code>err</code> value when it runs.</p>
<!--Can you give a high-level idea of what the closure does with it? -->
<!-- Does with what? I've tried to elaborate in the above and below paragraphs,
but I'm not sure exactly what's confusing /Carol -->
<p>We've added a new <code>use</code> line to import <code>process</code> from the standard library. The
code in the closure that will get run in the error case is only two lines: we
print out the <code>err</code> value, then call <code>std::process::exit</code> (we've added a new
<code>use</code> line at the top to import <code>process</code> from the standard library).
<code>process::exit</code> will stop the program immediately and return the number that
was passed as the exit status code. This is similar to the <code>panic!</code>-based
handling we used in Listing 12-8, with the exception that we no longer get all
the extra output. Let's try it:</p>
<pre><code class="language-text">$ cargo run
   Compiling greprs v0.1.0 (file:///projects/greprs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48 secs
     Running `target/debug/greprs`
Problem parsing arguments: not enough arguments
</code></pre>
<p>Great! This output is much friendlier for our users.</p>
<a class="header" href="print.html#extracting-a-run-function" id="extracting-a-run-function"><h3>Extracting a <code>run</code> Function</h3></a>
<p>Now we're done refactoring our configuration parsing; let's turn to our
program's logic. As we laid out in the process we discussed in the &quot;Separation
of Concerns for Binary Projects&quot; section, we're going to extract a function
named <code>run</code> that will hold all of the logic currently in the <code>main</code> function
that isn't setting up configuration or handling errors. Once we're done, <code>main</code>
will be concise and easy to verify by inspection, and we'll be able to write
tests for all of the other logic.</p>
<!-- it contains ALL the function from main? Can you say why we're doing this,
hw this improves it? What is the run function doing? I'm afraid I feel a bit in
the dark here-->
<!-- This is the pattern that we explained in the Separation of Concerns for
Binary Projects section. I've added a reference back to that and reiterated
some of the reasoning from there, but this section isn't introducing the
concept of the `run` function holding the logic that was in `main` /Carol -->
<p>Listing 12-11 shows the extracted <code>run</code> function. For now, we're making only
the small, incremental improvement of extracting the function and still
defining the function in <em>src/main.rs</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // ...snip...

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    run(config);
}

fn run(config: Config) {
    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents).expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}

// ...snip...
</code></pre>
<p><span class="caption">Listing 12-11: Extracting a <code>run</code> function containing the
rest of the program logic</span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>The <code>run</code> function now contains all the remaining logic from <code>main</code> starting
from reading the file. The <code>run</code> function takes the <code>Config</code> instance as an
argument.</p>
<a class="header" href="print.html#returning-errors-from-the-run-function" id="returning-errors-from-the-run-function"><h4>Returning Errors from the <code>run</code> Function</h4></a>
<p>With the remaining program logic separated into the <code>run</code> function rather than
being in <code>main</code>, we can improve the error handling like we did with
<code>Config::new</code> in Listing 12-9. Instead of allowing the program to panic by
calling <code>expect</code>, the <code>run</code> function will return a <code>Result&lt;T, E&gt;</code> when
something goes wrong. This will let us further consolidate the logic around
handling errors in a user-friendly way into <code>main</code>. Listing 12-12 shows the
changes to the signature and body of <code>run</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;

// ...snip...

fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    println!(&quot;With text:\n{}&quot;, contents);

    Ok(())
}
</code></pre>
<p><span class="caption">Listing 12-12: Changing the <code>run</code> function to return
<code>Result</code></span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>We've made three big changes here. First, we're changing the return type of the
<code>run</code> function to <code>Result&lt;(), Box&lt;Error&gt;&gt;</code>. This function previously returned
the unit type, <code>()</code>, and we keep that as the value returned in the <code>Ok</code> case.</p>
<!-- is just the `Box` bit the trait object, or the whole `Box<Error>`
syntax?-->
<!-- The whole `Box<Error>` /Carol -->
<p>For our error type, we're using the <em>trait object</em> <code>Box&lt;Error&gt;</code> (and we've
brought <code>std::error::Error</code> into scope with a <code>use</code> statement at the top).
We'll be covering trait objects in Chapter 17. For now, just know that
<code>Box&lt;Error&gt;</code> means the function will return a type that implements the <code>Error</code>
trait, but we don't have to specify what particular type the return value will
be. This gives us flexibility to return error values that may be of different
types in different error cases.</p>
<p>The second change we're making is removing the calls to <code>expect</code> in favor of
<code>?</code>, like we talked about in Chapter 9. Rather than <code>panic!</code> on an error, this
will return the error value from the current function for the caller to handle.</p>
<p>Thirdly, this function now returns an <code>Ok</code> value in the success case. We've
declared the <code>run</code> function's success type as <code>()</code> in the signature, which
means we need to wrap the unit type value in the <code>Ok</code> value. This <code>Ok(())</code>
syntax may look a bit strange at first, but using <code>()</code> like this is the
idiomatic way to indicate that we're calling <code>run</code> for its side effects only;
it doesn't return a value we need.</p>
<p>When you run this, it will compile, but with a warning:</p>
<pre><code class="language-text">warning: unused result which must be used, #[warn(unused_must_use)] on by default
  --&gt; src/main.rs:39:5
   |
39 |     run(config);
   |     ^^^^^^^^^^^^
</code></pre>
<p>Rust is telling us that our code ignores the <code>Result</code> value, which might be
indicating that there was an error. We're not checking to see if there was an
error or not, though, and the compiler is reminding us that we probably meant
to have some error handling code here! Let's rectify that now.</p>
<a class="header" href="print.html#handling-errors-returned-from-run-in-main" id="handling-errors-returned-from-run-in-main"><h4>Handling Errors Returned from <code>run</code> in <code>main</code></h4></a>
<p>We'll check for errors and handle them nicely using a similar technique to the
way we handled errors with <code>Config::new</code> in Listing 12-10, but with a slight
difference:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // ...snip...

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>We use <code>if let</code> to check whether <code>run</code> returns an <code>Err</code> value, rather than
<code>unwrap_or_else</code>, and call <code>process::exit(1)</code> if it does. <code>run</code> doesn't return
a value that we want to <code>unwrap</code> like <code>Config::new</code> returns the <code>Config</code>
instance. Because <code>run</code> returns a <code>()</code> in the success case, we only care about
detecting an error, so we don't need <code>unwrap_or_else</code> to return the unwrapped
value as it would only be <code>()</code>.</p>
<p>The bodies of the <code>if let</code> and the <code>unwrap_or_else</code> functions are the same in
both cases though: we print out the error and exit.</p>
<a class="header" href="print.html#split-code-into-a-library-crate" id="split-code-into-a-library-crate"><h3>Split Code into a Library Crate</h3></a>
<p>This is looking pretty good so far! Now we're going to split the <em>src/main.rs</em>
file up and put some code into <em>src/lib.rs</em> so that we can test it and have a
small <code>main</code> function.</p>
<p>Let's move the following pieces of code from <em>src/main.rs</em> to a new file,
<em>src/lib.rs</em>:</p>
<ul>
<li>The <code>run</code> function definition</li>
<li>The relevant <code>use</code> statements</li>
<li>The definition of <code>Config</code></li>
<li>The <code>Config::new</code> function definition</li>
</ul>
<p>The contents of <em>src/lib.rs</em> should now look like Listing 12-13:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt;{
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    println!(&quot;With text:\n{}&quot;, contents);

    Ok(())
}
</code></pre>
<p><span class="caption">Listing 12-13: Moving <code>Config</code> and <code>run</code> into
<em>src/lib.rs</em></span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>We've made liberal use of <code>pub</code> here: on <code>Config</code>, its fields and its <code>new</code>
method, and on the <code>run</code> function. We now have a library crate that has a
public API that we can test.</p>
<a class="header" href="print.html#calling-the-library-crate-from-the-binary-crate" id="calling-the-library-crate-from-the-binary-crate"><h4>Calling the Library Crate from the Binary Crate</h4></a>
<p>Now we need to bring the code we moved to <em>src/lib.rs</em> into the scope of the
binary crate in <em>src/main.rs</em> by using <code>extern crate greprs</code>. Then we'll add a
<code>use greprs::Config</code> line to bring the <code>Config</code> type into scope, and prefix the
<code>run</code> function with our crate name as shown in Listing 12-14:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate greprs;

use std::env;
use std::process;

use greprs::Config;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    if let Err(e) = greprs::run(config) {
        println!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p><span class="caption">Listing 12-14: Bringing the <code>greprs</code> crate into the scope
of <em>src/main.rs</em></span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>With that, all the functionality should be connected and should work. Give it a
<code>cargo run</code> and make sure everything is wired up correctly.</p>
<!-- any tips for if they do find something is broken, main places to check? Or
just "diff your file against the XXX file in the book's resources to check
where it went wrong"? -->
<!-- We think general troubleshooting tips should be something we cover in
Chapter 1; the tips should apply to any example in the book /Carol -->
<p>Whew! That was a lot of work, but we've set ourselves up for success in the
future. Now it's much easier to handle errors, and we've made our code more
modular. Almost all of our work will be done in <em>src/lib.rs</em> from here on out.</p>
<p>Let's take advantage of this newfound modularity by doing something that would
have been hard with our old code, but is easy with our new code: write some
tests!</p>
<a class="header" href="print.html#testing-the-librarys-functionality" id="testing-the-librarys-functionality"><h2>Testing the Library's Functionality</h2></a>
<p>Now that we've extracted the logic into <em>src/lib.rs</em> and left all the argument
parsing and error handling in <em>src/main.rs</em>, it's much easier for us to write
tests for the core functionality of our code. We can call our functions
directly with various arguments and check return values without having to call
our binary from the command line.</p>
<p>In this section, we're going to follow the Test Driven Development (TDD)
process. This is a software development technique that follows this set of
steps:</p>
<ol>
<li>Write a test that fails, and run it to make sure it fails for the reason
you expected.</li>
<li>Write or modify just enough code to make the new test pass.</li>
<li>Refactor the code you just added or changed, and make sure the tests
continue to pass.</li>
<li>Repeat!</li>
</ol>
<p>This is just one of many ways to write software, but TDD can help drive the
design of code. Writing the test before writing the code that makes the test
pass helps to maintain high test coverage throughout the process.</p>
<p>We're going to test drive the implementation of the part of our <code>greprs</code>
program that will actually do the searching for the query string in the file
contents and produce a list of lines that match the query. We're going to add
this functionality in a function called <code>search</code>.</p>
<a class="header" href="print.html#writing-a-failing-test" id="writing-a-failing-test"><h3>Writing a Failing Test</h3></a>
<p>First, since we don't really need them any more, let's remove the <code>println!</code>
statements from both <em>src/lib.rs</em> and <em>src/main.rs</em>. Then we'll add a <code>test</code>
module with a test function, like we did in Chapter 11. The test function
specifies the behavior we'd like the <code>search</code> function to have: it will take
a query and the text to search for the query in, and will return only the lines
from the text that contain the query. Listing 12-15 shows this test:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 12-15: Creating a failing test for the <code>search</code>
function we wish we had</span></p>
<p>We've chosen to use &quot;duct&quot; as the string we're looking for in this test. The
text we're searching in is three lines, only one of which contains &quot;duct&quot;. We
assert that the value returned from the <code>search</code> function contains only the one
line we expect.</p>
<p>We aren't able to run this test and watch it fail though, since this test
doesn't even compile yet! We're going to add just enough code to get it to
compile: a definition of the <code>search</code> function that always returns an empty
vector, as shown in Listing 12-16. Once we have this, the test should compile
and fail because an empty vector doesn't match a vector containing the one
line <code>&quot;safe, fast, productive.&quot;</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
     vec![]
}
#}</code></pre></pre>
<p><span class="caption">Listing 12-16: Defining just enough of the <code>search</code>
function that our test will compile</span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>Notice that we need an explicit lifetime <code>'a</code> defined in the signature of
<code>search</code> and used with the <code>contents</code> argument and the return value. Remember
from Chapter 10 that the lifetime parameters specify which argument lifetime is
connected to the lifetime of the return value. In this case, we're indicating
that the returned vector should contain string slices that reference slices of
the argument <code>contents</code> (rather than the argument <code>query</code>).</p>
<p>In other words, we're telling Rust that the data returned by the <code>search</code>
function will live as long as the data passed into the <code>search</code> function in the
<code>contents</code> argument. This is important! The data referenced <em>by</em> a slice needs
to be valid in order for the reference to be valid; if the compiler assumed we
were making string slices of <code>query</code> rather than <code>contents</code>, it would do its
safety checking incorrectly.</p>
<p>If we tried to compile this function without lifetimes, we would get this error:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/lib.rs:5:47
  |
5 | fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
  |                                               ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the
  signature does not say whether it is borrowed from `query` or `contents`
</code></pre>
<p>Rust can't possibly know which of the two arguments we need, so we need to tell
it. Because <code>contents</code> is the argument that contains all of our text and we
want to return the parts of that text that match, we know <code>contents</code> is the
argument that should be connected to the return value using the lifetime syntax.</p>
<p>Other programming languages don't require you to connect arguments to return
values in the signature, so this may still feel strange, but will get easier
over time. You may want to compare this example with the Lifetime Syntax
section in Chapter 10.</p>
<p>Now let's try running our test:</p>
<pre><code class="language-text">$ cargo test
...warnings...
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running target/debug/deps/greprs-abcabcabc

running 1 test
test test::one_result ... FAILED

failures:

---- test::one_result stdout ----
    thread 'test::one_result' panicked at 'assertion failed: `(left == right)`
(left: `[&quot;safe, fast, productive.&quot;]`, right: `[]`)', src/lib.rs:16
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    test::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured

error: test failed
</code></pre>
<p>Great, our test fails, exactly as we expected. Let's get the test to pass!</p>
<a class="header" href="print.html#writing-code-that-gets-the-test-to-pass" id="writing-code-that-gets-the-test-to-pass"><h3>Writing Code that Gets the Test to Pass</h3></a>
<p>Currently, our test is failing because we always return an empty vector. To fix
that and implement <code>search</code>, our program needs to follow these steps:</p>
<ol>
<li>Iterate through each line of the contents.</li>
<li>Check if the line contains our query string.
<ul>
<li>If it does, add it to the list of values we're returning.</li>
<li>If it doesn't, do nothing.</li>
</ul>
</li>
<li>Return the list of results that match.</li>
</ol>
<p>Let's take each step at a time, starting with iterating through lines.</p>
<a class="header" href="print.html#iterating-through-lines-with-the-lines-method" id="iterating-through-lines-with-the-lines-method"><h4>Iterating Through Lines with the <code>lines</code> method</h4></a>
<p>Rust has a helpful method to handle line-by-line iteration of strings,
conveniently named <code>lines</code>, that works as shown in Listing 12-17:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
</code></pre>
<p><span class="caption">Listing 12-17: Iterating through each line in
<code>contents</code></span></p>
<!-- Will add wingdings in libreoffice /Carol -->
<p>The <code>lines</code> method returns an iterator. We'll be talking about iterators in
depth in Chapter 13, but we've already seen this way of using an iterator in
Listing 3-6, where we used a <code>for</code> loop with an iterator to run some code on
each item in a collection.</p>
<!-- so what does `lines` do on its own, if we need to use it in a for loop to
work? -->
<!-- It does nothing on its own, it returns an iterator for you to do something
with. Here, the thing we're doing with it is using it with a `for` loop. I'm
not sure exactly what you're asking or how to make the text clearer, but I
added a reference to where we've done this in the book previously. /Carol -->
<a class="header" href="print.html#searching-each-line-for-the-query" id="searching-each-line-for-the-query"><h4>Searching Each Line for the Query</h4></a>
<p>Next, we'll add functionality to check if the current line contains the query
string. Luckily, strings have another helpful method named <code>contains</code> that does
this for us! Add the <code>contains</code> method to the <code>search</code> function as shown in
Listing 12-18:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
</code></pre>
<p><span class="caption">Listing 12-18: Adding functionality to see if the line
contains the string in <code>query</code></span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<a class="header" href="print.html#storing-matching-lines" id="storing-matching-lines"><h4>Storing Matching Lines</h4></a>
<p>Finally, we need a way to store the lines that contain our query string. For
that, we can make a mutable vector before the <code>for</code> loop and call the <code>push</code>
method to store a <code>line</code> in the vector. After the <code>for</code> loop, we return the
vector, as shown in Listing 12-19:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<p><span class="caption">Listing 12-19: Storing the lines that match so that we
can return them</span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>Now the <code>search</code> function should be returning only the lines that contain
<code>query</code>, and our test should pass. Let's run the tests:</p>
<pre><code class="language-text">$ cargo test
running 1 test
test test::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/debug/greprs-2f55ee8cd1721808

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests greprs

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Our test passed, great, it works!</p>
<p>Now that our test is passing, we could consider opportunities for refactoring
the implementation of the <code>search</code> function while keeping the tests passing in
order to maintain the same functionality while we do so. This code isn't bad,
but it isn't taking advantage of some useful features of iterators. We'll be
coming back to this example in Chapter 13 where we'll explore iterators in
detail and see how to improve it.</p>
<!-- If we aren't going into this here, maybe just keep it focused, there's a
lot going on here as is -->
<!-- The reason we mention refactoring here is that it's a key step in the TDD
method that we were implicitly using before. Now that we've added text to the
beginning of this section to explicitly mention that we're doing TDD and what
the steps are, we want to address the "refactor" step. People who have some
experience with Rust might also look at this example and wonder why we're not
doing this in a different way, and be concerned that we're not teaching the
best way possible. This paragraph reassures them that we know what we're doing
and we're getting to the better way in Chapter 13. /Carol -->
<a class="header" href="print.html#using-the-search-function-in-the-run-function" id="using-the-search-function-in-the-run-function"><h4>Using the <code>search</code> Function in the <code>run</code> Function</h4></a>
<p>Now that we have the <code>search</code> function working and tested, we need to actually
call <code>search</code> from our <code>run</code> function. We need to pass the <code>config.query</code> value
and the <code>contents</code> that <code>run</code> read from the file to the <code>search</code> function. Then
<code>run</code> will print out each line returned from <code>search</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
</code></pre>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>We're again using a <code>for</code> loop to get each line returned from <code>search</code>, and
the code that we run for each line prints it out.</p>
<p>Now our whole program should be working! Let's try it out, first with a word
that should return exactly one line from the Emily Dickinson poem, &quot;frog&quot;:</p>
<pre><code class="language-text">$ cargo run frog poem.txt
   Compiling greprs v0.1.0 (file:///projects/greprs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38 secs
     Running `target/debug/greprs frog poem.txt`
How public, like a frog
</code></pre>
<p>Cool! Next, how about a word that will match multiple lines, like &quot;the&quot;:</p>
<pre><code class="language-text">$ cargo run the poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/greprs the poem.txt`
Then there's a pair of us — don't tell!
To tell your name the livelong day
</code></pre>
<p>And finally, let's make sure that we don't get any lines when we search for a
word that isn't anywhere in the poem, like &quot;monomorphization&quot;:</p>
<pre><code class="language-text">$ cargo run monomorphization poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/greprs monomorphization poem.txt`
</code></pre>
<p>Excellent! We've built our own version of a classic tool, and learned a lot
about how to structure applications. We've also learned a bit about file input
and output, lifetimes, testing, and command line parsing.</p>
<p>Feel free to move on to Chapter 13 if you'd like at this point. To round out
this project chapter, though, we're going to briefly demonstrate how to work
with environment variables and printing to standard error, both of which are
useful when writing command line programs.</p>
<a class="header" href="print.html#working-with-environment-variables" id="working-with-environment-variables"><h2>Working with Environment Variables</h2></a>
<p>We're going to improve our tool with an extra feature: an option for case
insensitive searching turned on via an environment variable. We could make this
a command line option and require that users enter it each time they want it to
apply, but instead we're going to use an environment variable. This allows our
users to set the environment variable once and have all their searches be case
insensitive in that terminal session.</p>
<a class="header" href="print.html#writing-a-failing-test-for-the-case-insensitive-search-function" id="writing-a-failing-test-for-the-case-insensitive-search-function"><h3>Writing a Failing Test for the Case-Insensitive <code>search</code> Function</h3></a>
<p>First, let's add a new function that we will call when the environment variable
is on.</p>
<!-- You mean, to turn the environment variable on? I'm not sure what we're
doing here-->
<!-- No, I'm not sure how this is unclear. We're adding a new function. We will
call the new function when the user turns on the environment variable. Can you
elaborate on what part of the above statement leads to the conclusion that the
new function is going to turn the environment variable on? Can you suggest a
rewording that makes the causality direction clearer? /Carol -->
<p>We're going to continue following the TDD process that we started doing in the
last section, and the first step is again to write a failing test. We'll add a
new test for the new case insensitive search function, and rename our old test
from <code>one_result</code> to <code>case_sensitive</code> to be clearer about the differences
between the two tests, as shown in Listing 12-20:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Duct tape.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}
#}</code></pre></pre>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p><span class="caption">Listing 12-20: Adding a new failing test for the case
insensitive function we're about to add</span></p>
<p>Note that we've edited the old test's <code>contents</code> too. We've added a new line
with the text &quot;Duct tape&quot;, with a capital D, that shouldn't match the query
&quot;duct&quot; when we're searching for the query in a case sensitive manner. We've
changed this test to ensure that we don't accidentally break the case sensitive
search functionality that we've already implemented; this test should pass now
and should continue to pass as we work on the case insensitive search.</p>
<p>The new test for the case insensitive search uses &quot;rUsT&quot; with some capital
letters as its query. The expected return value from the
<code>search_case_insensitive</code> function we're going to add is that the query &quot;rust&quot;
will match both the line containing &quot;Rust:&quot; with a capital R and also the line
&quot;Trust me.&quot; that contains &quot;rust&quot; with a lowercase r. This test will fail to
compile right now since we haven't yet defined the <code>search_case_insensitive</code>
function; feel free to add a skeleton implementation that always returns an
empty vector in the same way that we did for the <code>search</code> function in Listing
12-16 in order to see the test compile and fail.</p>
<a class="header" href="print.html#implementing-the-search_case_insensitive-function" id="implementing-the-search_case_insensitive-function"><h3>Implementing the <code>search_case_insensitive</code> Function</h3></a>
<p>The <code>search_case_insensitive</code> function, shown in Listing 12-21, will be almost
the same as the <code>search</code> function. The difference is that we'll lowercase the
<code>query</code> function and each <code>line</code> so that whatever the case of the input
arguments, they will be the same case when we check whether the line contains
the query.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
#}</code></pre></pre>
<p><span class="caption">Listing 12-21: Defining the <code>search_case_insensitive</code>
function to lowercase both the query and the line before comparing them</span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<!-- why do we lowercase the search string? and why does it need to be a string
rather than a slice? -->
<!-- We explained this above, that in order to make the search case
insensitive, we need to lowercase everything so that searches will always match
no matter what case either the query or each line uses. It needs to be a
`String` because we're creating new data, not referencing existing data, when
we call `to_lowercase`. I've tried to make both of these points clearer, but
I'm not sure exactly what was unclear about it before, so I'm not sure if I've
helped. /Carol -->
<p>First, we lowercase the <code>query</code> string, and store it in a shadowed variable
with the same name. Calling <code>to_lowercase</code> on the query is necessary so that no
matter if the user's query is &quot;rust&quot;, &quot;RUST&quot;, &quot;Rust&quot;, or &quot;rUsT&quot;, we'll treat
the query as if it was &quot;rust&quot; and be insensitive to the case.</p>
<p>Note that <code>query</code> is now a <code>String</code> rather than a string slice, because calling
<code>to_lowercase</code> is creating new data, not referencing existing data. If the
query is &quot;rUsT&quot;, that string slice does not contain a lowercase u or t for us
to use, so we have to allocate a new <code>String</code> containing &quot;rust&quot;. Because
<code>query</code> is now a <code>String</code>, when we pass <code>query</code> as an argument to the
<code>contains</code> method, we need to add an ampersand since the signature of
<code>contains</code> is defined to take a string slice.</p>
<p>Next, we add a call to <code>to_lowercase</code> on each <code>line</code> before we check if it
contains <code>query</code>. This will turn &quot;Rust:&quot; into &quot;rust:&quot; and &quot;Trust me.&quot; into
&quot;trust me.&quot; Now that we've converted both <code>line</code> and <code>query</code> to all lowercase,
we'll find matches no matter what case the text in the file has or the user
entered in the query.</p>
<p>Let's see if this implementation passes the tests:</p>
<pre><code class="language-text">    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/greprs-e58e9b12d35dc861

running 2 tests
test test::case_insensitive ... ok
test test::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured

     Running target/debug/greprs-8a7faa2662b5030a

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests greprs

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Great! Now, let's actually call the new <code>search_case_insensitive</code> function from
the <code>run</code> function. First, we're going to add a configuration option for
switching between case sensitive and case insensitive search to the <code>Config</code>
struct:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Config {
    pub query: String,
    pub filename: String,
    pub case_sensitive: bool,
}
#}</code></pre></pre>
<!-- Will add ghosting in libreoffice /Carol -->
<p>We add the <code>case_sensitive</code> field that holds a boolean. Then we need our <code>run</code>
function to check the <code>case_sensitive</code> field's value and use that to decide
whether to call the <code>search</code> function or the <code>search_case_insensitive</code> function
as shown in Listing 12-22:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::error::Error;
# use std::fs::File;
# use std::io::prelude::*;
#
# fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
# fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }
#
pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt;{
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    let results = if config.case_sensitive {
        search(&amp;config.query, &amp;contents)
    } else {
        search_case_insensitive(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
#}</code></pre></pre>
<p><span class="caption">Listing 12-22: Calling either <code>search</code> or
<code>search_case_insensitive</code> based on the value in <code>config.case_sensitive</code></span></p>
<!-- Will add ghosting in libreoffice /Carol -->
<p>Finally, we need to actually check for the environment variable. The functions
for working with environment variables are in the <code>env</code> module in the standard
library, so we want to bring that module into scope with a <code>use std::env;</code>
line at the top of <em>src/lib.rs</em>. Then we're going to use the <code>var</code> method
from the <code>env</code> module in <code>Config::new</code> to check for an environment variable
named <code>CASE_INSENSITIVE</code>, as shown in Listing 12-23:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::env;
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }

// ...snip...

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config {
            query: query,
            filename: filename,
            case_sensitive: case_sensitive,
        })
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 12-23: Checking for an environment variable named
<code>CASE_INSENSITIVE</code></span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>Here, we create a new variable <code>case_sensitive</code>. In order to set its value, we
call the <code>env::var</code> function and pass it the name of the environment variable
we're looking for, <code>CASE_INSENSITIVE</code>. <code>env::var</code> returns a <code>Result</code> that will
be the <code>Ok</code> variant containing the value if the environment variable is set,
and will be the <code>Err</code> variant if the environment variable is not set. We're
using the <code>is_err</code> method on the <code>Result</code> to check to see if it's an error (and
therefore unset), which means we <em>should</em> do a case sensitive search. If the
<code>CASE_INSENSITIVE</code> environment variable is set to anything, <code>is_err</code> will
return false and we will do a case insensitive search. We don't care about the
value that the environment variable is set to, just whether it's set or unset,
so we're checking <code>is_err</code> rather than <code>unwrap</code>, <code>expect</code>, or any of the other
methods we've seen on <code>Result</code>. We pass the value in the <code>case_sensitive</code>
variable to the <code>Config</code> instance so that the <code>run</code> function can read that
value and decide whether to call <code>search</code> or <code>search_case_insensitive</code> as we
implemented in Listing 12-22.</p>
<p>Let's give it a try! First, we'll run our program without the environment
variable set and with the query &quot;to&quot;, which should match any line that contains
the word &quot;to&quot; in all lowercase:</p>
<pre><code class="language-text">$ cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/greprs to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Looks like that still works! Now, let's run the program with <code>CASE_INSENSITIVE</code>
set to 1 but with the same query &quot;to&quot;, and we should get lines that contain
&quot;to&quot; that might have capital letters:</p>
<pre><code class="language-text">$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/greprs to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Excellent, we also got lines containing &quot;To&quot;! Our <code>greprs</code> program can now do
case insensitive searching, controlled by an environment variable. Now you know
how to manage options set using either command line arguments or environment
variables!</p>
<p>Some programs allow both arguments <em>and</em> environment variables for the same
configuration. In those cases, the programs decide that one or the other takes
precedence. For another exercise on your own, try controlling case
insensitivity through a command line argument as well as through the
environment variable, and decide which should take precedence if the program is
run with contradictory values.</p>
<p>The <code>std::env</code> module contains many more useful features for dealing with
environment variables; check out its documentation to see what's available.</p>
<a class="header" href="print.html#write-to-stderr-instead-of-stdout" id="write-to-stderr-instead-of-stdout"><h2>Write to <code>stderr</code> Instead of <code>stdout</code></h2></a>
<p>Right now, we're writing all of our output to the terminal with <code>println!</code>.
Most terminals provide two kinds of output: &quot;standard out&quot; for general
information, and &quot;standard error&quot; for error messages. This distinction is the
behavior that's expected of command line programs: it enables users to choose
to direct a program's successful output to a file but still print error
messages to the screen, for example. <code>println!</code> is only capable of printing to
standard out, though, so we have to use something else in order to print to
standard error.</p>
<p>We can verify that, the way we've written <code>greprs</code> so far, everything is being
written to standard out, including error messages that should be written to
standard error instead. We'll do that by intentionally causing an error, the
one that happens when we run the program without any arguments. We're going to
redirect standard output to a file, but not standard error. The way command
line programs are expected to work is that, because the output is an error
message, it should be shown on the screen rather than being redirected to the
file. Let's see that our program is not currently meeting this expectation by
using <code>&gt;</code> and specifying a filename, <em>output.txt</em>, that we want to redirect
standard out to:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
</code></pre>
<!-- why do we get an error here? Was that intentional? Does that mean it can't
print stdout to a file? -->
<!-- Yes, we're intentionally causing an error here to show that errors are
currently going to the wrong place. It's showing that `println!` only prints
to standard out, even when we're printing error messages that should go
to standard error. /Carol-->
<p>The <code>&gt;</code> syntax tells the shell to write the contents of standard out to
<em>output.txt</em> instead of the screen. We didn't see the error message we were
expecting printed on the screen, so that means it must have ended up in the
file. Let's see what <em>output.txt</em> contains:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<!-- I don't understand why we send this output to a file to then just say we
want it to the screen, won't it do that by default? And what has this got to do
with our use of println? I'm finding the motives here hard to follow -->
<!-- The point of showing this is to demonstrate that our program is NOT doing
the correct thing by default, we need to change the places we're calling
`println!` with error messages to print to standard error instead. When to use
stdout vs. stderr, and why you might want to redirect stdout but not stderr,
is something our readers will be familiar with. /Carol -->
<p>Yup, there's our error message, which means it's being printed to standard out.
This isn't what's expected from command line programs. It's much more useful
for error messages like this to be printed to standard error, and only have
data printed to standard out from a successful run end up in the file when we
redirect standard out in this way. Let's change how error messages are printed
as shown in Listing 12-23. Because of the refactoring we did earlier in this
chapter, all of the code that prints error messages is in one place, in <code>main</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate greprs;

use std::env;
use std::process;
use std::io::prelude::*;

use greprs::Config;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    let mut stderr = std::io::stderr();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        writeln!(
            &amp;mut stderr,
            &quot;Problem parsing arguments: {}&quot;,
            err
        ).expect(&quot;Could not write to stderr&quot;);
        process::exit(1);
    });

    if let Err(e) = greprs::run(config) {
        writeln!(
            &amp;mut stderr,
            &quot;Application error: {}&quot;,
            e
        ).expect(&quot;Could not write to stderr&quot;);

        process::exit(1);
    }
}
</code></pre>
<p><span class="caption">Listing 12-23: Writing error messages to <code>stderr</code> instead
of <code>stdout</code> using <code>writeln!</code></span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>Rust does not have a convenient function like <code>println!</code> for writing to
standard error. Instead, we use the <code>writeln!</code> macro, which is like <code>println!</code>
but takes an extra argument. The first thing we pass to it is what to write to.
We can acquire a handle to standard error through the <code>std::io::stderr</code>
function. We give a mutable reference to <code>stderr</code> to <code>writeln!</code>; we need it to
be mutable so we can write to it! The second and third arguments to <code>writeln!</code>
are like the first and second arguments to <code>println!</code>: a format string and any
variables we're interpolating.</p>
<p>Let's try running the program again in the same way, without any arguments and
redirecting <code>stdout</code> with <code>&gt;</code>:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Now we see our error on the screen, and <code>output.txt</code> contains nothing, which is
the behavior that's expected of command line programs.</p>
<p>If we run the program again with arguments that don't cause an error, but still
redirecting standard out to a file:</p>
<pre><code class="language-text">$ cargo run to poem.txt &gt; output.txt
</code></pre>
<p>We won't see any output to our terminal, and <code>output.txt</code> will contain our
results:</p>
<p><span class="filename">Filename: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>This demonstrates that we're now using standard out for successful output and
standard error for error output as appropriate.</p>
<a class="header" href="print.html#summary-4" id="summary-4"><h2>Summary</h2></a>
<p>In this chapter, we've recapped on some of the major concepts so far and
covered how to do common I/O operations in a Rust context. By using command
line arguments, files, environment variables, and the <code>writeln!</code> macro with
<code>stderr</code>, you're now prepared to write command line applications. By using the
concepts from previous chapters, your code will be well-organized, be able to
store data effectively in the appropriate data structures, handle errors
nicely, and be well tested.</p>
<p>Next, let's explore some functional-language influenced Rust features: closures
and iterators.</p>
<a class="header" href="print.html#functional-language-features-in-rust-iterators-and-closures" id="functional-language-features-in-rust-iterators-and-closures"><h1>Functional Language features in Rust: Iterators and Closures</h1></a>
<!-- Are closures unique to Rust? -->
<!-- No, they're from functional languages, which is why they're discussed in
this chapter. Do you have a suggestion on how to make that clearer than the
text in the intro paragraph here? /Carol -->
<p>Rust's design has taken inspiration from a lot of existing languages and
techniques, and one significant influence is <em>functional programming</em>.
Programming in a functional style often includes using functions as values in
arguments or return values of other functions, assigning functions to variables
for later execution, and so forth. We won't debate here the issue of what,
exactly, functional programming is or is not, but will instead show off some
features of Rust that are similar to features in many languages often referred
to as functional.</p>
<p>More specifically, we're going to cover:</p>
<ul>
<li><em>Closures</em>: a function-like construct you can store in a variable.</li>
<li><em>Iterators</em>: a way of processing a series of elements.</li>
<li>How to use these features to improve on the I/O project from Chapter 12.</li>
<li>The performance of these features. Spoiler alert: they're faster than you
might think!</li>
</ul>
<p>There are other Rust features influenced by the functional style, like pattern
matching and enums, that we've covered in other chapters as well. Mastering
closures and iterators is an important part of writing idiomatic, fast Rust
code, so we're devoting an entire chapter to them here.</p>
<a class="header" href="print.html#closures-anonymous-functions-that-can-capture-their-environment" id="closures-anonymous-functions-that-can-capture-their-environment"><h2>Closures: Anonymous Functions that can Capture their Environment</h2></a>
<!-- Bill's suggested we flesh out some of these subtitles, which I think we
did more with earlier chapters but we (I, included!) have got a bit lax with. I
don't think this is quite right, is there a shorter heading we could use to
capture what a closure is/is for? -->
<!-- I've attempted a more descriptive subtitle, what do you think? /Carol -->
<p>Rust's <em>closures</em> are anonymous functions that you can save in a variable or
pass as arguments to other functions. You can create the closure in one place,
and then call the closure to evaluate it in a different context. Unlike
functions, closures are allowed to capture values from the scope in which they
are called. We're going to demonstrate how these features of closures allow for
code reuse and customization of behavior.</p>
<!-- Can you say what sets closures apart from functions, explicitly, above? I
can't see it clearly enough to be confident, after one read through this
chapter. I think it would help to have the closure definition up front, to help
to let the reader know what they are looking out for in the examples. When
would you use a closure, for example, rather than using a function? And is it
the closure that's stored in the variable, or is it the result of applying the
closure to a value passed as an argument? -->
<!-- I've tried reworking the above paragraph and restructuring the examples to
be more motivating. I've also tried to make it clear throughout that storing a
closure is storing the *unevaluated* code, and then you call the closure in
order to get the result. /Carol -->
<a class="header" href="print.html#creating-an-abstraction-of-behavior-using-a-closure" id="creating-an-abstraction-of-behavior-using-a-closure"><h3>Creating an Abstraction of Behavior Using a Closure</h3></a>
<p>Let's work on an example that will show a situation where storing a closure to
be executed at a later time is useful. We'll talk about the syntax of closures,
type inference, and traits along the way.</p>
<p>The hypothetical situation is this: we're working at a startup that's making an
app to generate custom exercise workout plans. The backend is written in Rust,
and the algorithm that generates the workout plan takes into account many
different factors like the app user's age, their Body Mass Index, their
preferences, their recent workouts, and an intensity number they specify. The
actual algorithm used isn't important in this example; what's important is that
this calculation takes a few seconds. We only want to call this algorithm if we
need to, and we only want to call it once, so that we aren't making the user
wait more than they need to. We're going to simulate calling this hypothetical
algorithm by calling the <code>simulated_expensive_calculation</code> function shown in
Listing 13-1 instead, which will print <code>calculating slowly...</code>, wait for two
seconds, and then return whatever number we passed in:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: i32) -&gt; i32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    intensity
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-1: A function we'll use to stand in for a
hypothetical calculation that takes about two seconds to run</span></p>
<p>Next, we have a <code>main</code> function that contains the parts of the workout app that
are important for this example. This represents the code that the app would
call when a user asks for a workout plan. Because the interaction with the
app's frontend isn't relevant to the use of closures, we're going to hardcode
values representing inputs to our program and print the outputs.</p>
<p>The inputs to the program are:</p>
<ul>
<li>An <code>intensity</code> number from the user, specified when they request a workout,
so they can indicate whether they'd like a low intensity workout or a high
intensity workout</li>
<li>A random number that will generate some variety in the workout plans</li>
</ul>
<p>The output the program prints will be the recommended workout plan.</p>
<p>Listing 13-2 shows the <code>main</code> function we're going to use. We've hardcoded the
variable <code>simulated_user_specified_value</code> to 10 and the variable
<code>simulated_random_number</code> to 7 for simplicity's sake; in an actual program we'd
get the intensity number from the app frontend and we'd use the <code>rand</code> crate to
generate a random number like we did in the Guessing Game example in Chapter 2.
The <code>main</code> function calls a <code>generate_workout</code> function with the simulated
input values:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(simulated_user_specified_value, simulated_random_number);
}
# fn generate_workout(intensity: i32, random_number: i32) {}
</code></pre></pre>
<p><span class="caption">Listing 13-2: A <code>main</code> function containing hardcoded
values to simulate user input and random number generation inputs to the
<code>generate_workout</code> function</span></p>
<p>That's the context of what we're working on. The <code>generate_workout</code> function in
Listing 13-3 contains the business logic of the app that we're most concerned
with in this example. The rest of the code changes in this example will be made
to this function:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# fn simulated_expensive_calculation(num: i32) -&gt; i32 {
#     println!(&quot;calculating slowly...&quot;);
#     thread::sleep(Duration::from_secs(2));
#     num
# }
#
fn generate_workout(intensity: i32, random_number: i32) {
    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            simulated_expensive_calculation(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                simulated_expensive_calculation(intensity)
            )
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-3: The business logic of the program that
prints the workout plans based on the inputs and calls to the
<code>simulated_expensive_calculation</code> function</span></p>
<p>The code in Listing 13-3 has multiple calls to the slow calculation function.
The first <code>if</code> block calls <code>simulated_expensive_calculation</code> twice, the <code>if</code>
inside the outer <code>else</code> doesn't call it at all, and the code inside the <code>else</code>
case inside the outer <code>else</code> calls it once.</p>
<!-- Will add wingdings in libreoffice /Carol -->
<p>The desired behavior of the <code>generate_workout</code> function is to first check if
the user wants a low intensity workout (indicated by a number less than 25) or
a high intensity workout (25 or more). Low intensity workout plans will
recommend a number of pushups and situps based on the complex algorithm we're
simulating with the <code>simulated_expensive_calculation</code> function, which needs the
intensity number as an input.</p>
<p>If the user wants a high intensity workout, there's some additional logic: if
the value of the random number generated by the app happens to be 3, the app
will recommend a break and hydration instead. If not, the user will get a high
intensity workout of a number of minutes of running that comes from the complex
algorithm.</p>
<p>The data science team has let us know that there are going to be some changes
to the way we have to call the algorithm, so we want to refactor this code to
have only one place that calls the <code>simulated_expensive_calculation</code> function
to update when those changes happen. We also want to get rid of the spot where
we're currently calling the function twice unnecessarily, and we don't want to
add any other calls to that function in the process. That is, we don't want to
call it if we're in the case where the result isn't needed at all, and we still
want to call it only once in the last case.</p>
<p>There are many ways we could restructure this program. The way we're going to
try first is extracting the duplicated call to the expensive calculation
function into a variable, as shown in Listing 13-4:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# fn simulated_expensive_calculation(num: i32) -&gt; i32 {
#     println!(&quot;calculating slowly...&quot;);
#     thread::sleep(Duration::from_secs(2));
#     num
# }
#
fn generate_workout(intensity: i32, random_number: i32) {
    let expensive_result =
        simulated_expensive_calculation(intensity);

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result
            )
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-4: Extracting the calls to
<code>simulated_expensive_calculation</code> to one place before the <code>if</code> blocks and
storing the result in the <code>expensive_result</code> variable</span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>This change unifies all the calls to <code>simulated_expensive_calculation</code> and
solves the problem of the first <code>if</code> block calling the function twice
unnecessarily. Unfortunately, we're now calling this function and waiting for
the result in all cases, which includes the inner <code>if</code> block that doesn't use
the result value at all.</p>
<p>We want to be able to specify some code in one place in our program, but then
only execute that code if we actually need the result in some other place in
our program. This is a use case for closures!</p>
<a class="header" href="print.html#closures-store-code-to-be-executed-later" id="closures-store-code-to-be-executed-later"><h3>Closures Store Code to be Executed Later</h3></a>
<p>Instead of always calling the <code>simulated_expensive_calculation</code> function before
the <code>if</code> blocks, we can define a closure and store the closure in a variable
instead of the result as shown in Listing 13-5. We can actually choose to move
the whole body of <code>simulated_expensive_calculation</code> within the closure we're
introducing here:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
let expensive_closure = |num| {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
# expensive_closure(5);
#}</code></pre></pre>
<p><span class="caption">Listing 13-5: Defining a closure with the body that was
in the expensive function and store the closure in the <code>expensive_closure</code>
variable</span></p>
<!-- Can you elaborate on *how* to define the closure first? I've had a go here
based on what I can see but not sure it's correct. Are we saying that a closure
is function that assigned its result to a variable you can then use? -->
<!-- I've attempted to elaborate on defining a closure in the next few
paragraphs starting here, is this better? /Carol -->
<p>The closure definition is the part after the <code>=</code> that we're assigning to the
variable <code>expensive_closure</code>. To define a closure, we start with a pair of
vertical pipes (<code>|</code>). Inside the pipes is where we specify the parameters to
the closure; this syntax was chosen because of its similarity to closure
definitions in Smalltalk and Ruby. This closure has one parameter named <code>num</code>;
if we had more than one parameter, we would separate them with commas, like
<code>|param1, param2|</code>.</p>
<p>After the parameters, we put curly braces that hold the body of the closure.
The curly braces are optional if the closure body only has one line. After the
curly braces, we need a semicolon to go with the <code>let</code> statement. The value
returned from the last line in the closure body (<code>num</code>), since that line
doesn't end in a semicolon, will be the value returned from the closure when
it's called, just like in function bodies.</p>
<p>Note that this <code>let</code> statement means <code>expensive_closure</code> contains the
<em>definition</em> of an anonymous function, not the <em>resulting value</em> of calling the
anonymous function. Recall the reason we're using a closure is because we want
to define the code to call at one point, store that code, and actually call it
at a later point; the code we want to call is now stored in <code>expensive_closure</code>.</p>
<p>Now that we have the closure defined, we can change the code in the <code>if</code> blocks
to call the closure in order to execute the code and get the resulting value.
Calling a closure looks very similar to calling a function; we specify the
variable name that holds the closure definition and follow it with parentheses
containing the argument values we want to use for that call as shown in Listing
13-6:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
fn generate_workout(intensity: i32, random_number: i32) {
    let expensive_closure = |num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_closure(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_closure(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_closure(intensity)
            )
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-6: Calling the <code>expensive_closure</code> we've
defined</span></p>
<p>Now we've achieved the goal of unifying where the expensive calculation is
called to one place, and we're only executing that code where we need the
results. However, we've reintroduced one of the problems from Listing 13-3:
we're still calling the closure twice in the first <code>if</code> block, which will call
the expensive code twice and make the user wait twice as long as they need to.
We could fix this problem by creating a variable local to that <code>if</code> block to
hold the result of calling the closure, but there's another solution we can use
since we have a closure. We'll get back to that solution in a bit; let's first
talk about why there aren't type annotations in the closure definition and the
traits involved with closures.</p>
<a class="header" href="print.html#closure-type-inference-and-annotation" id="closure-type-inference-and-annotation"><h3>Closure Type Inference and Annotation</h3></a>
<p>Closure are different than functions defined with the <code>fn</code> keyword in a few
ways. The first is that closures don't require you to annotate the types of the
parameters or the return value like <code>fn</code> functions do.</p>
<!-- I've suggested moving this next paragraph up from below, I found this
section difficult to follow with this next paragraph -->
<p>Type annotations are required on functions because they're are part of an
explicit interface exposed to your users. Defining this interface rigidly is
important for ensuring that everyone agrees on what types of values a function
uses and returns. Closures aren't used in an exposed interface like this,
though: they're stored in variables and used without naming them and exposing
them to be invoked by users of our library.</p>
<p>Additionally, closures are usually short and only relevant within a narrow
context rather than in any arbitrary scenario. Within these limited contexts,
the compiler is reliably able to infer the types of the parameters and return
type similarly to how it's able to infer the types of most variables. Being
forced to annotate the types in these small, anonymous functions would be
annoying and largely redundant with the information the compiler already has
available.</p>
<!--Can you expand above on what you mean by "stored in bindings and called
directly"? Do you mean stored in a variable? I'm struggling to visualize how
closures are used, and what the important difference is between them and
functions. I think a clearer definition of what they are, what they do, and
what they're used for at the start of the closures section would help clear
this up -->
<!-- Yes, sorry, in Rust terminology "binding" is mostly synonymous to
"variable", but when we started working on the book we decided to be consistent
and more like what people are used to by referring to the concept as "variable"
throughout, but we missed this spot. /Carol -->
<p>Like variables, we can choose to add type annotations if we want to increase
explicitness and clarity in exchange for being more verbose than is strictly
necessary; annotating the types for the closure we defined in Listing 13-4
would look like the definition shown here in Listing 13-7:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
let expensive_closure = |num: i32| -&gt; i32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
#}</code></pre></pre>
<p><span class="caption">Listing 13-7: Adding optional type annotations of the
parameter and return value types in the closure</span></p>
<!-- Why might you want to, if you don't need to? In a particular situation? -->
<!-- I've added an explanation /Carol -->
<!-- Below -- Am I right in assuming the closures below are doing the same
thing as the functions? -->
<!-- Yes /Carol -->
<p>The syntax of closures and functions looks more similar with type annotations.
Here's a vertical comparison of the syntax for the definition of a function
that adds one to its parameter, and a closure that has the same behavior. We've
added some spaces here to line up the relevant parts). This illustrates how
closure syntax is similar to function syntax except for the use of pipes rather
than parentheses and the amount of syntax that is optional:</p>
<!-- Prod: can you align this as shown in the text? -->
<!-- I'm confused, does this note mean that production *won't* be aligning all
of our other code examples as shown in the text? That's concerning to me, we're
trying to illustrate idiomatic Rust style in all the code examples, so our
alignment is always intentional... /Carol -->
<pre><code class="language-rust ignore">fn  add_one_v1   (x: i32) -&gt; i32 { x + 1 }
let add_one_v2 = |x: i32| -&gt; i32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<!-- Can you point out where we're looking at here, where the important
differences lie? -->
<!-- The importance isn't the difference but the similarity... I've tried to
clarify /Carol -->
<!-- Will add wingdings and ghosting in libreoffice /Carol -->
<p>The first line shows a function definition, and the second line shows a fully
annotated closure definition. The third line removes the type annotations from
the closure definition, and the fourth line removes the braces that are
optional since the closure body only has one line. These are all valid
definitions that will produce the same behavior when they're called.</p>
<!--Below--I'm not sure I'm following, is the i8 type being inferred? It seems
like we're annotating it. -->
<!-- The types in the function definitions are being inferred, but since Rust's
variable types for numbers defaults to `i32`, in order to illustrate our point
here we're forcing the type of the *variable* to be `i8` by annotating it in
the *variable* declaration. I've changed the example to hopefully be less
confusing and convey our point better. /Carol -->
<p>Closure definitions will have one concrete type inferred for each of their
parameters and for their return value. For instance, Listing 13-8 shows the
definition of a short closure that just returns the value it gets as a
parameter. This closure isn't very useful except for the purposes of this
example. Note that we haven't added any type annotations to the definition: if
we then try to call the closure twice, using a <code>String</code> as an argument the
first time and an <code>i32</code> the second time, we'll get an error:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">let example_closure = |x| x;

let s = example_closure(String::from(&quot;hello&quot;));
let n = example_closure(5);
</code></pre>
<p><span class="caption">Listing 13-8: Attempting to call a closure whose types
are inferred with two different types</span></p>
<p>The compiler gives us this error:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs
  |
  | let n = example_closure(5);
  |                         ^ expected struct `std::string::String`, found
  integral variable
  |
  = note: expected type `std::string::String`
             found type `{integer}`
</code></pre>
<!-- Will add wingdings in libreoffice /Carol -->
<p>The first time we call <code>example_closure</code> with the <code>String</code> value, the compiler
infers the type of <code>x</code> and the return type of the closure to be <code>String</code>. Those
types are then locked in to the closure in <code>example_closure</code>, and we get a type
error if we try to use a different type with the same closure.</p>
<a class="header" href="print.html#using-closures-with-generic-parameters-and-the-fn-traits" id="using-closures-with-generic-parameters-and-the-fn-traits"><h3>Using Closures with Generic Parameters and the <code>Fn</code> Traits</h3></a>
<p>Returning to our workout generation app, in Listing 13-6 we left our code still
calling the expensive calculation closure more times than it needs to. In each
place throughout our code, if we need the results of the expensive closure more
than once, we could save the result in a variable for reuse and use the
variable instead of calling the closure again. This could be a lot of repeated
code saving the results in a variety of places.</p>
<p>However, because we have a closure for the expensive calculation, we have
another solution available to us. We can create a struct that will hold the
closure and the resulting value of calling the closure. The struct will only
execute the closure if we need the resulting value, and it will cache the
resulting value so that the rest of our code doesn't have to be responsible for
saving and reusing the result. You may know this pattern as <em>memoization</em> or
<em>lazy evaluation</em>.</p>
<p>In order to make a struct that holds a closure, we need to be able to specify
the type of the closure. Each closure instance has its own unique anonymous
type: that is, even if two closures have the same signature, their types are
still considered to be different. In order to define structs, enums, or
function parameters that use closures, we use generics and trait bounds like we
discussed in Chapter 10.</p>
<!-- So Fn is a trait built into the language, is that right? I wasn't sure if
it was just a placeholder here -->
<!-- Fn is provided by the standard library; I've clarified here. /Carol -->
<p>The <code>Fn</code> traits are provided by the standard library. All closures implement
one of the traits <code>Fn</code>, <code>FnMut</code>, or <code>FnOnce</code>. We'll discuss the difference
between these traits in the next section on capturing the environment; in this
example, we can use the <code>Fn</code> trait.</p>
<p>We add types to the <code>Fn</code> trait bound to represent the types of the parameters
and return values that the closures must have in order to match this trait
bound. In this case, our closure has a parameter of type <code>i32</code> and returns an
<code>i32</code>, so the trait bound we specify is <code>Fn(i32) -&gt; i32</code>.</p>
<p>Listing 13-9 shows the definition of the <code>Cacher</code> struct that holds a closure
and an optional result value:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Cacher&lt;T&gt;
    where T: Fn(i32) -&gt; i32
{
    calculation: T,
    value: Option&lt;i32&gt;,
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-9: Defining a <code>Cacher</code> struct that holds a
closure in <code>calculation</code> and an optional result in <code>value</code></span></p>
<p>The <code>Cacher</code> struct has a <code>calculation</code> field of the generic type <code>T</code>. The
trait bounds on <code>T</code> specify that <code>T</code> is a closure by using the <code>Fn</code> trait. Any
closure we want to store in the <code>calculation</code> field of a <code>Cacher</code> instance must
have one <code>i32</code> parameter (specified within the parentheses after <code>Fn</code>) and must
return an <code>i32</code> (specified after the <code>-&gt;</code>).</p>
<p>The <code>value</code> field is of type <code>Option&lt;i32&gt;</code>. Before we execute the closure,
<code>value</code> will be <code>None</code>. If the code using a <code>Cacher</code> asks for the result of the
closure, we'll execute the closure at that time and store the result within a
<code>Some</code> variant in the <code>value</code> field. Then if the code asks for the result of
the closure again, instead of executing the closure again, we'll return the
result that we're holding in the <code>Some</code> variant.</p>
<p>The logic around the <code>value</code> field that we've just described is defined in
Listing 13-10:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Cacher&lt;T&gt;
#     where T: Fn(i32) -&gt; i32
# {
#     calculation: T,
#     value: Option&lt;i32&gt;,
# }
#
impl&lt;T&gt; Cacher&lt;T&gt;
    where T: Fn(i32) -&gt; i32
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: i32) -&gt; i32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}
#}</code></pre></pre>
<!-- Liz: the `new` function is using the "struct init shorthand" by just
saying `calculation` instead of `calculation: calculation`, since the parameter
matches the struct field name. This was recently added to stable Rust and we've
added an introduction of it in Chapter 5. Just adding an explanation here for
you in case you read this chapter before the changes we've made to Chapter 5!
/Carol -->
<p><span class="caption">Listing 13-10: Implementations on <code>Cacher</code> of an
associated function named <code>new</code> and a method named <code>value</code> that manage the
caching logic</span></p>
<p>The fields on the <code>Cacher</code> struct are private since we want <code>Cacher</code> to manage
their values rather than letting the calling code potentially change the values
in these fields directly. The <code>Cacher::new</code> function takes a generic parameter
<code>T</code>, which we've defined in the context of the <code>impl</code> block to have the same
trait bound as the <code>Cacher</code> struct. <code>Cacher::new</code> returns a <code>Cacher</code> instance
that holds the closure specified in the <code>calculation</code> field and a <code>None</code> value
in the <code>value</code> field, since we haven't executed the closure yet.</p>
<p>When the calling code wants the result of evaluating the closure, instead of
calling the closure directly, it will call the <code>value</code> method. This method
checks to see if we already have a resulting value in <code>self.value</code> in a <code>Some</code>;
if we do, it returns the value within the <code>Some</code> without executing the closure
again.</p>
<p>If <code>self.value</code> is <code>None</code>, we call the closure stored in <code>self.calculation</code>,
save the result in <code>self.value</code> for future use, and return the value as well.</p>
<p>Listing 13-11 shows how we can use this <code>Cacher</code> struct in the
<code>generate_workout</code> function from Listing 13-6:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# struct Cacher&lt;T&gt;
#     where T: Fn(i32) -&gt; i32
# {
#     calculation: T,
#     value: Option&lt;i32&gt;,
# }
#
# impl&lt;T&gt; Cacher&lt;T&gt;
#     where T: Fn(i32) -&gt; i32
# {
#     fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
#         Cacher {
#             calculation,
#             value: None,
#         }
#     }
#
#     fn value(&amp;mut self, arg: i32) -&gt; i32 {
#         match self.value {
#             Some(v) =&gt; v,
#             None =&gt; {
#                 let v = (self.calculation)(arg);
#                 self.value = Some(v);
#                 v
#             },
#         }
#     }
# }
#
fn generate_workout(intensity: i32, random_number: i32) {
    let mut expensive_result = Cacher::new(|num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result.value(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result.value(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result.value(intensity)
            )
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-11: Using <code>Cacher</code> in the <code>generate_workout</code>
function to abstract away the caching logic</span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>Instead of saving the closure in a variable directly, we save a new instance of
<code>Cacher</code> that holds the closure. Then, in each place we want the result, we
call the <code>value</code> method on the <code>Cacher</code> instance. We can call the <code>value</code>
method as many times as we want, or not call it at all, and the expensive
calculation will be run a maximum of once. Try running this program with the
<code>main</code> function from Listing 13-2, and change the values in the
<code>simulated_user_specified_value</code> and <code>simulated_random_number</code> variables to
verify that in all of the cases in the various <code>if</code> and <code>else</code> blocks,
<code>calculating slowly...</code> printed by the closure only shows up once and only when
needed.</p>
<p>The <code>Cacher</code> takes care of the logic necessary to ensure we aren't calling the
expensive calculation more than we need to be so that <code>generate_workout</code> can
focus on the business logic. Caching values is a more generally useful behavior
that we might want to use in other parts of our code with other closures as
well. However, there are a few problems with the current implementation of
<code>Cacher</code> that would make reusing it in different contexts difficult.</p>
<p>The first problem is a <code>Cacher</code> instance assumes it will always get the same
value for the parameter <code>arg</code> to the <code>value</code> method. That is, this test of
<code>Cacher</code> will fail:</p>
<pre><code class="language-rust ignore">#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 2);
}
</code></pre>
<p>This test creates a new <code>Cacher</code> instance with a closure that returns the value
passed into it. We call the <code>value</code> method on this <code>Cacher</code> instance with
an <code>arg</code> value of 1 and then an <code>arg</code> value of 2, and we expect that the call
to <code>value</code> with the <code>arg</code> value of 2 returns 2.</p>
<p>Run this with the <code>Cacher</code> implementation from Listing 13-9 and Listing 13-10
and the test will fail on the <code>assert_eq!</code> with this message:</p>
<pre><code class="language-text">thread 'call_with_different_arg_values' panicked at 'assertion failed:
`(left == right)` (left: `1`, right: `2`)', src/main.rs
</code></pre>
<p>The problem is that the first time we called <code>c.value</code> with 1, the <code>Cacher</code>
instance saved <code>Some(1)</code> in <code>self.value</code>. After that, no matter what we pass
in to the <code>value</code> method, it will always return 1.</p>
<p>Try modifying <code>Cacher</code> to hold a hash map rather than a single value. The keys
of the hash map will be the <code>arg</code> values that are passed in, and the values of
the hash map will be the result of calling the closure on that key. Instead of
looking at whether <code>self.value</code> directly has a <code>Some</code> or a <code>None</code> value, the
<code>value</code> function will look up the <code>arg</code> in the hash map and return the value if
it's present. If it's not present, the <code>Cacher</code> will call the closure and save
the resulting value in the hash map associated with its <code>arg</code> value.</p>
<p>Another problem with the current <code>Cacher</code> implementation that restricts its use
is that it only accepts closures that take one parameter of type <code>i32</code> and
return an <code>i32</code>. We might want to be able to cache the results of closures that
take a string slice as an argument and return <code>usize</code> values, for example. Try
introducing more generic parameters to increase the flexibility of the <code>Cacher</code>
functionality.</p>
<a class="header" href="print.html#closures-can-capture-their-environment" id="closures-can-capture-their-environment"><h3>Closures Can Capture Their Environment</h3></a>
<p>In the workout generator example, we only used closures as inline anonymous
functions. Closures have an additional ability we can use that functions don't
have, however: they can capture their environment and access variables from the
scope in which they're defined.</p>
<!-- To clarify, by enclosing scope, do you mean the scope that the closure is
inside? Can you expand on that?-->
<!-- Yes, I've tried here to clarify that it's the scope in which the closure
is defined /Carol -->
<p>Listing 13-12 has an example of a closure stored in the variable <code>equal_to_x</code>
that uses the variable <code>x</code> from the closure's surrounding environment:</p>
<!-- To clarify how we talk about a closure, does the closure include the
variable name, or are we referring to the closure as the functionality that is
on the right side of the = and so not including to variable name? I thought it
was the former, but it seems like the latter above. If it's the former, would
"an example of a closure with the variable `equal_to_x`" make more sense? -->
<!-- No, the closure does not include the variable name in which it's stored;
storing a closure in a variable is optional. It should always be the latter,
and I hope the reworking of the example used throughout the closure section
and making the wording consistent has cleared this confusion up by this point.
/Carol -->
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p><span class="caption">Listing 13-12: Example of a closure that refers to a
variable in its enclosing scope</span></p>
<p>Here, even though <code>x</code> is not one of the parameters of <code>equal_to_x</code>, the
<code>equal_to_x</code> closure is allowed to use the <code>x</code> variable that's defined in the
same scope that <code>equal_to_x</code> is defined in.</p>
<!-- So *why* is this allowed with closures and not functions, what about
closures makes this safe? -->
<!-- It's not really about safety; capturing the environment is the defining
functionality a closure has. The reason functions *don't* capture their
environment is mostly around storage overhead; I've added an explanation of
that aspect. Can you elaborate on what led to the conclusion that allowing
captures with functions wouldn't be safe and what you mean by "safe" here?
/Carol -->
<p>We can't do the same with functions; let's see what happens if we try:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -&gt; bool { z == x }

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre>
<p>We get an error:</p>
<pre><code class="language-text">error[E0434]: can't capture dynamic environment in a fn item; use the || { ... }
closure form instead
 --&gt;
  |
4 |     fn equal_to_x(z: i32) -&gt; bool { z == x }
  |                                          ^
</code></pre>
<p>The compiler even reminds us that this only works with closures!</p>
<p>When a closure captures a value from its environment, the closure uses memory
to store the values for use in the closure body. This use of memory is overhead
that we don't want pay for in the more common case where we want to execute
code that doesn't capture its environment. Because functions are never allowed
to capture their environment, defining and using functions will never incur
this overhead.</p>
<!-- Why didn't this work, is there a reason ingrained in the language? Or is
that not really relevant? -->
<!-- I've added an explanation /Carol -->
<p>Closures can capture values from their environment in three ways, which
directly map to the three ways a function can take a parameter: taking
ownership, borrowing immutably, and borrowing mutably. These ways of capturing
values are encoded in the three <code>Fn</code> traits as follows:</p>
<ul>
<li><code>FnOnce</code> takes ownership of the variables it captures from the environment
and moves those variables into the closure when the closure is defined.
Therefore, a <code>FnOnce</code> closure cannot be called more than once in the same
context.</li>
<li><code>Fn</code> borrows values from the environment immutably.</li>
<li><code>FnMut</code> can change the environment since it mutably borrows values.</li>
</ul>
<p>When we create a closure, Rust infers how we want to reference the environment
based on how the closure uses the values from the environment. In Listing
13-12, the <code>equal_to_x</code> closure borrows <code>x</code> immutably (so <code>equal_to_x</code> has the
<code>Fn</code> trait) since the body of the closure only needs to read the value in <code>x</code>.</p>
<p>If we want to force the closure to take ownership of the values it uses in the
environment, we can use the <code>move</code> keyword before the parameter list. This is
mostly useful when passing a closure to a new thread in order to move the data
to be owned by the new thread. We'll have more examples of <code>move</code> closures in
Chapter 16 when we talk about concurrency, but for now here's the code from
Listing 13-12 with the <code>move</code> keyword added to the closure definition and using
vectors instead of integers, since integers can be copied rather than moved:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!(&quot;can't use x here: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
</code></pre>
<p>This example doesn't compile:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `x`
 --&gt; src/main.rs:6:40
  |
4 |     let equal_to_x = move |z| z == x;
  |                      -------- value moved (into closure) here
5 |
6 |     println!(&quot;can't use x here: {:?}&quot;, x);
  |                                        ^ value used here after move
  |
  = note: move occurs because `x` has type `std::vec::Vec&lt;i32&gt;`, which does not
    implement the `Copy` trait
</code></pre>
<p>The <code>x</code> value is moved into the closure when the closure is defined because of
the <code>move</code> keyword. The closure then has ownership of <code>x</code>, and <code>main</code> isn't
allowed to use <code>x</code> anymore. Removing the <code>println!</code> will fix this example.</p>
<p>Most of the time when specifying one of the <code>Fn</code> trait bounds, you can start
with <code>Fn</code> and the compiler will tell you if you need <code>FnMut</code> or <code>FnOnce</code> based
on what happens in the closure body.</p>
<p>To illustrate situations where closures that can capture their environment are
useful as function parameters, let's move on to our next topic: iterators.</p>
<a class="header" href="print.html#processing-a-series-of-items-with-iterators" id="processing-a-series-of-items-with-iterators"><h2>Processing a Series of Items with Iterators</h2></a>
<!-- From reading on, it seems like an iterator is useless without the methods
we use it with --- I think this is an important point to make early, I did find
it difficult to know what an iterator actually was throughout, and how it
depends on these other methods. Can you add something to this effect? -->
<!-- Reiterating the need for a clear definition of an iterator here--it seems
like an item that's used in iteration rather than something that performs the
process of iteration itself, is that right? Like a counter passed from element
to element? Can we define this at the begin of the iterator section? -->
<!-- I've added an explanation along these lines, does this help? /Carol -->
<p>The iterator pattern allows you to perform some task on a sequence of items in
turn. An <em>iterator</em> is responsible for the logic around iterating over each item
in the sequence and determining when the sequence has finished. When we use
iterators, we don't have to reimplement that logic ourselves.</p>
<p>In Rust, iterators are <em>lazy</em>, which means they have no effect until we call
methods on them that consume the iterator to use it up. For example, the code
in Listing 13-13 creates an iterator over the items in the vector <code>v1</code> by
calling the <code>iter</code> method defined on <code>Vec</code>. This code by itself doesn't do
anything useful:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
#}</code></pre></pre>
<p><span class="caption">Listing 13-13: Creating an iterator; this by itself isn't
useful</span></p>
<p>After creating an iterator, we can choose to use it in a variety of ways. In
Listing 3-6, we actually used iterators with <code>for</code> loops to execute some code
on each item, though we glossed over what the call to <code>iter</code> did until now. The
example in Listing 13-14 separates the creation of the iterator from the use of
the iterator in the <code>for</code> loop. The iterator is stored in the <code>v1_iter</code>
variable, and no iteration takes place at that time. Once the <code>for</code> loop is
called using the iterator in <code>v1_iter</code>, then each element in the iterator is
used in one iteration of the loop, which prints out each value:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!(&quot;Got: {}&quot;, val);
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-13: Making use of an iterator in a <code>for</code>
loop</span></p>
<p>In languages that don't have iterators provided by their standard libraries, we
would likely write this same functionality by starting a variable at index 0,
using that variable to index into the vector to get a value, and incrementing
the variable value in a loop until its value gets up to the total number of
items in the vector. Iterators take care of all of that logic for us, which
cuts down on the repetitive code we would have to write and potentially mess up.
In addition, the way iterators are implemented gives us more flexibility to
use the same logic with many different kinds of sequences, not just data
structures that we can index into like vectors. Let's see how iterators do that.</p>
<a class="header" href="print.html#the-iterator-trait-and-the-next-method" id="the-iterator-trait-and-the-next-method"><h3>The <code>Iterator</code> trait and the <code>next</code> method</h3></a>
<p>Iterators all implement a trait named <code>Iterator</code> that is defined in the
standard library. The definition of the trait looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
#}</code></pre></pre>
<p>You'll notice some new syntax that we haven't covered yet: <code>type Item</code> and
<code>Self::Item</code>, which are defining an <em>associated type</em> with this trait. We'll
talk about associated types in depth in Chapter 19, but for now, all you need
to know is that this code says implementing <code>Iterator</code> trait requires that you
also define an <code>Item</code> type, and this <code>Item</code> type is used in the return type of
the <code>next</code> method. In other words, the <code>Item</code> type will be the type of element
that's returned from the iterator.</p>
<p>The <code>next</code> method is the only method that the <code>Iterator</code> trait requires
implementers of the trait to define. <code>next</code> returns one item of the iterator
at a time wrapped in <code>Some</code>, and when iteration is over, it returns <code>None</code>.
We can call the <code>next</code> method on iterators directly if we'd like; Listing 13-14
has a test that demonstrates the values we'd get on repeated calls to <code>next</code>
on the iterator created from the vector:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust test_harness">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&amp;1));
    assert_eq!(v1_iter.next(), Some(&amp;2));
    assert_eq!(v1_iter.next(), Some(&amp;3));
    assert_eq!(v1_iter.next(), None);
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-14: Calling the <code>next</code> method on an
iterator</span></p>
<p>Note that we needed to make <code>v1_iter</code> mutable: calling the <code>next</code> method on an
iterator changes the iterator's state that keeps track of where it is in the
sequence. Put another way, this code <em>consumes</em>, or uses up, the iterator. Each
call to <code>next</code> eats up an item from the iterator.</p>
<p>Also note that the values we get from the calls to <code>next</code> are immutable
references to the values in the vector. The <code>iter</code> method produces an iterator
over immutable references. If we wanted to create an iterator that takes
ownership of <code>v1</code> and returns owned values, we can call <code>into_iter</code> instead of
<code>iter</code>. Similarly, if we want to iterate over mutable references, we can call
<code>iter_mut</code> instead of <code>iter</code>.</p>
<a class="header" href="print.html#methods-in-the-iterator-trait-that-consume-the-iterator" id="methods-in-the-iterator-trait-that-consume-the-iterator"><h3>Methods in the <code>Iterator</code> Trait that Consume the Iterator</h3></a>
<!-- Can you explain what it is you mean by "consumes" an iterator here? It
doesn't look like we do in this section, I think that's important to lay that
out clearly -->
<!-- This next paragraph doesn't give much away to me I'm afraid, not being
clear what we mean by *consume* at this point. Is a consuming adaptor like a
catalyst? -->
<!-- I hope this section addresses these comments you had /Carol -->
<p>The <code>Iterator</code> trait has a number of different methods with default
implementations provided for us by the standard library; you can find out all
about these methods by looking in the standard library API documentation for
the <code>Iterator</code> trait. Some of these methods call the <code>next</code> method in their
definition, which is why we're required to implement the <code>next</code> method when
implementing the <code>Iterator</code> trait.</p>
<!-- Is there somewhere they can learn about all the methods and what they do,
how to use them? This seems like a good sample example, and if we can broaden
it out that would be really helpful -->
<!-- I've moved this comment here since you made this comment on the last
version of this chapter right after a spot where we mentioned looking at the
standard library API documentation for the iterator trait, like we're now doing
in the above paragraph. That's where the reader should go to learn about
all the methods and what they do and how to use them. Can you elaborate on why
that wasn't clear in the previous version of the chapter? Is there a reason why
the standard library API documentation didn't sound like that place to go?
/Carol -->
<p>The methods that call the <code>next</code> method are called <em>consuming adaptors</em>, since
calling them uses up the iterator. An example of a consuming adaptor is the
<code>sum</code> method. This method takes ownership of the iterator and iterates through
the items by repeatedly calling <code>next</code>, thus consuming the iterator. As it
iterates through each item, it adds each item to a running total and returns
the total when iteration has completed. Listing 13-15 has a test illustrating a
use of the <code>sum</code> method:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-15: Calling the <code>sum</code> method to get the total
of all items in the iterator</span></p>
<p>We aren't allowed to use <code>v1_iter</code> after the call to <code>sum</code> since <code>sum</code> takes
ownership of the iterator we call it on.</p>
<a class="header" href="print.html#methods-in-the-iterator-trait-that-produce-other-iterators" id="methods-in-the-iterator-trait-that-produce-other-iterators"><h3>Methods in the <code>Iterator</code> Trait that Produce Other Iterators</h3></a>
<p>Another kind of method defined on the <code>Iterator</code> trait are methods that produce
other iterators. These methods are called <em>iterator adaptors</em> and allow us to
change iterators into different kind of iterators. We can chain multiple calls
to iterator adaptors. Because all iterators are lazy, however, we have to
call one of the consuming adaptor methods in order to get results from calls
to iterator adaptors. Listing 13-16 shows an example of calling the iterator
adaptor method <code>map</code>, which takes a closure that <code>map</code> will call on each
item in order to produce a new iterator in which each item from the vector has
been incremented by 1. This code produces a warning, though:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
#}</code></pre></pre>
<p><span class="caption">Listing 13-16: Calling the iterator adapter <code>map</code> to
create a new iterator</span></p>
<p>The warning we get is:</p>
<pre><code class="language-text">warning: unused result which must be used: iterator adaptors are lazy and do
nothing unless consumed
 --&gt; src/main.rs:4:1
  |
4 | v1.iter().map(|x| x + 1);
  | ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(unused_must_use)] on by default
</code></pre>
<p>The code in Listing 13-16 isn't actually doing anything; the closure we've
specified never gets called. The warning reminds us why: iterator adaptors are
lazy, and we probably meant to consume the iterator here.</p>
<p>In order to fix this warning and consume the iterator to get a useful result,
we're going to use the <code>collect</code> method, which we saw briefly in Chapter 12.
This method consumes the iterator and collects the resulting values into a
data structure. In Listing 13-17, we're going to collect the results of
iterating over the iterator returned from the call to <code>map</code> into a vector that
will contain each item from the original vector incremented by 1:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
#}</code></pre></pre>
<p><span class="caption">Listing 13-17: Calling the <code>map</code> method to create a new
iterator, then calling the <code>collect</code> method to consume the new iterator and
create a vector</span></p>
<p>Because <code>map</code> takes a closure, we can specify any operation that we want to
perform on each item that we iterate over. This is a great example of how using
closures lets us customize some behavior while reusing the iteration behavior
that the <code>Iterator</code> trait provides.</p>
<!-- I'm not clear from this last sentence which part is iterating through each
element, iter or map? What is map actually doing?-->
<!--Ah, I'm afraid I completely failed to follow this. What is the second
iterator for? I'm still not clear on what map does, can you expand on this? It
seems crucial to using iterators. Map applies the iterator to each element,
which applies the closure?
<p>Also, to generalize this discussion a bit, would you ever use iter without map?
--&gt;</p>
<!-- I hope this new breakdown/rearranging has cleared up these comments you
had on the last version of this chapter about the difference between
iter and map. I hope the added examples where we've used iter without map have
cleared up the last question. /Carol -->
<a class="header" href="print.html#using-closures-that-capture-their-environment-with-iterators" id="using-closures-that-capture-their-environment-with-iterators"><h3>Using Closures that Capture their Environment with Iterators</h3></a>
<p>Now that we've introduced iterators, we can demonstrate a common use of
closures that capture their environment by using the <code>filter</code> iterator adapter.
The <code>filter</code> method on an iterator takes a closure that takes each item from
the iterator and returns a boolean. If the closure returns <code>true</code>, the value
will be included in the iterator produced by <code>filter</code>. If the closure returns
<code>false</code>, the value won't be included in the resulting iterator. Listing 13-18
demonstrates using <code>filter</code> with a closure that captures the <code>shoe_size</code>
variable from its environment in order to iterate over a collection of <code>Shoe</code>
struct instances in order to return only shoes that are the specified size:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust test_harness">
# #![allow(unused_variables)]
#fn main() {
#[derive(PartialEq, Debug)]
struct Shoe {
    size: i32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec&lt;Shoe&gt;, shoe_size: i32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
}

#[test]
fn filters_by_size() {
    let shoes = vec![
        Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
        Shoe { size: 13, style: String::from(&quot;sandal&quot;) },
        Shoe { size: 10, style: String::from(&quot;boot&quot;) },
    ];

    let in_my_size = shoes_in_my_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
            Shoe { size: 10, style: String::from(&quot;boot&quot;) },
        ]
    );
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-18: Using the <code>filter</code> method with a closure
that captures <code>shoe_size</code></span></p>
<!-- Will add wingdings in libreoffice /Carol -->
<p>The <code>shoes_in_my_size</code> function takes ownership of a vector of shoes and a shoe
size as parameters. It returns a vector containing only shoes of the specified
size. In the body of <code>shoes_in_my_size</code>, we call <code>into_iter</code> to create an
iterator that takes ownership of the vector. Then we call <code>filter</code> to adapt
that iterator into a new iterator that only contains elements for which the
closure returns <code>true</code>. The closure we've specified captures the <code>shoe_size</code>
parameter from the environment and uses the value to compare with each shoe's
size to only keep shoes that are of the size specified. Finally, calling
<code>collect</code> gathers the values returned by the adapted iterator into a vector
that the function returns.</p>
<p>The test shows that when we call <code>shoes_in_my_size</code>, we only get back shoes
that have the same size as the value we specified.</p>
<a class="header" href="print.html#implementing-the-iterator-trait-to-create-our-own-iterators" id="implementing-the-iterator-trait-to-create-our-own-iterators"><h3>Implementing the <code>Iterator</code> Trait to Create Our Own Iterators</h3></a>
<!-- So it seems like we are creating a program with an iterator inside, is
that right? I assumed the whole thing we were making was an iterator at first,
which lead to a few confusions, can you lay it out up front? -->
<!-- I'm not sure what you mean here, can you elaborate on what the distinction
is to you between "a program with an iterator inside" and "whole thing we were
making was an iterator"? I don't understand what you mean by these terms so I'm
not sure how to clear this up. /Carol -->
<p>We've shown that we can create an iterator by calling <code>iter</code>, <code>into_iter</code>, or
<code>iter_mut</code> on a vector. We can also create iterators from the other collection
types in the standard library, such as hash map. Additionally, we can implement
the <code>Iterator</code> trait in order to create iterators that do anything we want.
As previously mentioned, the only method we're required to provide a definition
for is the <code>next</code> method. Once we've done that, we can use all the other
methods that have default implementations provided by the <code>Iterator</code> trait on
our iterator!</p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>The iterator we're going to create is one that will only ever count from 1
to 5. First, we'll create a struct to hold on to some values, and then we'll
make this struct into an iterator by implementing the <code>Iterator</code> trait and use
the values in that implementation.</p>
<p>Listing 13-19 has the definition of the <code>Counter</code> struct and an associated
<code>new</code> function to create instances of <code>Counter</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-19: Defining the <code>Counter</code> struct and a <code>new</code>
function that creates instances of <code>Counter</code> with an initial value of 0 for
<code>count</code></span></p>
<!-- Could you add a filename here? I think that will help the reader keep
track of what they're working on. Can you also just sum up in a line what this
code has accomplished so far? I moved this down from above the code, if this
will do? -->
<!-- Done /Carol -->
<p>The <code>Counter</code> struct has one field named <code>count</code>. This field holds a <code>u32</code>
value that will keep track of where we are in the process of iterating from 1
to 5. The <code>count</code> field is private since we want the implementation of
<code>Counter</code> to manage its value. The <code>new</code> function enforces the behavior we want
of always starting new instances with a value of 0 in the <code>count</code> field.</p>
<!-- Why define the new method, if it isn't necessary? Or is that what this
next line is telling us? -->
<!-- So does this code just initialize it with 0? Is that jat { count: 0 }
does?-->
<!-- I've rearranged to make this clearer /Carol -->
<p>Next, we're going to implement the <code>Iterator</code> trait for our <code>Counter</code> type by
defining the body of the <code>next</code> method to specify what we want to happen when
this iterator is used, as shown in Listing 13-20:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.count += 1;

        if self.count &lt; 6 {
            Some(self.count)
        } else {
            None
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-20: Implementing the <code>Iterator</code> trait on our
<code>Counter</code> struct</span></p>
<!-- I will add wingdings in libreoffice /Carol -->
<p>We set the associated <code>Item</code> type for our iterator to <code>u32</code>, meaning the
iterator will return <code>u32</code> values. Again, don't worry about associated types
yet, we'll be covering them in Chapter 19. We want our iterator to add one to
the current state, which is why we initialized <code>count</code> to 0: we want our
iterator to return one first. If the value of <code>count</code> is less than six, <code>next</code>
will return the current value wrapped in <code>Some</code>, but if <code>count</code> is six or
higher, our iterator will return <code>None</code>.</p>
<a class="header" href="print.html#using-our-counter-iterators-next-method" id="using-our-counter-iterators-next-method"><h4>Using Our <code>Counter</code> Iterator's <code>next</code> Method</h4></a>
<p>Once we've implemented the <code>Iterator</code> trait, we have an iterator! Listing 13-21
shows a test demonstrating that we can use the iterator functionality our
<code>Counter</code> struct now has by calling the <code>next</code> method on it directly, just like
we did with the iterator created from a vector in Listing 13-14:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
# impl Iterator for Counter {
#     type Item = u32;
#
#     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
#         self.count += 1;
#
#         if self.count &lt; 6 {
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
#
#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-21: Testing the functionality of the <code>next</code>
method implementation</span></p>
<p>This test creates a new <code>Counter</code> instance in the <code>counter</code> variable and then
calls <code>next</code> repeatedly, verifying that we have implemented the behavior we
want this iterator to have of returning the values from 1 to 5.</p>
<!-- So if I have this right, the first line creates a new Counter called
counter, and the rest of them merely call counter with next, store it in x, and
then print x? And we have to do that 5 times to get the 1-5 count? Phew, could
you wrap that up if indeed it is correct!) and sum up here? -->
<!-- I decided to change this into a test rather than printing out values, and
I added some summary text about what the test is doing. Is this clearer? /Carol
-->
<a class="header" href="print.html#using-other-iterator-trait-methods-on-our-iterator" id="using-other-iterator-trait-methods-on-our-iterator"><h4>Using Other <code>Iterator</code> Trait Methods on Our Iterator</h4></a>
<p>Because we implemented the <code>Iterator</code> trait by defining the <code>next</code> method, we
can now use any <code>Iterator</code> trait method's default implementations that the
standard library has defined, since they all use the <code>next</code> method's
functionality.</p>
<!-- So we can't just use these methods anyway? It seems like we did earlier,
but here we have to use next first, before we cam access these methods? -->
<!-- No, we don't have to *use* `next` before we can use the other methods, we
have to *define* `next` before we can use the other methods. I hope the various
rewordings and reworkings have made this clearer by this point. /Carol -->
<!-- below: once you've done what, defined a default implementation? Only then
can you use other adapters, is that what we're saying? And I'm still not clear
on what an adapter does/means, as opposed to a method, or consumer, at this
point. -->
<!-- I hope this comment has been cleared up too /Carol -->
<p>For example, if for some reason we wanted to take the values that an instance
of <code>Counter</code> produces, pair those values with values produced by another
<code>Counter</code> instance after skipping the first value that instance produces,
multiply each pair together, keep only those results that are divisible by
three, and add all the resulting values together, we could do so as shown in
the test in Listing 13-22:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
# impl Counter {
#     fn new() -&gt; Counter {
#         Counter { count: 0 }
#     }
# }
#
# impl Iterator for Counter {
#     // Our iterator will produce u32s
#     type Item = u32;
#
#     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
#         // increment our count. This is why we started at zero.
#         self.count += 1;
#
#         // check to see if we've finished counting or not.
#         if self.count &lt; 6 {
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
#
#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                 .map(|(a, b)| a * b)
                                 .filter(|x| x % 3 == 0)
                                 .sum();
    assert_eq!(18, sum);
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-22: Using a variety of <code>Iterator</code> trait
methods on our <code>Counter</code> iterator</span></p>
<p>Note that <code>zip</code> produces only four pairs; the theoretical fifth pair <code>(5, None)</code> is never produced because <code>zip</code> returns <code>None</code> when either of its input
iterators return <code>None</code>.</p>
<p>All of these method calls are possible because we implemented the <code>Iterator</code>
trait by specifying how the <code>next</code> method works and the standard library
provides default implementations for other methods that call <code>next</code>.</p>
<a class="header" href="print.html#improving-our-io-project" id="improving-our-io-project"><h2>Improving our I/O Project</h2></a>
<p>We can improve our implementation of the I/O project in Chapter 12 by using
iterators to make places in the code clearer and more concise. Let's take a
look at how iterators can improve our implementation of both the <code>Config::new</code>
function and the <code>search</code> function.</p>
<a class="header" href="print.html#removing-a-clone-using-an-iterator" id="removing-a-clone-using-an-iterator"><h3>Removing a <code>clone</code> Using an Iterator</h3></a>
<p>In Listing 12-13, we had code that took a slice of <code>String</code> values and created
an instance of the <code>Config</code> struct by checking for the right number of
arguments, indexing into the slice, and cloning the values so that the <code>Config</code>
struct could own those values. We've reproduced the code here in Listing 13-23:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config {
            query, filename
        })
    }
}
</code></pre>
<p><span class="caption">Listing 13-23: Reproduction of the <code>Config::new</code> function
from Listing 12-13</span></p>
<!--Is this why we didn't want to use clone calls, they were inefficient, or
was it that stacking clone calls can become confusing/is bad practice? -->
<!-- Yep, it's for performance reasons /Carol -->
<p>At the time, we said not to worry about the inefficient <code>clone</code> calls here
because we would remove them in the future. Well, that time is now!</p>
<p>The reason we needed <code>clone</code> here in the first place is that we have a slice
with <code>String</code> elements in the parameter <code>args</code>, but the <code>new</code> function does not
own <code>args</code>. In order to be able to return ownership of a <code>Config</code> instance, we
need to clone the values that we put in the <code>query</code> and <code>filename</code> fields of
<code>Config</code>, so that the <code>Config</code> instance can own its values.</p>
<p>With our new knowledge about iterators, we can change the <code>new</code> function to
take ownership of an iterator as its argument instead of borrowing a slice.
We'll use the iterator functionality instead of the code we had that checks the
length of the slice and indexes into specific locations. This will clear up
what the <code>Config::new</code> function is doing since the iterator will take care of
accessing the values.</p>
<!-- use the iterator functionality to what? How will iterating allow us to do
the same thing, can you briefly lay that out? -->
<!-- It's mostly for clarity and using a good abstraction, I've tried fixing
/Carol -->
<p>Once <code>Config::new</code> taking ownership of the iterator and not using indexing
operations that borrow, we can move the <code>String</code> values from the iterator into
<code>Config</code> rather than calling <code>clone</code> and making a new allocation.</p>
<!-- below: which file are we in, can you specify here? -->
<!-- done /Carol -->
<a class="header" href="print.html#using-the-iterator-returned-by-envargs-directly" id="using-the-iterator-returned-by-envargs-directly"><h4>Using the Iterator Returned by <code>env::args</code> Directly</h4></a>
<p>In your I/O project's <em>src/main.rs</em>, let's change the start of the <code>main</code>
function from this code that we had in Listing 12-23:</p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    let mut stderr = std::io::stderr();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        writeln!(
            &amp;mut stderr,
            &quot;Problem parsing arguments: {}&quot;,
            err
        ).expect(&quot;Could not write to stderr&quot;);
        process::exit(1);
    });
    // ...snip...
}
</code></pre>
<p>To the code in Listing 13-24:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut stderr = std::io::stderr();

    let config = Config::new(env::args()).unwrap_or_else(|err| {
        writeln!(
            &amp;mut stderr,
            &quot;Problem parsing arguments: {}&quot;,
            err
        ).expect(&quot;Could not write to stderr&quot;);
        process::exit(1);
    });
    // ...snip...
}
</code></pre>
<p><span class="caption">Listing 13-24: Passing the return value of <code>env::args</code> to
<code>Config::new</code></span></p>
<!-- I think, if we're going to be building this up bit by bit, it might be
worth adding listing numbers and file names to each, can you add those? Don't
worry about being accurate with the numbers, we can update them more easily
later -->
<!-- That's nice of you to offer, but since we're maintaining an online version
that we're keeping in sync with each round of edits, we need to keep the
listing numbers making sense as well. We'll just take care of them. /Carol -->
<p>The <code>env::args</code> function returns an iterator! Rather than collecting the
iterator values into a vector and then passing a slice to <code>Config::new</code>, now
we're passing ownership of the iterator returned from <code>env::args</code> to
<code>Config::new</code> directly.</p>
<p>Next, we need to update the definition of <code>Config::new</code>. In your I/O project's
<em>src/lib.rs</em>, let's change the signature of <code>Config::new</code> to look like Listing
13-25:</p>
<!-- can you give the filename here too? -->
<!-- done /Carol -->
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    fn new(args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // ...snip...
</code></pre>
<p><span class="caption">Listing 13-25: Updating the signature of <code>Config::new</code> to
expect an iterator</span></p>
<p>The standard library documentation for the <code>env::args</code> function shows that the
type of the iterator it returns is <code>std::env::Args</code>. We've updated the
signature of the <code>Config::new</code> function so that the parameter <code>args</code> has the
type <code>std::env::Args</code> instead of <code>&amp;[String]</code>.</p>
<a class="header" href="print.html#using-iterator-trait-methods-instead-of-indexing" id="using-iterator-trait-methods-instead-of-indexing"><h4>Using <code>Iterator</code> Trait Methods Instead of Indexing</h4></a>
<p>Next, we'll fix the body of <code>Config::new</code>. The standard library documentation
also mentions that <code>std::env::Args</code> implements the <code>Iterator</code> trait, so we know
we can call the <code>next</code> method on it! Listing 13-26 has the new code:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Config {
#     query: String,
#     filename: String,
# }
#
impl Config {
    fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a query string&quot;),
        };

        let filename = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a file name&quot;),
        };

        Ok(Config {
            query, filename
        })
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-26: Changing the body of <code>Config::new</code> to use
iterator methods</span></p>
<!-- is this the *full* new lib.rs code? Worth noting for ghosting purposes -->
<!-- No, this is just the `Config::new` function, which I thought would be
clear by saying "Next, we'll fix the body of `Config::new`.", can you elaborate
on why that's not clear enough? I would expect programmers to be able to
understand where a function starts and ends. /Carol -->
<p>Remember that the first value in the return value of <code>env::args</code> is the name of
the program. We want to ignore that and get to the next value, so first we call
<code>next</code> and do nothing with the return value. Second, we call <code>next</code> on the
value we want to put in the <code>query</code> field of <code>Config</code>. If <code>next</code> returns a
<code>Some</code>, we use a <code>match</code> to extract the value. If it returns <code>None</code>, it means
not enough arguments were given and we return early with an <code>Err</code> value. We do
the same thing for the <code>filename</code> value.</p>
<!-- Hm, if ? would not work anyway, I'm not clear on why we mention, why it's
a shame we cant use it on Option? -->
<!-- We've taken this out, it's something that a portion of the readers might
be wondering and something that Rust might let you do someday, but yeah, it's
probably just distracting to most people /Carol -->
<a class="header" href="print.html#making-code-clearer-with-iterator-adaptors" id="making-code-clearer-with-iterator-adaptors"><h3>Making Code Clearer with Iterator Adaptors</h3></a>
<p>The other place in our I/O project we could take advantage of iterators is in
the <code>search</code> function, as implemented in Listing 12-19 and reproduced here in
Listing 13-27:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<p><span class="caption">Listing 13-27: The implementation of the <code>search</code>
function from Listing 12-19</span></p>
<p>We can write this code in a much shorter way by using iterator adaptor methods
instead. This also lets us avoid having a mutable intermediate <code>results</code>
vector. The functional programming style prefers to minimize the amount of
mutable state to make code clearer. Removing the mutable state might make it
easier for us to make a future enhancement to make searching happen in
parallel, since we wouldn't have to manage concurrent access to the <code>results</code>
vector. Listing 13-28 shows this change:</p>
<!-- Remind us why we want to avoid the mutable results vector? -->
<!-- done /Carol -->
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents.lines()
        .filter(|line| line.contains(query))
        .collect()
}
</code></pre>
<p><span class="caption">Listing 13-28: Using iterator adaptor methods in the
implementation of the <code>search</code> function</span></p>
<p>Recall that the purpose of the <code>search</code> function is to return all lines in
<code>contents</code> that contain the <code>query</code>. Similarly to the <code>filter</code> example in
Listing 13-18, we can use the <code>filter</code> adaptor to keep only the lines that
<code>line.contains(query)</code> returns true for. We then collect the matching lines up
into another vector with <code>collect</code>. Much simpler!</p>
<!-- what is that, here, only lines that contain a matching string? A bit more
context would help out, we probably can't rely on readers remembering all the
details I'm afraid -->
<!-- done /Carol -->
<p>The next logical question is which style you should choose in your own code:
the original implementation in Listing 13-27, or the version using iterators in
Listing 13-28. Most Rust programmers prefer to use the iterator style. It's a
bit tougher to get the hang of at first, but once you get a feel for the
various iterator adaptors and what they do, iterators can be easier to
understand. Instead of fiddling with the various bits of looping and building
new vectors, the code focuses on the high-level objective of the loop. This
abstracts away some of the commonplace code so that it's easier to see the
concepts that are unique to this code, like the filtering condition each
element in the iterator must pass.</p>
<p>But are the two implementations truly equivalent? The intuitive assumption
might be that the more low-level loop will be faster. Let's talk about
performance.</p>
<a class="header" href="print.html#comparing-performance-loops-versus-iterators" id="comparing-performance-loops-versus-iterators"><h2>Comparing Performance: Loops versus Iterators</h2></a>
<p>To determine which to use, we need to know which version of our <code>search</code>
functions is faster: the version with an explicit <code>for</code> loop or the version
with iterators.</p>
<p>We ran a benchmark by loading the entire contents of &quot;The Adventures of
Sherlock Holmes&quot; by Sir Arthur Conan Doyle into a <code>String</code> and looking for the
word &quot;the&quot; in the contents. Here were the results of the benchmark on the
version of <code>search</code> using the <code>for</code> loop and the version using iterators:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>The iterator version ended up slightly faster! We're not going to go through
the benchmark code here, as the point is not to prove that they're exactly
equivalent, but to get a general sense of how these two implementations compare
performance-wise. For a more comprehensive benchmark, you'd want to check
various texts of various sizes, different words, words of different lengths,
and all kinds of other variations. The point is this: iterators, while a
high-level abstraction, get compiled down to roughly the same code as if you'd
written the lower-level code yourself. Iterators are one of Rust's <em>zero-cost
abstractions</em>, by which we mean using the abstraction imposes no additional
runtime overhead in the same way that Bjarne Stroustrup, the original designer
and implementer of C++, defines <em>zero-overhead</em>:</p>
<blockquote>
<p>In general, C++ implementations obey the zero-overhead principle: What you
don’t use, you don’t pay for. And further: What you do use, you couldn’t hand
code any better.</p>
<ul>
<li>Bjarne Stroustrup &quot;Foundations of C++&quot;</li>
</ul>
</blockquote>
<!-- should this be "handle code any better", above? -->
<!-- No, this is an exact quote. He means hand code, as in "code by hand",
rather than let the language/standard library code it for you. The quote is
at the top of page 4 in http://www.stroustrup.com/ETAPS-corrected-draft.pdf
/Carol -->
<p>As another example, here is some code taken from an audio decoder. The decoding
algorithm uses the linear prediction mathematical operation to estimate future
values based on a linear function of the previous samples.</p>
<!-- Can you briefly explain what the intention of the code it --- that will
help us understand, for example, why we have a `prediction` value -->
<!-- I've tried, but the algorithm is really complicated and not really all
that important... /Carol -->
<p>This code uses an iterator chain to do some math on three variables in scope: a
<code>buffer</code> slice of data, an array of 12 <code>coefficients</code>, and an amount by which
to shift data in <code>qlp_shift</code>. We've declared the variables within this example
but not given them any values; while this code doesn't have much meaning
outside of its context, it's still a concise, real-world example of how Rust
translates high-level ideas to low-level code:</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
</code></pre>
<p>In order to calculate the value of <code>prediction</code>, this code iterates through
each of the 12 values in <code>coefficients</code> and uses the <code>zip</code> method to pair the
coefficient values with the previous 12 values in <code>buffer</code>. Then, for each
pair, we multiply the values together, sum all the results, and shift the bits
in the sum <code>qlp_shift</code> bits to the right.</p>
<p>Calculations in applications like audio decoders often prioritize performance
most highly. Here, we're creating an iterator, using two adaptors, then
consuming the value. What assembly code would this Rust code compile to? Well,
as of this writing, it compiles down to the same assembly you'd write by hand.
There's no loop at all corresponding to the iteration over the values in
<code>coefficients</code>: Rust knows that there are twelve iterations, so it &quot;unrolls&quot;
the loop. Unrolling is an optimization that removes the overhead of the loop
controlling code and instead generates repetitive code for each iteration of
the loop.</p>
<!-- Maybe some expansion on what you mean by unrolls? -->
<!-- done /Carol -->
<p>All of the coefficients get stored in registers, which means it's very fast to
access the values. There are no bounds checks on the array access at runtime.
All these optimizations Rust is able to apply make the resulting code extremely
efficient.</p>
<p>Now that you know this, go use iterators and closures without fear! They make
code feel higher-level, but don't impose a runtime performance penalty for
doing so.</p>
<a class="header" href="print.html#summary-5" id="summary-5"><h2>Summary</h2></a>
<p>Closures and iterators are Rust features inspired by functional programming
language ideas. They contribute to Rust's ability to clearly express high-level
ideas, at low level performance. The implementations of closures and iterators
are such that runtime performance is not affected. This is part of Rust's goal
to strive to provide zero-cost abstractions.</p>
<!-- Are we going to cover which other elements of rust are zero-cost
abstractions, somewhere? Might be good to cross ref or, if we've already
covered, give a brief list or a way to identify them -->
<!-- Zero-cost abstraction in Rust is more about a design philosophy and a goal
we keep in mind; all abstractions in Rust strive to be zero-cost abstractions,
and if they aren't, it's considered a bug. There will always be some bugs. I've
reworded a bit to not make it sound as much like something we could list.
/Carol -->
<p>Now that we've improved the expressiveness of our I/O project, let's look at
some more features of <code>cargo</code> that would help us get ready to share the project
with the world.</p>
<a class="header" href="print.html#more-about-cargo-and-cratesio" id="more-about-cargo-and-cratesio"><h1>More about Cargo and Crates.io</h1></a>
<p>We've used some features of Cargo in this book so far, but only the most basic
ones. We've used Cargo to build, run, and test our code, but it can do a lot
more. Let's go over some of its other features now. Cargo can do even more than
what we will cover in this chapter; for a full explanation, see its
documentation.</p>
<p>We're going to cover:</p>
<ul>
<li>Customizing your build through release profiles</li>
<li>Publishing libraries on crates.io</li>
<li>Organizing larger projects with workspaces</li>
<li>Installing binaries from crates.io</li>
<li>Extending Cargo with your own custom commands</li>
</ul>
<a class="header" href="print.html#release-profiles" id="release-profiles"><h2>Release profiles</h2></a>
<p>Cargo supports a notion of <em>release profiles</em>. These profiles control various
options for compiling your code and let you configure each profile
independently of the others. You've seen a hint of this feature in the output
of your builds:</p>
<pre><code class="language-text">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
$ cargo build --release
    Finished release [optimized] target(s) in 0.0 secs
</code></pre>
<p>The &quot;dev&quot; and &quot;release&quot; notifications here indicate that the compiler is
using different profiles. Cargo supports four profiles:</p>
<ul>
<li><code>dev</code>: used for <code>cargo build</code></li>
<li><code>release</code> used for <code>cargo build --release</code></li>
<li><code>test</code> used for <code>cargo test</code></li>
<li><code>doc</code> used for <code>cargo doc</code></li>
</ul>
<p>We can customize our <code>Cargo.toml</code> file with <code>[profile.*]</code> sections to tweak
various compiler options for these profiles. For example, here's one of the
default options for the <code>dev</code> and <code>release</code> profiles:</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>The <code>opt-level</code> setting controls how many optimizations Rust will apply to your
code. The setting goes from zero to three. Applying more optimizations takes
more time. When you're compiling very often in development, you'd usually want
compiling to be fast at the expense of the resulting code running slower. When
you're ready to release, it's better to spend more time compiling the one time
that you build your code to trade off for code that will run faster every time
you use that compiled code.</p>
<p>We could override these defaults by changing them in <code>Cargo.toml</code>. For example,
if we wanted to use optimization level 1 in development:</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>This overrides the default setting of <code>0</code>, and now our development builds will
use more optimizations. Not as much as a release build, but a little bit more.</p>
<p>For the full list of settings and the defaults for each profile, see <a href="http://doc.crates.io/">Cargo's
documentation.</a></p>
<a class="header" href="print.html#publishing-a-crate-to-cratesio" id="publishing-a-crate-to-cratesio"><h2>Publishing a Crate to Crates.io</h2></a>
<p>We've added crates from crates.io as dependencies of our project. We can choose
to share our code for other people to use as well. Crates.io distributes the
source code of your packages, so it is primarily used to distribute code that's
open source.</p>
<p>Rust and Cargo have some features that can make your published package easier
for people to find and use. We'll talk about some of those features, then cover
how to publish a package.</p>
<a class="header" href="print.html#documentation-comments" id="documentation-comments"><h3>Documentation Comments</h3></a>
<p>In Chapter 3, we saw comments in Rust that start with <code>//</code>. Rust also has a
second kind of comment: the <em>documentation comment</em>. While comments can be
useful if someone is reading your code, you can generate HTML documentation
that displays the contents of documentation comments for public API items meant
for someone who's interested in knowing how to <em>use</em> your crate, as opposed to
how your crate is <em>implemented</em>. Note that documentation is only generated for
library crates, since binary crates don't have a public API that people need to
know how to use.</p>
<p>Documentation comments use <code>///</code> instead of <code>//</code> and support Markdown notation
inside. They go just before the item they are documenting. Here's documentation
comments for an <code>add_one</code> function:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let five = 5;
///
/// assert_eq!(6, add_one(five));
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
#}</code></pre></pre>
<p><span class="caption">Listing 14-1: A documentation comment for a
function</span></p>
<p><code>cargo doc</code> runs a tool distributed with Rust, <code>rustdoc</code>, to generate HTML
documentation from these comments. To try this out locally, you can run <code>cargo doc --open</code>, which will build the documentation for your current crate (as well
as all of your crate's dependencies) and open it in a web browser. Navigate to
the <code>add_one</code> function and you'll see how the text in the documentation
comments gets rendered.</p>
<p>Adding examples in code blocks in your documentation comments is a way to
clearly demonstrate how to use your library. There's an additional bonus reason
to do this: <code>cargo test</code> will run the code examples in your documentation as
tests! Nothing is better than documentation with examples. Nothing is worse
than examples that don't actually work because the code has changed since the
documentation has been written. Try running <code>cargo test</code> with the documentation
for the <code>add_one</code> function in Listing 14-1; you'll see a section in the test
results like this:</p>
<pre><code class="language-test">   Doc-tests add-one

running 1 test
test add_one_0 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Try changing the function or the example to see that <code>cargo test</code> will catch
that the example no longer works!</p>
<p>There's another style of doc comment, <code>//!</code>, to comment containing items (e.g.
crates, modules or functions), instead of the items following it. These are
typically used inside the crate root (lib.rs) or a module's root (mod.rs) to
document the crate or the module as a whole, respectively. Here's the
documentation within the <code>libstd</code> module that contains the entire standard
library:</p>
<pre><code>//! # The Rust Standard Library
//!
//! The Rust Standard Library provides the essential runtime
//! functionality for building portable Rust software.
</code></pre>
<a class="header" href="print.html#exporting-a-convenient-public-api-with-pub-use" id="exporting-a-convenient-public-api-with-pub-use"><h3>Exporting a Convenient Public API with <code>pub use</code></h3></a>
<p>In Chapter 7, we covered how to organize our code into modules with the <code>mod</code>
keyword, how to make items public with the <code>pub</code> keyword, and how to bring
items into a scope with the <code>use</code> keyword. When publishing a crate for people
unfamiliar with the implementation to use, it's worth taking time to consider
if the structure of your crate that's useful for you as you're developing is
what would be useful for people depending on your crate. If the structure isn't
convenient to use from another library, you don't have to rearrange your
internal organization: you can choose to re-export items to make a different
public structure with <code>pub use</code>.</p>
<p>For example, say that we made a library named <code>art</code> consisting of a <code>kinds</code>
module containing two enums named <code>PrimaryColor</code> and <code>SecondaryColor</code>, and a
<code>utils</code> module containing a function named <code>mix</code> as shown in Listing 14-2:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // ...snip...
#         SecondaryColor::Green
    }
}
</code></pre>
<p><span class="caption">Listing 14-2: An <code>art</code> library with items organized into
<code>kinds</code> and <code>utils</code> modules</span></p>
<p>In order to use this library, another crate would have <code>use</code> statements as in
Listing 14-3:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate art;

use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
</code></pre>
<p><span class="caption">Listing 14-3: A program using the <code>art</code> crate's items
with its internal structure exported</span></p>
<p>Users of this crate shouldn't need to know that <code>PrimaryColor</code> and
<code>SecondaryColor</code> are in the <code>kinds</code> module, and <code>mix</code> is in the <code>utils</code> module;
that structure might be useful for internal organization but doesn't have much
meaning from the outside looking in.</p>
<p>To change this, we can add the following <code>pub use</code> statements to the code from
Listing 14-2 to re-export the types at the top level, as shown in Listing 14-4:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use kinds::PrimaryColor;
pub use kinds::SecondaryColor;
pub use utils::mix;

pub mod kinds {
    // ...snip...
</code></pre>
<p><span class="caption">Listing 14-4: Adding <code>pub use</code> statements to re-export
items</span></p>
<!-- Will add ghosting in libreoffice /Carol -->
<p>Re-exports are listed and linked on the front page of the crate's API
documentation. Users of the <code>art</code> crate can still see and choose to use the
internal structure as in Listing 14-3, or they can use the more convenient
structure from Listing 14-4, as shown in Listing 14-5:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate art;

use art::PrimaryColor;
use art::mix;

fn main() {
    // ...snip...
}
</code></pre>
<p><span class="caption">Listing 14-5: Using the re-exported items from the <code>art</code>
crate</span></p>
<!-- Will add ghosting in libreoffice /Carol -->
<p>Creating a useful public API structure is more of an art than a science.
Choosing <code>pub use</code> gives you flexibility in how you expose your crate's
internal structure to users. Take a look at some of the code of crates you've
installed to see if their internal structure differs from their public API.</p>
<a class="header" href="print.html#before-your-first-publish" id="before-your-first-publish"><h3>Before Your First Publish</h3></a>
<p>Before being able to publish any crates, you'll need to create an account on
<a href="https://crates.io">crates.io</a> and get an API token. To do so, <a href="https://crates.io">visit the home page</a>
and log in via a GitHub account. A GitHub account is a requirement for now, but
the site might support other ways of creating an account in the future. Once
you're logged in, visit your <a href="https://crates.io/me">Account Settings</a> page and run the <code>cargo login</code>
command with the API key as the page specifies, which will look something like
this:</p>
<pre><code class="language-text">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>This command will inform Cargo of your API token and store it locally in
<em>~/.cargo/config</em>. Note that this token is a <strong>secret</strong> and should not be
shared with anyone else. If it gets shared with anyone for any reason, you
should regenerate it immediately.</p>
<a class="header" href="print.html#before-publishing-a-new-crate" id="before-publishing-a-new-crate"><h3>Before Publishing a New Crate</h3></a>
<p>First, your crate will need a unique name. While you're working on a crate
locally, you may name a crate whatever you'd like, but crate names on
<a href="https://crates.io">crates.io</a> are allocated on a first-come-first- serve basis. Once a crate name
is taken, it cannot be used for another crate, so check on the site that the
name you'd like is available.</p>
<p>If you try to publish a crate as generated by <code>cargo new</code>, you'll get a warning
and then an error:</p>
<pre><code class="language-text">$ cargo publish
    Updating registry `https://github.com/rust-lang/crates.io-index`
warning: manifest has no description, license, license-file, documentation,
homepage or repository.
...snip...
error: api errors: missing or empty metadata fields: description, license.
Please see http://doc.crates.io/manifest.html#package-metadata for how to
upload metadata
</code></pre>
<p>We can include more information about our package in <em>Cargo.toml</em>. Some of
these fields are optional, but a description and a license are required in
order to publish so that people will know what your crate does and under what
terms they may use it.</p>
<p>The description appears with your crate in search results and on your crate's
page. Descriptions are usually a sentence or two. The <code>license</code> field takes a
license identifier value, and the possible values have been specified by the
Linux Foundation's <a href="http://spdx.org/licenses/">Software Package Data Exchange (SPDX)</a>. If you would
like to use a license that doesn't appear there, instead of the <code>license</code> key,
you can use <code>license-file</code> to specify the name of a file in your project that
contains the text of the license you want to use.</p>
<p>Guidance on which license is right for your project is out of scope for this
book. Many people in the Rust community choose to license their projects in the
same way as Rust itself, with a dual license of <code>MIT/Apache-2.0</code>, which
demonstrates that you can specify multiple license identifiers separated by a
slash. So the <em>Cargo.toml</em> for a project that is ready to publish might look
like this:</p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
description = &quot;A fun game where you guess what number the computer has chosen.&quot;
license = &quot;MIT/Apache-2.0&quot;

[dependencies]
</code></pre>
<p>Be sure to check out the <a href="http://doc.crates.io/manifest.html#package-metadata">documentation on crates.io</a> that
describes other metadata you can specify to ensure your crate can be discovered
and used more easily!</p>
<a class="header" href="print.html#publishing-to-cratesio" id="publishing-to-cratesio"><h3>Publishing to Crates.io</h3></a>
<p>Now that we've created an account, saved our API token, chosen a name for our
crate, and specified the required metadata, we're ready to publish! Publishing
a crate is when a specific version is uploaded to be hosted on crates.io.</p>
<p>Take care when publishing a crate, because a publish is <strong>permanent</strong>. The
version can never be overwritten, and the code cannot be deleted. However,
there is no limit to the number of versions which can be published.</p>
<p>Let's run the <code>cargo publish</code> command, which should succeed this time since
we've now specified the required metadata:</p>
<pre><code class="language-text">$ cargo publish
 Updating registry `https://github.com/rust-lang/crates.io-index`
Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
 Finished dev [unoptimized + debuginfo] target(s) in 0.19 secs
Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>Congratulations! You've now shared your code with the Rust community, and
anyone can easily add your crate as a dependency to their project.</p>
<a class="header" href="print.html#publishing-a-new-version-of-an-existing-crate" id="publishing-a-new-version-of-an-existing-crate"><h3>Publishing a New Version of an Existing Crate</h3></a>
<p>When you've made changes to your crate and are ready to release a new version,
change the <code>version</code> value specified in your <em>Cargo.toml</em>. Use the <a href="http://semver.org/">Semantic
Versioning rules</a> to decide what an appropriate next version number is
based on the kinds of changes you've made. Then run <code>cargo publish</code> to upload
the new version.</p>
<a class="header" href="print.html#removing-versions-from-cratesio-with-cargo-yank" id="removing-versions-from-cratesio-with-cargo-yank"><h3>Removing Versions from Crates.io with <code>cargo yank</code></h3></a>
<p>Occasions may arise where you publish a version of a crate that actually ends
up being broken for one reason or another, such as a syntax error or forgetting
to include a file. For situations such as this, Cargo supports <em>yanking</em> a
version of a crate.</p>
<p>Marking a version of a crate as yanked means that no projects will be able to
start depending on that version, but all existing projects that depend on that
version will continue to be allowed to download and depend on that version. One
of the major goals of crates.io is to act as a permanent archive of code so
that builds of all projects will continue to work, and allowing deletion of a
version would go against this goal. Essentially, a yank means that all projects
with a <em>Cargo.lock</em> will not break, while any future <em>Cargo.lock</em> files
generated will not use the yanked version.</p>
<p>A yank <strong>does not</strong> delete any code. The yank feature is not intended for
deleting accidentally uploaded secrets, for example. If that happens, you must
reset those secrets immediately.</p>
<p>To yank a version of a crate, run <code>cargo yank</code> and specify which version you
want to yank:</p>
<pre><code class="language-text">$ cargo yank --vers 1.0.1
</code></pre>
<p>You can also undo a yank, and allow projects to start depending on a version
again, by adding <code>--undo</code> to the command:</p>
<pre><code class="language-text">$ cargo yank --vers 1.0.1 --undo
</code></pre>
<a class="header" href="print.html#cargo-workspaces" id="cargo-workspaces"><h2>Cargo Workspaces</h2></a>
<p>In Chapter 12, we built a package that included both a binary crate and a
library crate. But what if the library crate continues to get bigger and we
want to split our package up further into multiple library crates? As packages
grow, separating out major components can be quite useful. In this situation,
Cargo has a feature called <em>workspaces</em> that can help us manage multiple
related packages that are developed in tandem.</p>
<p>A <em>workspace</em> is a set of packages that will all share the same <em>Cargo.lock</em>
and output directory. Let's make a project using a workspace where the code
will be trivial so that we can concentrate on the structure of a workspace.
We'll have a binary that uses two libraries: one that will provide an <code>add_one</code>
method and a second that will provide an <code>add_two</code> method. Let's start by
creating a new crate for the binary:</p>
<pre><code class="language-text">$ cargo new --bin adder
     Created binary (application) `adder` project
$ cd adder
</code></pre>
<p>We need to modify the binary package's <em>Cargo.toml</em> to tell Cargo the <code>adder</code>
package is a workspace. Add this at the bottom of the file:</p>
<pre><code class="language-toml">[workspace]
</code></pre>
<p>Like many Cargo features, workspaces support convention over configuration: we
don't need to say anything more than this as long as we follow the convention.
The convention is that any crates that we depend on as sub-directories will be
part of the workspace. Let's add a path dependency to the <code>adder</code> crate by
changing the <code>[dependencies]</code> section of <em>Cargo.toml</em> to look like this:</p>
<pre><code class="language-toml">[dependencies]
add-one = { path = &quot;add-one&quot; }
</code></pre>
<p>If we add dependencies that don't have a <code>path</code> specified, those will be normal
dependencies that aren't in this workspace.</p>
<p>Next, generate the <code>add-one</code> crate within the <code>adder</code> directory:</p>
<pre><code class="language-text">$ cargo new add-one
     Created library `add-one` project
</code></pre>
<p>Your <code>adder</code> directory should now have these directories and files:</p>
<pre><code class="language-text">├── Cargo.toml
├── add-one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
└── src
    └── main.rs
</code></pre>
<p>In <em>add-one/src/lib.rs</em>, let's add an implementation of an <code>add_one</code> function:</p>
<p><span class="filename">Filename: add-one/src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
#}</code></pre></pre>
<p>Open up <em>src/main.rs</em> for <code>adder</code> and add an <code>extern crate</code> line to bring the
new <code>add-one</code> library crate into scope, and change the <code>main</code> function to use
the <code>add_one</code> function:</p>
<pre><code class="language-rust ignore">extern crate add_one;

fn main() {
    let num = 10;
    println!(&quot;Hello, world! {} plus one is {}!&quot;, num, add_one::add_one(num));
}
</code></pre>
<p>Let's build it!</p>
<pre><code class="language-text">$ cargo build
   Compiling add-one v0.1.0 (file:///projects/adder/add-one)
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68 secs
</code></pre>
<p>Note that running <code>cargo build</code> in the <em>adder</em> directory built both that crate
and the <code>add-one</code> crate in <em>adder/add-one</em>, but created only one <em>Cargo.lock</em>
and one <em>target</em> directory, both in the <em>adder</em> directory. See if you can add
an <code>add-two</code> crate in the same way.</p>
<p>Let's now say that we'd like to use the <code>rand</code> crate in our <code>add-one</code> crate.
As usual, we'll add it to the <code>[dependencies]</code> section in the <code>Cargo.toml</code> for
that crate:</p>
<p><span class="filename">Filename: add-one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p>And if we add <code>extern crate rand;</code> to <em>add-one/src/lib.rs</em> then run <code>cargo build</code>, it will succeed:</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
   ...snip...
   Compiling rand v0.3.14
   Compiling add-one v0.1.0 (file:///projects/adder/add-one)
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18 secs
</code></pre>
<p>The top level <em>Cargo.lock</em> now reflects the fact that <code>add-one</code> depends
on <code>rand</code>. However, even though <code>rand</code> is used somewhere in the
workspace, we can't use it in other crates in the workspace unless we add
<code>rand</code> to their <em>Cargo.toml</em> as well. If we add <code>extern crate rand;</code> to
<em>src/main.rs</em> for the top level <code>adder</code> crate, for example, we'll get an error:</p>
<pre><code class="language-text">$ cargo build
   Compiling adder v0.1.0 (file:///projects/adder)
error[E0463]: can't find crate for `rand`
 --&gt; src/main.rs:1:1
  |
1 | extern crate rand;
  | ^^^^^^^^^^^^^^^^^^^ can't find crate
</code></pre>
<p>To fix this, edit <em>Cargo.toml</em> for the top level and indicate that <code>rand</code> is a
dependency for the <code>adder</code> crate.</p>
<p>For another enhancement, let's add a test of the <code>add_one::add_one</code> function
within that crate:</p>
<p><span class="filename">Filename: add-one/src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
#}</code></pre></pre>
<p>Now run <code>cargo test</code> in the top-level <em>adder</em> directory:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running target/debug/adder-f0253159197f7841

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Wait a second, zero tests? We just added one! If we look at the output, we can
see that <code>cargo test</code> in a workspace only runs the tests for the top level
crate. To run tests for the other crates, we need to use the <code>-p</code> argument to
indicate we want to run tests for a particular package:</p>
<pre><code class="language-text">$ cargo test -p add-one
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/add_one-abcabcabc

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Similarly, if you choose to publish the workspace to crates.io, each crate in
the workspace will get published separately.</p>
<p>As your project grows, consider a workspace: smaller components are easier to
understand individually than one big blob of code. Keeping the crates in a
workspace can make coordination among them easier if they work together and are
often changed at the same time.</p>
<a class="header" href="print.html#installing-binaries-from-cratesio-with-cargo-install" id="installing-binaries-from-cratesio-with-cargo-install"><h2>Installing Binaries from Crates.io with <code>cargo install</code></h2></a>
<p>The <code>cargo install</code> command allows you to install and use binary crates
locally. This isn't intended to replace system packages; it's meant to be a
convenient way for Rust developers to install tools that others have shared on
crates.io. Only packages which have binary targets can be installed, and all
binaries are installed into the installation root's <em>bin</em> folder. If you
installed Rust using <em>rustup.rs</em> and don't have any custom configurations, this
will be <code>$HOME/.cargo/bin</code>. Add that directory to your <code>$PATH</code> to be able to
run programs you've gotten through <code>cargo install</code>.</p>
<p>For example, we mentioned in Chapter 12 that there's a Rust implementation of
the <code>grep</code> tool for searching files called <code>ripgrep</code>. If we want to install
<code>ripgrep</code>, we can run:</p>
<pre><code class="language-text">$ cargo install ripgrep
Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading ripgrep v0.3.2
 ...snip...
   Compiling ripgrep v0.3.2
    Finished release [optimized + debuginfo] target(s) in 97.91 secs
  Installing ~/.cargo/bin/rg
</code></pre>
<p>The last line of the output shows the location and the name of the installed
binary, which in the case of <code>ripgrep</code> is named <code>rg</code>. As long as the
installation directory is in our <code>$PATH</code> as mentioned above, we can then run
<code>rg --help</code> and start using a faster, rustier tool for searching files!</p>
<a class="header" href="print.html#extending-cargo-with-custom-commands" id="extending-cargo-with-custom-commands"><h2>Extending Cargo with Custom Commands</h2></a>
<p>Cargo is designed to be extensible with new subcommands without having to
modify Cargo itself. If a binary in your <code>$PATH</code> is named <code>cargo-something</code>,
you can run it as if it were a Cargo subcommand by running <code>cargo something</code>.
Custom commands like this are also listed when you run <code>cargo --list</code>. It's
convenient to <code>cargo install</code> extensions to Cargo then be able to run them just
like the built-in Cargo tools!</p>
<a class="header" href="print.html#summary-6" id="summary-6"><h2>Summary</h2></a>
<p>Sharing code with Cargo and crates.io is part of what makes the Rust ecosystem
useful for many different tasks. Rust's standard library is small and stable,
but crates are easy to share, use, and improve on a different timeline than the
language itself. Don't be shy about sharing code that's useful to you on
crates.io; it's likely that it will be useful to someone else as well!</p>
<a class="header" href="print.html#smart-pointers" id="smart-pointers"><h1>Smart Pointers</h1></a>
<p><em>Pointer</em> is a generic programming term for something that refers to a location
that stores some other data. We learned about Rust's references in Chapter 4;
they're a plain sort of pointer indicated by the <code>&amp;</code> symbol and borrow the
value that they point to. <em>Smart pointers</em> are data structures that act like a
pointer, but also have additional metadata and capabilities, such as reference
counting. The smart pointer pattern originated in C++. In Rust, an additional
difference between plain references and smart pointers is that references are a
kind of pointer that only borrow data; by contrast, in many cases, smart
pointers <em>own</em> the data that they point to.</p>
<p>We've actually already encountered a few smart pointers in this book, even
though we didn't call them that by name at the time. For example, in a certain
sense, <code>String</code> and <code>Vec&lt;T&gt;</code> from Chapter 8 are both smart pointers. They own
some memory and allow you to manipulate it, and have metadata (like their
capacity) and extra capabilities or guarantees (<code>String</code> data will always be
valid UTF-8). The characteristics that distinguish a smart pointer from an
ordinary struct are that smart pointers implement the <code>Deref</code> and <code>Drop</code>
traits, and in this chapter we'll be discussing both of those traits and why
they're important to smart pointers.</p>
<p>Given that the smart pointer pattern is a general design pattern used
frequently in Rust, this chapter won't cover every smart pointer that exists.
Many libraries have their own and you may write some yourself. The ones we
cover here are the most common ones from the standard library:</p>
<ul>
<li><code>Box&lt;T&gt;</code>, for allocating values on the heap</li>
<li><code>Rc&lt;T&gt;</code>, a reference counted type so data can have multiple owners</li>
<li><code>RefCell&lt;T&gt;</code>, which isn't a smart pointer itself, but manages access to the
smart pointers <code>Ref</code> and <code>RefMut</code> to enforce the borrowing rules at runtime
instead of compile time</li>
</ul>
<p>Along the way, we'll also cover:</p>
<ul>
<li>The <em>interior mutability</em> pattern where an immutable type exposes an API for
mutating an interior value, and the borrowing rules apply at runtime instead
of compile time</li>
<li>Reference cycles, how they can leak memory, and how to prevent them</li>
</ul>
<p>Let's dive in!</p>
<a class="header" href="print.html#boxt-points-to-data-on-the-heap-and-has-a-known-size" id="boxt-points-to-data-on-the-heap-and-has-a-known-size"><h2><code>Box&lt;T&gt;</code> Points to Data on the Heap and Has a Known Size</h2></a>
<p>The most straightforward smart pointer is a <em>box</em>, whose type is written
<code>Box&lt;T&gt;</code>. Boxes allow you to put a single value on the heap (we talked about
the stack vs. the heap in Chapter 4). Listing 15-1 shows how to use a box to
store an <code>i32</code> on the heap:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<p><span class="caption">Listing 15-1: Storing an <code>i32</code> value on the heap using a
box</span></p>
<p>This will print <code>b = 5</code>. In this case, we can access the data in the box in a
similar way as we would if this data was on the stack. Just like any value that
has ownership of data, when a box goes out of scope like <code>b</code> does at the end of
<code>main</code>, it will be deallocated. The deallocation happens for both the box
(stored on the stack) and the data it points to (stored on the heap).</p>
<p>Putting a single value on the heap isn't very useful, so you won't use boxes by
themselves in the way that Listing 15-1 does very often. A time when boxes are
useful is when you want to ensure that your type has a known size. For example,
consider Listing 15-2, which contains an enum definition for a <em>cons list</em>, a
type of data structure that comes from functional programming. Note that this
won't compile quite yet:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, List),
    Nil,
}
</code></pre>
<p><span class="caption">Listing 15-2: The first attempt of defining an enum to
represent a cons list data structure of <code>i32</code> values</span></p>
<p>We're implementing a cons list that holds only <code>i32</code> values. We
could have also chosen to implement a cons list independent of the
type of value by using generics as discussed in Chapter 10.</p>
<blockquote>
<a class="header" href="print.html#more-information-about-the-cons-list" id="more-information-about-the-cons-list"><h4>More Information About the Cons List</h4></a>
<p>A <em>cons list</em> is a data structure that comes from the Lisp programming
language and its dialects. In Lisp, the <code>cons</code> function (short for &quot;construct
function&quot;) constructs a new list from its two arguments, which usually are a
single value and another list.</p>
<p>The cons function concept has made its way into more general functional
programming jargon; &quot;to cons x onto y&quot; informally means to construct a new
container instance by putting the element x at the start of this new
container, followed by the container y.</p>
<p>A cons list is produced by recursively calling the <code>cons</code> function.
The canonical name to denote the base case of the recursion is <code>Nil</code>, which
announces the end of the list. Note that this is not the same as the &quot;null&quot;
or &quot;nil&quot; concept from Chapter 6, which is an invalid or absent value.</p>
</blockquote>
<p>A cons list is a list where each element contains both a single value as well
as the remains of the list at that point. The remains of the list are defined
by nested cons lists. The end of the list is signified by the value <code>Nil</code>. Cons
lists aren't used very often in Rust; <code>Vec&lt;T&gt;</code> is usually a better choice.
Implementing this data structure is a good example of a situation where
<code>Box&lt;T&gt;</code> is useful, though. Let's find out why!</p>
<p>Using a cons list to store the list <code>1, 2, 3</code> would look like this:</p>
<pre><code class="language-rust ignore">use List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<p>The first <code>Cons</code> value holds <code>1</code> and another <code>List</code> value. This <code>List</code>
value is another <code>Cons</code> value that holds <code>2</code> and another <code>List</code> value. This
is one more <code>Cons</code> value that holds <code>3</code> and a <code>List</code> value, which is finally
<code>Nil</code>, the non-recursive variant that signals the end of the list.</p>
<p>If we try to compile the above code, we get the error shown in Listing 15-3:</p>
<pre><code class="language-text">error[E0072]: recursive type `List` has infinite size
 --&gt;
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |     --------------- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
  make `List` representable
</code></pre>
<p><span class="caption">Listing 15-3: The error we get when attempting to define
a recursive enum</span></p>
<p>The error says this type 'has infinite size'. Why is that? It's because we've
defined <code>List</code> to have a variant that is recursive: it holds another value of
itself. This means Rust can't figure out how much space it needs in order to
store a <code>List</code> value. Let's break this down a bit: first let's look at how Rust
decides how much space it needs to store a value of a non-recursive type.
Recall the <code>Message</code> enum we defined in Listing 6-2 when we discussed enum
definitions in Chapter 6:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#}</code></pre></pre>
<p>When Rust needs to know how much space to allocate for a <code>Message</code> value, it
can go through each of the variants and see that <code>Message::Quit</code> does not need
any space, <code>Message::Move</code> needs enough space to store two <code>i32</code> values, and so
forth. Therefore, the most space a <code>Message</code> value will need is the space it
would take to store the largest of its variants.</p>
<p>Contrast this to what happens when the Rust compiler looks at a recursive type
like <code>List</code> in Listing 15-2. The compiler tries to figure out how much memory
is needed to store a value of the <code>List</code> enum, and starts by looking at the <code>Cons</code>
variant. The <code>Cons</code> variant holds a value of type <code>i32</code> and a value of type
<code>List</code>, so <code>Cons</code> needs an amount of space equal to the size of an <code>i32</code> plus
the size of a <code>List</code>. To figure out how much memory a <code>List</code> needs, it looks at
its variants, starting with the <code>Cons</code> variant. The <code>Cons</code> variant holds a
value of type <code>i32</code> and a value of type <code>List</code>, and this continues infinitely,
as shown in Figure 15-4.</p>
<p><img alt="An infinite Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 15-4: An infinite <code>List</code> consisting of infinite
<code>Cons</code> variants</span></p>
<p>Rust can't figure out how much space to allocate for recursively defined types,
so the compiler gives the error in Listing 15-3. The error did include this
helpful suggestion:</p>
<pre><code class="language-text">= help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
        make `List` representable
</code></pre>
<p>Because a <code>Box&lt;T&gt;</code> is a pointer, we always know how much space it needs: a
pointer takes up a <code>usize</code> amount of space. The value of the <code>usize</code> will be
the address of the heap data. The heap data can be any size, but the address to
the start of that heap data will always fit in a <code>usize</code>. So if we change our
definition from Listing 15-2 to look like the definition here in Listing 15-5,
and change <code>main</code> to use <code>Box::new</code> for the values inside the <code>Cons</code> variants
like so:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
</code></pre></pre>
<p><span class="caption">Listing 15-5: Definition of <code>List</code> that uses <code>Box&lt;T&gt;</code> in
order to have a known size</span></p>
<p>The compiler will be able to figure out the size it needs to store a <code>List</code>
value. Rust will look at <code>List</code>, and again start by looking at the <code>Cons</code>
variant. The <code>Cons</code> variant will need the size of <code>i32</code> plus the space to store
a <code>usize</code>, since a box always has the size of a <code>usize</code>, no matter what it's
pointing to. Then Rust looks at the <code>Nil</code> variant, which does not store a
value, so <code>Nil</code> doesn't need any space. We've broken the infinite, recursive
chain by adding in a box. Figure 15-6 shows what the <code>Cons</code> variant looks like
now:</p>
<p><img alt="A finite Cons list" src="img/trpl15-02.svg" class="center" /></p>
<p><span class="caption">Figure 15-6: A <code>List</code> that is not infinitely sized since
<code>Cons</code> holds a <code>Box</code></span></p>
<p>This is the main area where boxes are useful: breaking up an infinite data
structure so that the compiler can know what size it is. We'll look at another
case where Rust has data of unknown size in Chapter 17 when we discuss trait
objects.</p>
<p>Even though you won't be using boxes very often, they are a good way to
understand the smart pointer pattern. Two of the aspects of <code>Box&lt;T&gt;</code> that are
commonly used with smart pointers are its implementations of the <code>Deref</code> trait
and the <code>Drop</code> trait. Let's investigate how these traits work and how smart
pointers use them.</p>
<a class="header" href="print.html#the-deref-trait-allows-access-to-the-data-through-a-reference" id="the-deref-trait-allows-access-to-the-data-through-a-reference"><h2>The <code>Deref</code> Trait Allows Access to the Data Through a Reference</h2></a>
<p>The first important smart pointer-related trait is <code>Deref</code>, which allows us to
override <code>*</code>, the dereference operator (as opposed to the multiplication
operator or the glob operator). Overriding <code>*</code> for smart pointers makes
accessing the data behind the smart pointer convenient, and we'll talk about
what we mean by convenient when we get to deref coercions later in this section.</p>
<p>We briefly mentioned the dereference operator in Chapter 8, in the hash map
section titled &quot;Update a Value Based on the Old Value&quot;. We had a mutable
reference, and we wanted to change the value that the reference was pointing
to. In order to do that, first we had to dereference the reference. Here's
another example using references to <code>i32</code> values:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 5;
{
    let y = &amp;mut x;

    *y += 1
}

assert_eq!(6, x);
#}</code></pre></pre>
<p>We use <code>*y</code> to access the data that the mutable reference in <code>y</code> refers to,
rather than the mutable reference itself. We can then modify that data, in this
case by adding 1.</p>
<p>With references that aren't smart pointers, there's only one value that the
reference is pointing to, so the dereference operation is straightforward.
Smart pointers can also store metadata about the pointer or the data. When
dereferencing a smart pointer, we only want the data, not the metadata, since
dereferencing a regular reference only gives us data and not metadata. We want
to be able to use smart pointers in the same places that we can use regular
references. To enable that, we can override the behavior of the <code>*</code> operator by
implementing the <code>Deref</code> trait.</p>
<p>Listing 15-7 has an example of overriding <code>*</code> using <code>Deref</code> on a struct we've
defined to hold mp3 data and metadata. <code>Mp3</code> is, in a sense, a smart pointer:
it owns the <code>Vec&lt;u8&gt;</code> data containing the audio. In addition, it holds some
optional metadata, in this case the artist and title of the song in the audio
data. We want to be able to conveniently access the audio data, not the
metadata, so we implement the <code>Deref</code> trait to return the audio data.
Implementing the <code>Deref</code> trait requires implementing one method named <code>deref</code>
that borrows <code>self</code> and returns the inner data:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::Deref;

struct Mp3 {
    audio: Vec&lt;u8&gt;,
    artist: Option&lt;String&gt;,
    title: Option&lt;String&gt;,
}

impl Deref for Mp3 {
    type Target = Vec&lt;u8&gt;;

    fn deref(&amp;self) -&gt; &amp;Vec&lt;u8&gt; {
        &amp;self.audio
    }
}

fn main() {
    let my_favorite_song = Mp3 {
        // we would read the actual audio data from an mp3 file
        audio: vec![1, 2, 3],
        artist: Some(String::from(&quot;Nirvana&quot;)),
        title: Some(String::from(&quot;Smells Like Teen Spirit&quot;)),
    };

    assert_eq!(vec![1, 2, 3], *my_favorite_song);
}
</code></pre></pre>
<p><span class="caption">Listing 15-7: An implementation of the <code>Deref</code> trait on a
struct that holds mp3 file data and metadata</span></p>
<p>Most of this should look familiar: a struct, a trait implementation, and a
main function that creates an instance of the struct. There is one part we
haven't explained thoroughly yet: similarly to Chapter 13 when we looked at the
Iterator trait with the <code>type Item</code>, the <code>type Target = T;</code> syntax is defining
an associated type, which is covered in more detail in Chapter 19. Don't worry
about that part of the example too much; it is a slightly different way of
declaring a generic parameter.</p>
<p>In the <code>assert_eq!</code>, we're verifying that <code>vec![1, 2, 3]</code> is the result we get
when dereferencing the <code>Mp3</code> instance with <code>*my_favorite_song</code>, which is what
happens since we implemented the <code>deref</code> method to return the audio data. If
we hadn't implemented the <code>Deref</code> trait for <code>Mp3</code>, Rust wouldn't compile the
code <code>*my_favorite_song</code>: we'd get an error saying type <code>Mp3</code> cannot be
dereferenced.</p>
<p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&amp;</code> references,
which <code>my_favorite_song</code> is not (it is an <code>Mp3</code> struct). With the <code>Deref</code>
trait, the compiler knows that types implementing the <code>Deref</code> trait have a
<code>deref</code> method that returns a reference (in this case, <code>&amp;self.audio</code> because of
our definition of <code>deref</code> in Listing 15-7). So in order to get a <code>&amp;</code> reference
that <code>*</code> can dereference, the compiler expands <code>*my_favorite_song</code> to this:</p>
<pre><code class="language-rust ignore">*(my_favorite_song.deref())
</code></pre>
<p>The result is the value in <code>self.audio</code>. The reason <code>deref</code> returns a reference
that we then have to dereference, rather than just returning a value directly,
is because of ownership: if the <code>deref</code> method directly returned the value
instead of a reference to it, the value would be moved out of <code>self</code>. We don't
want to take ownership of <code>my_favorite_song.audio</code> in this case and most cases
where we use the dereference operator.</p>
<p>Note that replacing <code>*</code> with a call to the <code>deref</code> method and then a call to
<code>*</code> happens once, each time the <code>*</code> is used. The substitution of <code>*</code> does not
recurse infinitely. That's how we end up with data of type <code>Vec&lt;u8&gt;</code>, which
matches the <code>vec![1, 2, 3]</code> in the <code>assert_eq!</code> in Listing 15-7.</p>
<a class="header" href="print.html#implicit-deref-coercions-with-functions-and-methods" id="implicit-deref-coercions-with-functions-and-methods"><h3>Implicit Deref Coercions with Functions and Methods</h3></a>
<p>Rust tends to favor explicitness over implicitness, but one case where this
does not hold true is <em>deref coercions</em> of arguments to functions and methods.
A deref coercion will automatically convert a reference to any pointer into a
reference to that pointer's contents. A deref coercion happens when the
reference type of the argument passed into the function differs from the
reference type of the parameter defined in that function's signature. Deref
coercion was added to Rust to make calling functions and methods not need as
many explicit references and dereferences with <code>&amp;</code> and <code>*</code>.</p>
<p>Using our <code>Mp3</code> struct from Listing 15-7, here's the signature of a function to
compress mp3 audio data that takes a slice of <code>u8</code>:</p>
<pre><code class="language-rust ignore">fn compress_mp3(audio: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    // the actual implementation would go here
}
</code></pre>
<p>If Rust didn't have deref coercion, in order to call this function with the
audio data in <code>my_favorite_song</code>, we'd have to write:</p>
<pre><code class="language-rust ignore">compress_mp3(my_favorite_song.audio.as_slice())
</code></pre>
<p>That is, we'd have to explicitly say that we want the data in the <code>audio</code> field
of <code>my_favorite_song</code> and that we want a slice referring to the whole
<code>Vec&lt;u8&gt;</code>. If there were a lot of places where we'd want to process the <code>audio</code>
data in a similar manner, <code>.audio.as_slice()</code> would be wordy and repetitive.</p>
<p>However, because of deref coercion and our implementation of the <code>Deref</code> trait
on <code>Mp3</code>, we can call this function with the data in <code>my_favorite_song</code> by
using this code:</p>
<pre><code class="language-rust ignore">let result = compress_mp3(&amp;my_favorite_song);
</code></pre>
<p>Just an <code>&amp;</code> and the instance, nice! We can treat our smart pointer as if it was
a regular reference. Deref coercion means that Rust can use its knowledge of
our <code>Deref</code> implementation, namely: Rust knows that <code>Mp3</code> implements the
<code>Deref</code> trait and returns <code>&amp;Vec&lt;u8&gt;</code> from the <code>deref</code> method. Rust also knows
the standard library implements the <code>Deref</code> trait on <code>Vec&lt;T&gt;</code> to return <code>&amp;[T]</code>
from the <code>deref</code> method (and we can find that out too by looking at the API
documentation for <code>Vec&lt;T&gt;</code>). So, at compile time, Rust will see that it can use
<code>Deref::deref</code> twice to turn <code>&amp;Mp3</code> into <code>&amp;Vec&lt;u8&gt;</code> and then into <code>&amp;[T]</code> to
match the signature of <code>compress_mp3</code>. That means we get to do less typing!
Rust will analyze types through <code>Deref::deref</code> as many times as it needs to in
order to get a reference to match the parameter's type, when the <code>Deref</code> trait
is defined for the types involved. This indirection is resolved at compile time,
so there is no run-time penalty for taking advantage of deref coercion!</p>
<p>Similar to how we use the <code>Deref</code> trait to override <code>*</code> on <code>&amp;T</code>s, there is also
a <code>DerefMut</code> trait for overriding <code>*</code> on <code>&amp;mut T</code>.</p>
<p>Rust does deref coercion when it finds types and trait implementations in three
cases:</p>
<ul>
<li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code>.</li>
<li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code>.</li>
<li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code>.</li>
</ul>
<p>The first two are the same, except for mutability: if you have a <code>&amp;T</code>, and
<code>T</code> implements <code>Deref</code> to some type <code>U</code>, you can get a <code>&amp;U</code> transparently. Same
for mutable references. The last one is more tricky: if you have a mutable
reference, it will also coerce to an immutable one. The other case is <em>not</em>
possible though: immutable references will never coerce to mutable ones.</p>
<p>The reason that the <code>Deref</code> trait is important to the smart pointer pattern is
that smart pointers can then be treated like regular references and used in
places that expect regular references. We don't have to redefine methods and
functions to take smart pointers explicitly, for example.</p>
<a class="header" href="print.html#the-drop-trait-runs-code-on-cleanup" id="the-drop-trait-runs-code-on-cleanup"><h2>The <code>Drop</code> Trait Runs Code on Cleanup</h2></a>
<p>The other trait that's important to the smart pointer pattern is the <code>Drop</code>
trait. <code>Drop</code> lets us run some code when a value is about to go out of scope.
Smart pointers perform important cleanup when being dropped, like deallocating
memory or decrementing a reference count. More generally, data types can manage
resources beyond memory, like files or network connections, and use <code>Drop</code> to
release those resources when our code is done with them. We're discussing
<code>Drop</code> in the context of smart pointers, though, because the functionality of
the <code>Drop</code> trait is almost always used when implementing smart pointers.</p>
<p>In some other languages, we have to remember to call code to free the memory or
resource every time we finish using an instance of a smart pointer. If we
forget, the system our code is running on might get overloaded and crash. In
Rust, we can specify that some code should be run when a value goes out of
scope, and the compiler will insert this code automatically. That means we don't
need to remember to put this code everywhere we're done with an instance of
these types, but we still won't leak resources!</p>
<p>The way we specify code should be run when a value goes out of scope is by
implementing the <code>Drop</code> trait. The <code>Drop</code> trait requires us to implement one
method named <code>drop</code> that takes a mutable reference to <code>self</code>.</p>
<p>Listing 15-8 shows a <code>CustomSmartPointer</code> struct that doesn't actually do
anything, but we're printing out <code>CustomSmartPointer created.</code> right after we
create an instance of the struct and <code>Dropping CustomSmartPointer!</code> when the
instance goes out of scope so that we can see when each piece of code gets run.
Instead of a <code>println!</code> statement, you'd fill in <code>drop</code> with whatever cleanup
code your smart pointer needs to run:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping CustomSmartPointer!&quot;);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;some data&quot;) };
    println!(&quot;CustomSmartPointer created.&quot;);
    println!(&quot;Wait for it...&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 15-8: A <code>CustomSmartPointer</code> struct that
implements the <code>Drop</code> trait, where we could put code that would clean up after
the <code>CustomSmartPointer</code>.</span></p>
<p>The <code>Drop</code> trait is in the prelude, so we don't need to import it. The <code>drop</code>
method implementation calls the <code>println!</code>; this is where you'd put the actual
code needed to close the socket. In <code>main</code>, we create a new instance of
<code>CustomSmartPointer</code> then print out <code>CustomSmartPointer created.</code> to be able to
see that our code got to that point at runtime. At the end of <code>main</code>, our
instance of <code>CustomSmartPointer</code> will go out of scope. Note that we didn't call
the <code>drop</code> method explicitly.</p>
<p>When we run this program, we'll see:</p>
<pre><code class="language-text">CustomSmartPointer created.
Wait for it...
Dropping CustomSmartPointer!
</code></pre>
<p>printed to the screen, which shows that Rust automatically called <code>drop</code> for us
when our instance went out of scope.</p>
<p>We can use the <code>std::mem::drop</code> function to drop a value earlier than when it
goes out of scope. This isn't usually necessary; the whole point of the <code>Drop</code>
trait is that it's taken care of automatically for us. We'll see an example of
a case when we'll need to drop a value earlier than when it goes out of scope
in Chapter 16 when we're talking about concurrency. For now, let's just see
that it's possible, and <code>std::mem::drop</code> is in the prelude so we can just call
<code>drop</code> as shown in Listing 15-9:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;some data&quot;) };
    println!(&quot;CustomSmartPointer created.&quot;);
    drop(c);
    println!(&quot;Wait for it...&quot;);
}
</code></pre>
<p><span class="caption">Listing 15-9: Calling <code>std::mem::drop</code> to explicitly drop
a value before it goes out of scope</span></p>
<p>Running this code will print the following, showing that the destructor code is
called since <code>Dropping CustomSmartPointer!</code> is printed between
<code>CustomSmartPointer created.</code> and <code>Wait for it...</code>:</p>
<pre><code class="language-text">CustomSmartPointer created.
Dropping CustomSmartPointer!
Wait for it...
</code></pre>
<p>Note that we aren't allowed to call the <code>drop</code> method that we defined directly:
if we replaced <code>drop(c)</code> in Listing 15-9 with <code>c.drop()</code>, we'll get a compiler
error that says <code>explicit destructor calls not allowed</code>. We're not allowed to
call <code>Drop::drop</code> directly because when Rust inserts its call to <code>Drop::drop</code>
automatically when the value goes out of scope, then the value would get
dropped twice. Dropping a value twice could cause an error or corrupt memory,
so Rust doesn't let us. Instead, we can use <code>std::mem::drop</code>, whose definition
is:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod std {
    pub mod mem {
        pub fn drop&lt;T&gt;(x: T) { }
    }
}
#}</code></pre></pre>
<p>This function is generic over any type <code>T</code>, so we can pass any value to it. The
function doesn't actually have anything in its body, so it doesn't use its
parameter. The reason this empty function is useful is that <code>drop</code> takes
ownership of its parameter, which means the value in <code>x</code> gets dropped at the
end of this function when <code>x</code> goes out of scope.</p>
<p>Code specified in a <code>Drop</code> trait implementation can be used for many reasons to
make cleanup convenient and safe: we could use it to create our own memory
allocator, for instance! By using the <code>Drop</code> trait and Rust's ownership system,
we don't have to remember to clean up after ourselves since Rust takes care of
it automatically. We'll get compiler errors if we write code that would clean
up a value that's still in use, since the ownership system that makes sure
references are always valid will also make sure that <code>drop</code> only gets called
one time when the value is no longer being used.</p>
<p>Now that we've gone over <code>Box&lt;T&gt;</code> and some of the characteristics of smart
pointers, let's talk about a few other smart pointers defined in the standard
library that add different kinds of useful functionality.</p>
<a class="header" href="print.html#rct-the-reference-counted-smart-pointer" id="rct-the-reference-counted-smart-pointer"><h2><code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer</h2></a>
<p>In the majority of cases, ownership is very clear: you know exactly which
variable owns a given value. However, this isn't always the case; sometimes,
you may actually need multiple owners. For this, Rust has a type called
<code>Rc&lt;T&gt;</code>. Its name is an abbreviation for <em>reference counting</em>. Reference
counting means keeping track of the number of references to a value in order to
know if a value is still in use or not. If there are zero references to a
value, we know we can clean up the value without any references becoming
invalid.</p>
<p>To think about this in terms of a real-world scenario, it's like a TV in a
family room. When one person comes in the room to watch TV, they turn it on.
Others can also come in the room and watch the TV. When the last person leaves
the room, they'll turn the TV off since it's no longer being used. If someone
turns off the TV while others are still watching it, though, the people
watching the TV would get mad!</p>
<p><code>Rc&lt;T&gt;</code> is for use when we want to allocate some data on the heap for multiple
parts of our program to read, and we can't determine at compile time which part
of our program using this data will finish using it last. If we knew which part
would finish last, we could make that part the owner of the data and the normal
ownership rules enforced at compile time would kick in.</p>
<p>Note that <code>Rc&lt;T&gt;</code> is only for use in single-threaded scenarios; the next
chapter on concurrency will cover how to do reference counting in
multithreaded programs. If you try to use <code>Rc&lt;T&gt;</code> with multiple threads,
you'll get a compile-time error.</p>
<a class="header" href="print.html#using-rct-to-share-data" id="using-rct-to-share-data"><h3>Using <code>Rc&lt;T&gt;</code> to Share Data</h3></a>
<p>Let's return to our cons list example from Listing 15-5. In Listing 15-11, we're
going to try to use <code>List</code> as we defined it using <code>Box&lt;T&gt;</code>. First we'll create
one list instance that contains 5 and then 10. Next, we want to create two more
lists: one that starts with 3 and continues on to our first list containing 5
and 10, then another list that starts with 4 and <em>also</em> continues on to our
first list containing 5 and 10. In other words, we want two lists that both
share ownership of the third list, which conceptually will be something like
Figure 15-10:</p>
<p><img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" /></p>
<p><span class="caption">Figure 15-10: Two lists, <code>b</code> and <code>c</code>, sharing ownership
of a third list, <code>a</code></span></p>
<p>Trying to implement this using our definition of <code>List</code> with <code>Box&lt;T&gt;</code> won't
work, as shown in Listing 15-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<p><span class="caption">Listing 15-11: Having two lists using <code>Box&lt;T&gt;</code> that try
to share ownership of a third list won't work</span></p>
<p>If we compile this, we get this error:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not
   implement the `Copy` trait
</code></pre>
<p>The <code>Cons</code> variants own the data they hold, so when we create the <code>b</code> list it
moves <code>a</code> to be owned by <code>b</code>. Then when we try to use <code>a</code> again when creating
<code>c</code>, we're not allowed to since <code>a</code> has been moved.</p>
<p>We could change the definition of <code>Cons</code> to hold references instead, but then
we'd have to specify lifetime parameters and we'd have to construct elements of
a list such that every element lives at least as long as the list itself.
Otherwise, the borrow checker won't even let us compile the code.</p>
<p>Instead, we can change our definition of <code>List</code> to use <code>Rc&lt;T&gt;</code> instead of
<code>Box&lt;T&gt;</code> as shown here in Listing 15-12:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, a.clone());
    let c = Cons(4, a.clone());
}
</code></pre></pre>
<p><span class="caption">Listing 15-12: A definition of <code>List</code> that uses
<code>Rc&lt;T&gt;</code></span></p>
<p>Note that we need to add a <code>use</code> statement for <code>Rc</code> because it's not in the
prelude. In <code>main</code>, we create the list holding 5 and 10 and store it in a new
<code>Rc</code> in <code>a</code>. Then when we create <code>b</code> and <code>c</code>, we call the <code>clone</code> method on <code>a</code>.</p>
<a class="header" href="print.html#cloning-an-rct-increases-the-reference-count" id="cloning-an-rct-increases-the-reference-count"><h3>Cloning an <code>Rc&lt;T&gt;</code> Increases the Reference Count</h3></a>
<p>We've seen the <code>clone</code> method previously, where we used it for making a
complete copy of some data. With <code>Rc&lt;T&gt;</code>, though, it doesn't make a full copy.
<code>Rc&lt;T&gt;</code> holds a <em>reference count</em>, that is, a count of how many clones exist.
Let's change <code>main</code> as shown in Listing 15-13 to have an inner scope around
where we create <code>c</code>, and to print out the results of the <code>Rc::strong_count</code>
associated function at various points. <code>Rc::strong_count</code> returns the reference
count of the <code>Rc</code> value we pass to it, and we'll talk about why this function
is named <code>strong_count</code> in the section later in this chapter about preventing
reference cycles.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># enum List {
#     Cons(i32, Rc&lt;List&gt;),
#     Nil,
# }
#
# use List::{Cons, Nil};
# use std::rc::Rc;
#
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;rc = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, a.clone());
    println!(&quot;rc after creating b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, a.clone());
        println!(&quot;rc after creating c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;rc after c goes out of scope = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Listing 15-13: Printing out the reference count</span></p>
<p>This will print out:</p>
<pre><code class="language-text">rc = 1
rc after creating b = 2
rc after creating c = 3
rc after c goes out of scope = 2
</code></pre>
<p>We're able to see that <code>a</code> has an initial reference count of one. Then each
time we call <code>clone</code>, the count goes up by one. When <code>c</code> goes out of scope, the
count is decreased by one, which happens in the implementation of the <code>Drop</code>
trait for <code>Rc&lt;T&gt;</code>. What we can't see in this example is that when <code>b</code> and then
<code>a</code> go out of scope at the end of <code>main</code>, the count of references to the list
containing 5 and 10 is then 0, and the list is dropped. This strategy lets us
have multiple owners, as the count will ensure that the value remains valid as
long as any of the owners still exist.</p>
<p>In the beginning of this section, we said that <code>Rc&lt;T&gt;</code> only allows you to share
data for multiple parts of your program to read through immutable references to
the <code>T</code> value the <code>Rc&lt;T&gt;</code> contains. If <code>Rc&lt;T&gt;</code> let us have a mutable reference,
we'd run into the problem that the borrowing rules disallow that we discussed
in Chapter 4: two mutable borrows to the same place can cause data races and
inconsistencies. But mutating data is very useful! In the next section, we'll
discuss the interior mutability pattern and the <code>RefCell&lt;T&gt;</code> type that we can
use in conjunction with an <code>Rc&lt;T&gt;</code> to work with this restriction on
immutability.</p>
<a class="header" href="print.html#refcellt-and-the-interior-mutability-pattern" id="refcellt-and-the-interior-mutability-pattern"><h2><code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</h2></a>
<p><em>Interior mutability</em> is a design pattern in Rust for allowing you to mutate
data even though there are immutable references to that data, which would
normally be disallowed by the borrowing rules. The interior mutability pattern
involves using <code>unsafe</code> code inside a data structure to bend Rust's usual rules
around mutation and borrowing. We haven't yet covered unsafe code; we will in
Chapter 19. The interior mutability pattern is used when you can ensure that
the borrowing rules will be followed at runtime, even though the compiler can't
ensure that. The <code>unsafe</code> code involved is then wrapped in a safe API, and the
outer type is still immutable.</p>
<p>Let's explore this by looking at the <code>RefCell&lt;T&gt;</code> type that follows the
interior mutability pattern.</p>
<a class="header" href="print.html#refcellt-has-interior-mutability" id="refcellt-has-interior-mutability"><h3><code>RefCell&lt;T&gt;</code> has Interior Mutability</h3></a>
<p>Unlike <code>Rc&lt;T&gt;</code>, the <code>RefCell&lt;T&gt;</code> type represents single ownership over the data
that it holds. So, what makes <code>RefCell&lt;T&gt;</code> different than a type like <code>Box&lt;T&gt;</code>?
Let's recall the borrowing rules we learned in Chapter 4:</p>
<ol>
<li>At any given time, you can have <em>either</em> but not both of:</li>
</ol>
<ul>
<li>One mutable reference.</li>
<li>Any number of immutable references.</li>
</ul>
<ol start="2">
<li>References must always be valid.</li>
</ol>
<p>With references and <code>Box&lt;T&gt;</code>, the borrowing rules' invariants are enforced at
compile time. With <code>RefCell&lt;T&gt;</code>, these invariants are enforced <em>at runtime</em>.
With references, if you break these rules, you'll get a compiler error. With
<code>RefCell&lt;T&gt;</code>, if you break these rules, you'll get a <code>panic!</code>.</p>
<p>Static analysis, like the Rust compiler performs, is inherently conservative.
There are properties of code that are impossible to detect by analyzing the
code: the most famous is the Halting Problem, which is out of scope of this
book but an interesting topic to research if you're interested.</p>
<p>Because some analysis is impossible, the Rust compiler does not try to even
guess if it can't be sure, so it's conservative and sometimes rejects correct
programs that would not actually violate Rust's guarantees. Put another way, if
Rust accepts an incorrect program, people would not be able to trust in the
guarantees Rust makes. If Rust rejects a correct program, the programmer will
be inconvenienced, but nothing catastrophic can occur. <code>RefCell&lt;T&gt;</code> is useful
when you know that the borrowing rules are respected, but the compiler can't
understand that that's true.</p>
<p>Similarly to <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> is only for use in single-threaded
scenarios. We'll talk about how to get the functionality of <code>RefCell&lt;T&gt;</code> in a
multithreaded program in the next chapter on concurrency. For now, all you
need to know is that if you try to use <code>RefCell&lt;T&gt;</code> in a multithreaded
context, you'll get a compile time error.</p>
<p>With references, we use the <code>&amp;</code> and <code>&amp;mut</code> syntax to create references and
mutable references, respectively. But with <code>RefCell&lt;T&gt;</code>, we use the <code>borrow</code>
and <code>borrow_mut</code> methods, which are part of the safe API that <code>RefCell&lt;T&gt;</code> has.
<code>borrow</code> returns the smart pointer type <code>Ref</code>, and <code>borrow_mut</code> returns the
smart pointer type <code>RefMut</code>. These two types implement <code>Deref</code> so that we can
treat them as if they're regular references. <code>Ref</code> and <code>RefMut</code> track the
borrows dynamically, and their implementation of <code>Drop</code> releases the borrow
dynamically.</p>
<p>Listing 15-14 shows what it looks like to use <code>RefCell&lt;T&gt;</code> with functions that
borrow their parameters immutably and mutably. Note that the <code>data</code> variable is
declared as immutable with <code>let data</code> rather than <code>let mut data</code>, yet
<code>a_fn_that_mutably_borrows</code> is allowed to borrow the data mutably and make
changes to the data!</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::cell::RefCell;

fn a_fn_that_immutably_borrows(a: &amp;i32) {
    println!(&quot;a is {}&quot;, a);
}

fn a_fn_that_mutably_borrows(b: &amp;mut i32) {
    *b += 1;
}

fn demo(r: &amp;RefCell&lt;i32&gt;) {
    a_fn_that_immutably_borrows(&amp;r.borrow());
    a_fn_that_mutably_borrows(&amp;mut r.borrow_mut());
    a_fn_that_immutably_borrows(&amp;r.borrow());
}

fn main() {
    let data = RefCell::new(5);
    demo(&amp;data);
}
</code></pre></pre>
<p><span class="caption">Listing 15-14: Using <code>RefCell&lt;T&gt;</code>, <code>borrow</code>, and
<code>borrow_mut</code></span></p>
<p>This example prints:</p>
<pre><code class="language-text">a is 5
a is 6
</code></pre>
<p>In <code>main</code>, we've created a new <code>RefCell&lt;T&gt;</code> containing the value 5, and stored
in the variable <code>data</code>, declared without the <code>mut</code> keyword. We then call the
<code>demo</code> function with an immutable reference to <code>data</code>: as far as <code>main</code> is
concerned, <code>data</code> is immutable!</p>
<p>In the <code>demo</code> function, we get an immutable reference to the value inside the
<code>RefCell&lt;T&gt;</code> by calling the <code>borrow</code> method, and we call
<code>a_fn_that_immutably_borrows</code> with that immutable reference. More
interestingly, we can get a <em>mutable</em> reference to the value inside the
<code>RefCell&lt;T&gt;</code> with the <code>borrow_mut</code> method, and the function
<code>a_fn_that_mutably_borrows</code> is allowed to change the value. We can see that the
next time we call <code>a_fn_that_immutably_borrows</code> that prints out the value, it's
6 instead of 5.</p>
<a class="header" href="print.html#borrowing-rules-are-checked-at-runtime-on-refcellt" id="borrowing-rules-are-checked-at-runtime-on-refcellt"><h3>Borrowing Rules are Checked at Runtime on <code>RefCell&lt;T&gt;</code></h3></a>
<p>Recall from Chapter 4 that because of the borrowing rules, this code using
regular references that tries to create two mutable borrows in the same scope
won't compile:</p>
<pre><code class="language-rust ignore">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;
</code></pre>
<p>We'll get this compiler error:</p>
<pre><code class="language-text">error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt;
  |
5 |     let r1 = &amp;mut s;
  |                   - first mutable borrow occurs here
6 |     let r2 = &amp;mut s;
  |                   ^ second mutable borrow occurs here
7 | }
  | - first borrow ends here
</code></pre>
<p>In contrast, using <code>RefCell&lt;T&gt;</code> and calling <code>borrow_mut</code> twice in the same
scope <em>will</em> compile, but it'll panic at runtime instead. This code:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::cell::RefCell;

fn main() {
    let s = RefCell::new(String::from(&quot;hello&quot;));

    let r1 = s.borrow_mut();
    let r2 = s.borrow_mut();
}
</code></pre></pre>
<p>compiles but panics with the following error when we <code>cargo run</code>:</p>
<pre><code class="language-text">    Finished dev [unoptimized + debuginfo] target(s) in 0.83 secs
     Running `target/debug/refcell`
thread 'main' panicked at 'already borrowed: BorrowMutError',
/stable-dist-rustc/build/src/libcore/result.rs:868
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>This runtime <code>BorrowMutError</code> is similar to the compiler error: it says we've
already borrowed <code>s</code> mutably once, so we're not allowed to borrow it again. We
aren't getting around the borrowing rules, we're just choosing to have Rust
enforce them at runtime instead of compile time. You could choose to use
<code>RefCell&lt;T&gt;</code> everywhere all the time, but in addition to having to type
<code>RefCell</code> a lot, you'd find out about possible problems later (possibly in
production rather than during development). Also, checking the borrowing rules
while your program is running has a performance penalty.</p>
<a class="header" href="print.html#multiple-owners-of-mutable-data-by-combining-rct-and-refcellt" id="multiple-owners-of-mutable-data-by-combining-rct-and-refcellt"><h3>Multiple Owners of Mutable Data by Combining <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code></h3></a>
<p>So why would we choose to make the tradeoffs that using <code>RefCell&lt;T&gt;</code> involves?
Well, remember when we said that <code>Rc&lt;T&gt;</code> only lets you have an immutable
reference to <code>T</code>? Given that <code>RefCell&lt;T&gt;</code> is immutable, but has interior
mutability, we can combine <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> to get a type that's both
reference counted and mutable. Listing 15-15 shows an example of how to do
that, again going back to our cons list from Listing 15-5. In this example,
instead of storing <code>i32</code> values in the cons list, we'll be storing
<code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> values. We want to store that type so that we can have an
owner of the value that's not part of the list (the multiple owners
functionality that <code>Rc&lt;T&gt;</code> provides), and so we can mutate the inner <code>i32</code>
value (the interior mutability functionality that <code>RefCell&lt;T&gt;</code> provides):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Cons(value.clone(), Rc::new(Nil));
    let shared_list = Rc::new(a);

    let b = Cons(Rc::new(RefCell::new(6)), shared_list.clone());
    let c = Cons(Rc::new(RefCell::new(10)), shared_list.clone());

    *value.borrow_mut() += 10;

    println!(&quot;shared_list after = {:?}&quot;, shared_list);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}
</code></pre></pre>
<p><span class="caption">Listing 15-15: Using <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> to create a
<code>List</code> that we can mutate</span></p>
<p>We're creating a value, which is an instance of <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code>. We're
storing it in a variable named <code>value</code> because we want to be able to access it
directly later. Then we create a <code>List</code> in <code>a</code> that has a <code>Cons</code> variant that
holds <code>value</code>, and <code>value</code> needs to be cloned since we want <code>value</code> to also
have ownership in addition to <code>a</code>. Then we wrap <code>a</code> in an <code>Rc&lt;T&gt;</code> so that we
can create lists <code>b</code> and <code>c</code> that start differently but both refer to <code>a</code>,
similarly to what we did in Listing 15-12.</p>
<p>Once we have the lists in <code>shared_list</code>, <code>b</code>, and <code>c</code> created, then we add 10
to the 5 in <code>value</code> by dereferencing the <code>Rc&lt;T&gt;</code> and calling <code>borrow_mut</code> on
the <code>RefCell</code>.</p>
<p>When we print out <code>shared_list</code>, <code>b</code>, and <code>c</code>, we can see that they all have
the modified value of 15:</p>
<pre><code class="language-text">shared_list after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>This is pretty neat! By using <code>RefCell&lt;T&gt;</code>, we can have an outwardly immutable
<code>List</code>, but we can use the methods on <code>RefCell&lt;T&gt;</code> that provide access to its
interior mutability to be able to modify our data when we need to. The runtime
checks of the borrowing rules that <code>RefCell&lt;T&gt;</code> does protect us from data
races, and we've decided that we want to trade a bit of speed for the
flexibility in our data structures.</p>
<p><code>RefCell&lt;T&gt;</code> is not the only standard library type that provides interior
mutability. <code>Cell&lt;T&gt;</code> is similar but instead of giving references to the inner
value like <code>RefCell&lt;T&gt;</code> does, the value is copied in and out of the <code>Cell&lt;T&gt;</code>.
<code>Mutex&lt;T&gt;</code> offers interior mutability that is safe to use across threads, and
we'll be discussing its use in the next chapter on concurrency. Check out the
standard library docs for more details on the differences between these types.</p>
<a class="header" href="print.html#creating-reference-cycles-and-leaking-memory-is-safe" id="creating-reference-cycles-and-leaking-memory-is-safe"><h2>Creating Reference Cycles and Leaking Memory is Safe</h2></a>
<p>Rust makes a number of guarantees that we've talked about, for example that
we'll never have a null value, and data races will be disallowed at compile
time. Rust's memory safety guarantees make it more difficult to create memory
that never gets cleaned up, which is known as a <em>memory leak</em>. Rust does not
make memory leaks <em>impossible</em>, however, preventing memory leaks is <em>not</em> one
of Rust's guarantees. In other words, memory leaks are memory safe.</p>
<p>By using <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>, it is possible to create cycles of
references where items refer to each other in a cycle. This is bad because the
reference count of each item in the cycle will never reach 0, and the values
will never be dropped. Let's take a look at how that might happen and how to
prevent it.</p>
<p>In Listing 15-16, we're going to use another variation of the <code>List</code> definition
from Listing 15-5. We're going back to storing an <code>i32</code> value as the first
element in the <code>Cons</code> variant. The second element in the <code>Cons</code> variant is now
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>: instead of being able to modify the <code>i32</code> value this time,
we want to be able to modify which <code>List</code> a <code>Cons</code> variant is pointing to.
We've also added a <code>tail</code> method to make it convenient for us to access the
second item, if we have a <code>Cons</code> variant:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match *self {
            Cons(_, ref item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}
</code></pre>
<p><span class="caption">Listing 15-16: A cons list definition that holds a
<code>RefCell</code> so that we can modify what a <code>Cons</code> variant is referring to</span></p>
<p>Next, in Listing 15-17, we're going to create a <code>List</code> value in the variable
<code>a</code> that initially is a list of <code>5, Nil</code>. Then we'll create a <code>List</code> value in
the variable <code>b</code> that is a list of the value 10 and then points to the list in
<code>a</code>. Finally, we'll modify <code>a</code> so that it points to <code>b</code> instead of <code>Nil</code>, which
will then create a cycle:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># #[derive(Debug)]
# enum List {
#     Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
#     Nil,
# }
#
# impl List {
#     fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
#         match *self {
#             Cons(_, ref item) =&gt; Some(item),
#             Nil =&gt; None,
#         }
#     }
# }
#
use List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {

    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a next item = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(a.clone())));

    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b next item = {:?}&quot;, b.tail());

    if let Some(ref link) = a.tail() {
        *link.borrow_mut() = b.clone();
    }

    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle; it will
    // overflow the stack
    // println!(&quot;a next item = {:?}&quot;, a.tail());
}
</code></pre></pre>
<p><span class="caption">Listing 15-17: Creating a reference cycle of two <code>List</code>
values pointing to each other</span></p>
<p>We use the <code>tail</code> method to get a reference to the <code>RefCell</code> in <code>a</code>, which we
put in the variable <code>link</code>. Then we use the <code>borrow_mut</code> method on the
<code>RefCell</code> to change the value inside from an <code>Rc</code> that holds a <code>Nil</code> value to
the <code>Rc</code> in <code>b</code>. We've created a reference cycle that looks like Figure 15-18:</p>
<p><img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 15-18: A reference cycle of lists <code>a</code> and <code>b</code>
pointing to each other</span></p>
<p>If you uncomment the last <code>println!</code>, Rust will try and print this cycle out
with <code>a</code> pointing to <code>b</code> pointing to <code>a</code> and so forth until it overflows the
stack.</p>
<p>Looking at the results of the <code>println!</code> calls before the last one, we'll see
that the reference count of both <code>a</code> and <code>b</code> are 2 after we change <code>a</code> to point
to <code>b</code>. At the end of <code>main</code>, Rust will try and drop <code>b</code> first, which will
decrease the count of the <code>Rc</code> by one. However, because <code>a</code> is still
referencing that <code>Rc</code>, its count is 1 rather than 0, so the memory the <code>Rc</code> has
on the heap won't be dropped. It'll just sit there with a count of one,
forever. In this specific case, the program ends right away, so it's not a
problem, but in a more complex program that allocates lots of memory in a cycle
and holds onto it for a long time, this would be a problem. The program would
be using more memory than it needs to be, and might overwhelm the system and
cause it to run out of memory available to use.</p>
<p>Now, as you can see, creating reference cycles is difficult and inconvenient in
Rust. But it's not impossible: preventing memory leaks in the form of reference
cycles is not one of the guarantees Rust makes. If you have <code>RefCell&lt;T&gt;</code> values
that contain <code>Rc&lt;T&gt;</code> values or similar nested combinations of types with
interior mutability and reference counting, be aware that you'll have to ensure
that you don't create cycles. In the example in Listing 15-14, the solution
would probably be to not write code that could create cycles like this, since
we do want <code>Cons</code> variants to own the list they point to.</p>
<p>With data structures like graphs, it's sometimes necessary to have references
that create cycles in order to have parent nodes point to their children and
children nodes point back in the opposite direction to their parents, for
example. If one of the directions is expressing ownership and the other isn't,
one way of being able to model the relationship of the data without creating
reference cycles and memory leaks is using <code>Weak&lt;T&gt;</code>. Let's explore that next!</p>
<a class="header" href="print.html#prevent-reference-cycles-turn-an-rct-into-a-weakt" id="prevent-reference-cycles-turn-an-rct-into-a-weakt"><h3>Prevent Reference Cycles: Turn an <code>Rc&lt;T&gt;</code> into a <code>Weak&lt;T&gt;</code></h3></a>
<p>The Rust standard library provides <code>Weak&lt;T&gt;</code>, a smart pointer type for use in
situations that have cycles of references but only one direction expresses
ownership. We've been showing how cloning an <code>Rc&lt;T&gt;</code> increases the
<code>strong_count</code> of references; <code>Weak&lt;T&gt;</code> is a way to reference an <code>Rc&lt;T&gt;</code> that
does not increment the <code>strong_count</code>: instead it increments the <code>weak_count</code>
of references to an <code>Rc</code>. When an <code>Rc</code> goes out of scope, the inner value will
get dropped if the <code>strong_count</code> is 0, even if the <code>weak_count</code> is not 0. To
be able to get the value from a <code>Weak&lt;T&gt;</code>, we first have to upgrade it to an
<code>Option&lt;Rc&lt;T&gt;&gt;</code> by using the <code>upgrade</code> method. The result of upgrading a
<code>Weak&lt;T&gt;</code> will be <code>Some</code> if the <code>Rc</code> value has not been dropped yet, and <code>None</code>
if the <code>Rc</code> value has been dropped. Because <code>upgrade</code> returns an <code>Option</code>, we
know Rust will make sure we handle both the <code>Some</code> case and the <code>None</code> case and
we won't be trying to use an invalid pointer.</p>
<p>Instead of the list in Listing 15-17 where each item knows only about the
next item, let's say we want a tree where the items know about their children
items <em>and</em> their parent items.</p>
<p>Let's start just with a struct named <code>Node</code> that holds its own <code>i32</code> value as
well as references to its children <code>Node</code> values:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
#}</code></pre></pre>
<p>We want to be able to have a <code>Node</code> own its children, and we also want to be
able to have variables own each node so we can access them directly. That's why
the items in the <code>Vec</code> are <code>Rc&lt;Node&gt;</code> values. We want to be able to modify what
nodes are another node's children, so that's why we have a <code>RefCell</code> in
<code>children</code> around the <code>Vec</code>. In Listing 15-19, let's create one instance of
<code>Node</code> named <code>leaf</code> with the value 3 and no children, and another instance
named <code>branch</code> with the value 5 and <code>leaf</code> as one of its children:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![leaf.clone()]),
    });
}
</code></pre>
<p><span class="caption">Listing 15-19: Creating a <code>leaf</code> node and a <code>branch</code> node
where <code>branch</code> has <code>leaf</code> as one of its children but <code>leaf</code> has no reference to
<code>branch</code></span></p>
<p>The <code>Node</code> in <code>leaf</code> now has two owners: <code>leaf</code> and <code>branch</code>, since we clone
the <code>Rc</code> in <code>leaf</code> and store that in <code>branch</code>. The <code>Node</code> in <code>branch</code> knows
it's related to <code>leaf</code> since <code>branch</code> has a reference to <code>leaf</code> in
<code>branch.children</code>. However, <code>leaf</code> doesn't know that it's related to <code>branch</code>,
and we'd like <code>leaf</code> to know that <code>branch</code> is its parent.</p>
<p>To do that, we're going to add a <code>parent</code> field to our <code>Node</code> struct
definition, but what should the type of <code>parent</code> be? We know it can't contain
an <code>Rc&lt;T&gt;</code>, since <code>leaf.parent</code> would point to <code>branch</code> and <code>branch.children</code>
contains a pointer to <code>leaf</code>, which makes a reference cycle. Neither <code>leaf</code> nor
<code>branch</code> would get dropped since they would always refer to each other and
their reference counts would never be zero.</p>
<p>So instead of <code>Rc</code>, we're going to make the type of <code>parent</code> use <code>Weak&lt;T&gt;</code>,
specifically a <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
#}</code></pre></pre>
<p>This way, a node will be able to refer to its parent node if it has one,
but it does not own its parent. A parent node will be dropped even if
it has child nodes referring to it, as long as it doesn't have a parent
node as well. Now let's update <code>main</code> to look like Listing 15-20:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![leaf.clone()]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}
</code></pre>
<p><span class="caption">Listing 15-20: A <code>leaf</code> node and a <code>branch</code> node where
<code>leaf</code> has a <code>Weak</code> reference to its parent, <code>branch</code></span></p>
<p>Creating the <code>leaf</code> node looks similar; since it starts out without a parent,
we create a new <code>Weak</code> reference instance. When we try to get a reference to
the parent of <code>leaf</code> by using the <code>upgrade</code> method, we'll get a <code>None</code> value,
as shown by the first <code>println!</code> that outputs:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>Similarly, <code>branch</code> will also have a new <code>Weak</code> reference, since <code>branch</code> does
not have a parent node. We still make <code>leaf</code> be one of the children of
<code>branch</code>. Once we have a new <code>Node</code> instance in <code>branch</code>, we can modify <code>leaf</code>
to have a <code>Weak</code> reference to <code>branch</code> for its parent. We use the <code>borrow_mut</code>
method on the <code>RefCell</code> in the <code>parent</code> field of <code>leaf</code>, then we use the
<code>Rc::downgrade</code> function to create a <code>Weak</code> reference to <code>branch</code> from the <code>Rc</code>
in <code>branch.</code></p>
<p>When we print out the parent of <code>leaf</code> again, this time we'll get a <code>Some</code>
variant holding <code>branch</code>. Also notice we don't get a cycle printed out that
eventually ends in a stack overflow like we did in Listing 15-14: the <code>Weak</code>
references are just printed as <code>(Weak)</code>:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>The fact that we don't get infinite output (or at least until the stack
overflows) is one way we can see that we don't have a reference cycle in this
case. Another way we can tell is by looking at the values we get from calling
<code>Rc::strong_count</code> and <code>Rc::weak_count</code>. In Listing 15-21, let's create a new
inner scope and move the creation of <code>branch</code> in there, so that we can see what
happens when <code>branch</code> is created and then dropped when it goes out of scope:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![leaf.clone()]),
        });
        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}
</code></pre>
<p><span class="caption">Listing 15-21: Creating <code>branch</code> in an inner scope and
examining strong and weak reference counts of <code>leaf</code> and <code>branch</code></span></p>
<p>Right after creating <code>leaf</code>, its strong count is 1 (for <code>leaf</code> itself) and its
weak count is 0. In the inner scope, after we create <code>branch</code> and associate
<code>leaf</code> and <code>branch</code>, <code>branch</code> will have a strong count of 1 (for <code>branch</code>
itself) and a weak count of 1 (for <code>leaf.parent</code> pointing to <code>branch</code> with a
<code>Weak&lt;T&gt;</code>). <code>leaf</code> will have a strong count of 2, since <code>branch</code> now has a
clone the <code>Rc</code> of <code>leaf</code> stored in <code>branch.children</code>. <code>leaf</code> still has a weak
count of 0.</p>
<p>When the inner scope ends, <code>branch</code> goes out of scope, and its strong count
decreases to 0, so its <code>Node</code> gets dropped. The weak count of 1 from
<code>leaf.parent</code> has no bearing on whether <code>Node</code> gets dropped or not, so we don't
have a memory leak!</p>
<p>If we try to access the parent of <code>leaf</code> after the end of the scope, we'll get
<code>None</code> again like we did before <code>leaf</code> had a parent. At the end of the program,
<code>leaf</code> has a strong count of 1 and a weak count of 0, since <code>leaf</code> is now the
only thing pointing to it again.</p>
<p>All of the logic managing the counts and whether a value should be dropped or
not was managed by <code>Rc</code> and <code>Weak</code> and their implementations of the <code>Drop</code>
trait. By specifying that the relationship from a child to its parent should be
a <code>Weak&lt;T&gt;</code> reference in the definition of <code>Node</code>, we're able to have parent
nodes point to child nodes and vice versa without creating a reference cycle
and memory leaks.</p>
<a class="header" href="print.html#summary-7" id="summary-7"><h2>Summary</h2></a>
<p>We've now covered how you can use different kinds of smart pointers to choose
different guarantees and tradeoffs than those Rust makes with regular
references. <code>Box&lt;T&gt;</code> has a known size and points to data allocated on the heap.
<code>Rc&lt;T&gt;</code> keeps track of the number of references to data on the heap so that
data can have multiple owners. <code>RefCell&lt;T&gt;</code> with its interior mutability gives
us a type that can be used where we need an immutable type, and enforces the
borrowing rules at runtime instead of at compile time.</p>
<p>We've also discussed the <code>Deref</code> and <code>Drop</code> traits that enable a lot of smart
pointers' functionality. We explored how it's possible to create a reference
cycle that would cause a memory leak, and how to prevent reference cycles by
using <code>Weak&lt;T&gt;</code>.</p>
<p>If this chapter has piqued your interest and you now want to implement your own
smart pointers, check out <a href="https://doc.rust-lang.org/stable/nomicon/">The Nomicon</a> for even more useful information.</p>
<p>Next, let's talk about concurrency in Rust. We'll even learn about a few new
smart pointers that can help us with it.</p>
<a class="header" href="print.html#fearless-concurrency" id="fearless-concurrency"><h1>Fearless Concurrency</h1></a>
<p>Ensuring memory safety isn't Rust's only goal: being a language that is better
equipped to handle concurrent and parallel programming has always been another
major goal of Rust. <em>Concurrent programming</em>, where different parts of a
program execute independently, and <em>parallel programming</em>, where different
parts of a program are executing at the same time, are becoming more important
as more computers have multiple processors for our programs to take advantage
of. Historically, programming in these contexts has been difficult and error
prone: Rust hopes to change that.</p>
<p>Originally, we thought that memory safety and preventing concurrency problems
were two separate challenges to be solved with different methods. However, over
time, we discovered that ownership and the type system are a powerful set of
tools that help in dealing with both memory safety <em>and</em> concurrency problems!
By leveraging ownership and type checking, many concurrency errors are <em>compile
time</em> errors in Rust, rather than runtime errors. We've nicknamed this aspect
of Rust <em>fearless concurrency</em>. Fearless concurrency means Rust not only allows
you to have confidence that your code is free of subtle bugs, but also lets you
refactor this kind of code easily without worrying about introducing new bugs.</p>
<blockquote>
<p>Note: given that Rust's slogan is <em>fearless concurrency</em>, we'll be referring
to many of the problems here as <em>concurrent</em> rather than being more precise
by saying <em>concurrent and/or parallel</em>, for simplicity's sake. If this were a
book specifically about concurrency and/or parallelism, we'd be sure to be
more specific. For this chapter, please mentally substitute
<em>concurrent and/or parallel</em> whenever we say <em>concurrent</em>.</p>
</blockquote>
<p>Many languages are strongly opinionated about the solutions they offer you to
deal with concurrent problems. That's a very reasonable strategy, especially
for higher-level languages, but lower-level languages don't have that luxury.
Lower-level languages are expected to enable whichever solution would provide
the best performance in a given situation, and they have fewer abstractions
over the hardware. Rust, therefore, gives us a variety of tools for modeling
our problems in whatever way is appropriate for our situation and requirements.</p>
<p>Here's what we'll cover in this chapter:</p>
<ul>
<li>How to create threads to run multiple pieces of code at the same time</li>
<li><em>Message passing</em> concurrency, where channels are used to send messages
between threads.</li>
<li><em>Shared state</em> concurrency, where multiple threads have access to some piece
of data.</li>
<li>The <code>Sync</code> and <code>Send</code> traits, which allow Rust's concurrency guarantees to be
extended to user-defined types as well as types provided by the standard
library.</li>
</ul>
<a class="header" href="print.html#using-threads-to-run-code-simultaneously" id="using-threads-to-run-code-simultaneously"><h2>Using Threads to Run Code Simultaneously</h2></a>
<p>In most operating systems in use today, when your program executes, the context
in which the operating system runs your code is called a <em>process</em>. The
operating system runs many processes, and the operating system managing these
processes is what lets multiple programs execute at the same time on your
computer.</p>
<p>We can take the idea of processes each running a program down one level of
abstraction: your program can also have independent parts that run
simultaneously within the context of your program. The feature that enables
this functionality is called <em>threads</em>.</p>
<p>Splitting up the computation your program needs to do into multiple threads can
improve performance, since the program will be doing multiple things at the
same time. Programming with threads can add complexity, however. Since threads
run simultaneously, there's no inherent guarantee about the order in which the
parts of your code on different threads will run. This can lead to race
conditions where threads are accessing data or resources in an inconsistent
order, deadlocks where two threads both prevent each other from continuing, or
bugs that only happen in certain situations that are hard to reproduce
reliably. Rust lessens the effect of these and other downsides of using
threads, but programming in a multithreaded context still takes thought and
code structured differently than for programs only expected to run in a single
thread.</p>
<p>There are a few different ways that programming languages implement threads.
Many operating systems provide an API for creating new threads. In addition,
many programming languages provide their own special implementation of threads.
Programming language provided threads are sometimes called <em>lightweight</em> or
<em>green</em> threads. These languages take a number of green threads and execute
them in the context of a different number of operating system threads. For this
reason, the model where a language calls the operating system APIs to create
threads is sometimes called <em>1:1</em>, one OS thread per one language thread. The
green threaded model is called the <em>M:N</em> model, <code>M</code> green threads per <code>N</code> OS
threads, where <code>M</code> and <code>N</code> are not necessarily the same number.</p>
<p>Each model has its own advantages and tradeoffs. The tradeoff that's most
important to Rust is runtime support. <em>Runtime</em> is a confusing term; it can
have different meaning in different contexts. Here, we mean some code included
by the language in every binary. For some languages, this code is large, and
for others, this code is small. Colloquially, &quot;no runtime&quot; is often what people
will say when they mean &quot;small runtime&quot;, since every non-assembly language has
some amount of runtime. Smaller runtimes have fewer features but have the
advantage of resulting in smaller binaries. Smaller binaries make it easier to
combine the language with other languages in more contexts. While many
languages are okay with increasing the runtime in exchange for more features,
Rust needs to have nearly no runtime, and cannot compromise on being able to
call into C in order to maintain performance.</p>
<p>The green threading model is a feature that requires a larger language runtime
in order to manage the threads. As such, the Rust standard library only
provides an implementation of 1:1 threading. Because Rust is such a low-level
language, there are crates that implement M:N threading if you would rather
trade overhead for aspects such as more control over which threads run when and
lower costs of context switching, for example.</p>
<p>Now that we've defined what threads are in Rust, let's explore how to use the
thread-related API that the standard library provides for us.</p>
<a class="header" href="print.html#creating-a-new-thread-with-spawn" id="creating-a-new-thread-with-spawn"><h3>Creating a New Thread with <code>spawn</code></h3></a>
<p>To create a new thread, we call the <code>thread::spawn</code> function and pass it a
closure (we talked about closures in Chapter 13), containing the code we want
to run in the new thread. The example in Listing 16-1 prints some text from a
new thread and other text from the main thread:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 16-1: Creating a new thread to print one thing
while the main thread is printing something else</span></p>
<p>Note that the way this function is written, when the main thread ends, it will
stop the new thread too. The output from this program might be a little
different every time, but it will look similar to this:</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>The threads will probably take turns, but that's not guaranteed. In this run,
the main thread printed first, even though the print statement from the spawned
thread appears first in the code we wrote. And even though we told the spawned
thread to print until <code>i</code> is 9, it only got to 5 before the main thread shut
down. If you always only see one thread, or if you don't see any overlap, try
increasing the numbers in the ranges to create more opportunities for a thread
to take a break and give the other thread a turn.</p>
<a class="header" href="print.html#waiting-for-all-threads-to-finish-using-join-handles" id="waiting-for-all-threads-to-finish-using-join-handles"><h4>Waiting for All Threads to Finish Using <code>join</code> Handles</h4></a>
<p>Not only does the code in Listing 16-1 not allow the spawned thread to finish
most of the time since the main thread ends before the spawned thread is done,
there's actually no guarantee that the spawned thread will get to run at all! We
can fix this by saving the return value of <code>thread::spawn</code>, which is a
<code>JoinHandle</code>. That looks like Listing 16-2:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
    }

    handle.join();
}
</code></pre></pre>
<p><span class="caption">Listing 16-2: Saving a <code>JoinHandle</code> from <code>thread::spawn</code>
to guarantee the thread is run to completion</span></p>
<p>A <code>JoinHandle</code> is an owned value that can wait for a thread to finish, which is
what the <code>join</code> method does. By calling <code>join</code> on the handle, the current
thread will block until the thread that the handle represents terminates. Since
we've put the call to <code>join</code> after the main thread's <code>for</code> loop, running this
example should produce output that looks something like this:</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>The two threads are still alternating, but the main thread waits because of the
call to <code>handle.join()</code> and does not end until the spawned thread is finished.</p>
<p>If we instead move <code>handle.join()</code> before the <code>for</code> loop in main, like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
        }
    });

    handle.join();

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
    }
}
</code></pre></pre>
<p>The main thread will wait for the spawned thread to finish before the main
thread starts running its <code>for</code> loop, so the output won't be interleaved
anymore:</p>
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>Thinking about a small thing such as where to call <code>join</code> can affect whether
your threads are actually running at the same time or not.</p>
<a class="header" href="print.html#using-move-closures-with-threads" id="using-move-closures-with-threads"><h3>Using <code>move</code> Closures with Threads</h3></a>
<p>There's a feature of closures that we didn't cover in Chapter 13 that's often
useful with <code>thread::spawn</code>: <code>move</code> closures. We said this in Chapter 13:</p>
<blockquote>
<p>Creating closures that capture values from their environment is mostly used
in the context of starting new threads.</p>
</blockquote>
<p>Now we're creating new threads, so let's talk about capturing values in
closures!</p>
<p>Notice the closure that we pass to <code>thread::spawn</code> in Listing 16-1 takes no
arguments: we're not using any data from the main thread in the spawned
thread's code. In order to use data in the spawned thread that comes from the
main thread, we need the spawned thread's closure to capture the values it
needs. Listing 16-3 shows an attempt to create a vector in the main thread and
use it in the spawned thread, which won't work the way this example is written:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join();
}
</code></pre>
<p><span class="caption">Listing 16-3: Attempting to use a vector created by the
main thread from another thread</span></p>
<p>The closure uses <code>v</code>, so the closure will capture <code>v</code> and make <code>v</code> part of the
closure's environment. Because <code>thread::spawn</code> runs this closure in a new
thread, we can access <code>v</code> inside that new thread.</p>
<p>When we compile this example, however, we'll get the following error:</p>
<pre><code class="language-text">error[E0373]: closure may outlive the current function, but it borrows `v`,
which is owned by the current function
 --&gt;
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword, as shown:
  |     let handle = thread::spawn(move || {
</code></pre>
<p>When we capture something in a closure's environment, Rust will try to infer
how to capture it. <code>println!</code> only needs a reference to <code>v</code>, so the closure
tries to borrow <code>v</code>. There's a problem, though: we don't know how long the
spawned thread will run, so we don't know if the reference to <code>v</code> will always
be valid.</p>
<p>Consider the code in Listing 16-4 that shows a scenario where it's more likely
that the reference to <code>v</code> won't be valid:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    drop(v); // oh no!

    handle.join();
}
</code></pre>
<p><span class="caption">Listing 16-4: A thread with a closure that attempts to
capture a reference to <code>v</code> from a main thread that drops <code>v</code></span></p>
<p>This code could be run, and the spawned thread could immediately get put in the
background without getting a chance to run at all. The spawned thread has a
reference to <code>v</code> inside, but the main thread is still running: it immediately
drops <code>v</code>, using the <code>drop</code> function that we discussed in Chapter 15 that
explicitly drops its argument. Then, the spawned thread starts to execute. <code>v</code>
is now invalid, so a reference to it is also invalid. Oh no!</p>
<p>To fix this problem, we can listen to the advice of the error message:</p>
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword, as shown:
  |     let handle = thread::spawn(move || {
</code></pre>
<p>By adding the <code>move</code> keyword before the closure, we force the closure to take
ownership of the values it's using, rather than inferring borrowing. This
modification to the code from Listing 16-3 shown in Listing 16-5 will compile
and run as we intend:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join();
}
</code></pre></pre>
<p><span class="caption">Listing 16-5: Using the <code>move</code> keyword to force a closure
to take ownership of the values it uses</span></p>
<p>What about the code in Listing 16-4 where the main thread called <code>drop</code>? If we
add <code>move</code> to the closure, we've moved <code>v</code> into the closure's environment, and
we can no longer call <code>drop</code> on it. We get this compiler error instead:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `v`
  --&gt;
   |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
10 |     drop(v); // oh no!
   |          ^ value used here after move
   |
   = note: move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does
   not implement the `Copy` trait
</code></pre>
<p>Rust's ownership rules have saved us again!</p>
<p>Now that we have a basic understanding of threads and the thread API, let's
talk about what we can actually <em>do</em> with threads.</p>
<a class="header" href="print.html#message-passing-to-transfer-data-between-threads" id="message-passing-to-transfer-data-between-threads"><h2>Message Passing to Transfer Data Between Threads</h2></a>
<p>One approach to concurrency that's seen a rise in popularity as of late is
<em>message passing</em>, where threads or actors communicate by sending each other
messages containing data. Here's the idea in slogan form:</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by
communicating.</p>
<p>--<a href="http://golang.org/doc/effective_go.html">Effective Go</a></p>
</blockquote>
<p>A major tool to accomplish this goal is the <em>channel</em>. A channel has two
halves, a transmitter and a receiver. One part of our code can call methods on
the transmitter with the data we want to send, and another part can check the
receiving end for arriving messages.</p>
<p>We're going to work up to an example where we have one thread that will
generate values and send them down a channel. The main thread will receive the
values and print them out.</p>
<p>First, though, let's start by creating a channel but not doing anything with it
in Listing 16-6:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
#     tx.send(()).unwrap();
}
</code></pre></pre>
<p><span class="caption">Listing 16-6: Creating a channel and assigning the two
halves to <code>tx</code> and <code>rx</code></span></p>
<p>The <code>mpsc::channel</code> function creates a new channel. <code>mpsc</code> stands for <em>multiple
producer, single consumer</em>. In short, we can have multiple <em>sending</em> ends of a
channel that produce values, but only one <em>receiving</em> end that consumes those
values. We're going to start with a single producer for now, but we'll add
multiple producers once we get this example working.</p>
<p><code>mpsc::channel</code> returns a tuple: the first element is the sending end, and the
second element is the receiving end. For historical reasons, many people use
<code>tx</code> and <code>rx</code> to abbreviate <em>transmitter</em> and <em>receiver</em>, so those are the
names we're using for the variables bound to each end. We're using a <code>let</code>
statement with a pattern that destructures the tuples; we'll be discussing the
use of patterns in <code>let</code> statements and destructuring in Chapter 18.</p>
<p>Let's move the transmitting end into a spawned thread and have it send one
string, shown in Listing 16-7:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });
}
</code></pre></pre>
<p><span class="caption">Listing 16-7: Moving <code>tx</code> to a spawned thread and sending
&quot;hi&quot;</span></p>
<p>We're using <code>thread::spawn</code> to create a new thread, just as we did in the
previous section. We use a <code>move</code> closure to make <code>tx</code> move into the closure so
that the thread owns it.</p>
<p>The transmitting end of a channel has the <code>send</code> method that takes the value we
want to send down the channel. The <code>send</code> method returns a <code>Result&lt;T, E&gt;</code> type,
because if the receiving end has already been dropped, there's nowhere to send
a value to, so the send operation would error. In this example, we're simply
calling <code>unwrap</code> to ignore this error, but for a real application, we'd want to
handle it properly. Chapter 9 is where you'd go to review strategies for proper
error handling.</p>
<p>In Listing 16-8, let's get the value from the receiving end of the channel in
the main thread:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre></pre>
<p><span class="caption">Listing 16-8: Receiving the value &quot;hi&quot; in the main thread
and printing it out</span></p>
<p>The receiving end of a channel has two useful methods: <code>recv</code> and <code>try_recv</code>.
Here, we're using <code>recv</code>, which is short for <em>receive</em>. This method will block
execution until a value is sent down the channel. Once a value is sent, <code>recv</code>
will return it in a <code>Result&lt;T, E&gt;</code>. When the sending end of the channel closes,
<code>recv</code> will return an error. The <code>try_recv</code> method will not block; it instead
returns a <code>Result&lt;T, E&gt;</code> immediately.</p>
<p>If we run the code in Listing 16-8, we'll see the value printed out from the
main thread:</p>
<pre><code class="language-text">Got: hi
</code></pre>
<a class="header" href="print.html#how-channels-interact-with-ownership" id="how-channels-interact-with-ownership"><h3>How Channels Interact with Ownership</h3></a>
<p>Let's do an experiment at this point to see how channels and ownership work
together: we'll try to use <code>val</code> in the spawned thread after we've sent it down
the channel. Try compiling the code in Listing 16-9:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
        println!(&quot;val is {}&quot;, val);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre>
<p><span class="caption">Listing 16-9: Attempting to use <code>val</code> after we have sent
it down the channel</span></p>
<p>Here, we try to print out <code>val</code> after we've sent it down the channel via
<code>tx.send</code>. This is a bad idea: once we've sent the value to another thread,
that thread could modify it or drop it before we try to use the value again.
This could cause errors or unexpected results due to inconsistent or
nonexistent data.</p>
<p>If we try to compile this code, Rust will error:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `val`
  --&gt; src/main.rs:10:31
   |
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val is {}&quot;, val);
   |                               ^^^ value used here after move
   |
   = note: move occurs because `val` has type `std::string::String`, which does
   not implement the `Copy` trait
</code></pre>
<p>Our concurrency mistake has caused a compile-time error! <code>send</code> takes ownership
of its parameter and moves the value so that the value is owned by the
receiver. This means we can't accidentally use the value again after sending
it; the ownership system checks that everything is okay.</p>
<p>In this regard, message passing is very similar to single ownership in Rust.
Message passing enthusiasts enjoy message passing for similar reasons that
Rustaceans enjoy Rust's ownership: single ownership means certain classes of
problems go away. If only one thread at a time can use some memory, there's no
chance of a data race.</p>
<a class="header" href="print.html#sending-multiple-values-and-seeing-the-receiver-waiting" id="sending-multiple-values-and-seeing-the-receiver-waiting"><h3>Sending Multiple Values and Seeing the Receiver Waiting</h3></a>
<p>The code in Listing 16-8 compiled and ran, but it wasn't very interesting: it's
hard to see that we have two separate threads talking to each other over a
channel. Listing 16-10 has some modifications that will prove to us that this
code is running concurrently: the spawned thread will now send multiple
messages and pause for a second between each message.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 16-10: Sending multiple messages and pausing
between each one</span></p>
<p>This time, we have a vector of strings in the spawned thread that we want to
send to the main thread. We iterate over them, sending each individually and
then pausing by calling the <code>thread::sleep</code> function with a <code>Duration</code> value of
one second.</p>
<p>In the main thread, we're not calling the <code>recv</code> function explicitly anymore:
instead we're treating <code>rx</code> as an iterator. For each value received, we're
printing it out. When the channel is closed, iteration will end.</p>
<p>When running the code in Listing 16-10, we'll see this output, with a one second
pause in between each line:</p>
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>We don't have any pausing or code that would take a while in the <code>for</code> loop in
the main thread, so we can tell that the main thread is waiting to receive
values from the spawned thread.</p>
<a class="header" href="print.html#create-multiple-producers-by-cloning-the-transmitter" id="create-multiple-producers-by-cloning-the-transmitter"><h3>Create Multiple Producers by Cloning the Transmitter</h3></a>
<p>Near the start of this section, we mentioned that <code>mpsc</code> stood for <em>multiple
producer, single consumer</em>. We can expand the code from Listing 16-10 to create
multiple threads that all send values to the same receiver. We do that by
cloning the transmitting half of the channel, as shown in Listing 16-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::thread;
# use std::sync::mpsc;
# use std::time::Duration;
#
# fn main() {
// ...snip...
let (tx, rx) = mpsc::channel();

let tx1 = tx.clone();
thread::spawn(move || {
    let vals = vec![
        String::from(&quot;hi&quot;),
        String::from(&quot;from&quot;),
        String::from(&quot;the&quot;),
        String::from(&quot;thread&quot;),
    ];

    for val in vals {
        tx1.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

thread::spawn(move || {
    let vals = vec![
        String::from(&quot;more&quot;),
        String::from(&quot;messages&quot;),
        String::from(&quot;for&quot;),
        String::from(&quot;you&quot;),
    ];

    for val in vals {
        tx.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});
// ...snip...
#
#     for received in rx {
#         println!(&quot;Got: {}&quot;, received);
#     }
# }
</code></pre></pre>
<p><span class="caption">Listing 16-11: Sending multiple messages and pausing
between each one</span></p>
<p>This time, before we create the first spawned thread, we call <code>clone</code> on the
sending end of the channel. This will give us a new sending handle that we can
pass to the first spawned thread. We'll pass the original sending end of the
channel to a second spawned thread, and each thread is sending different
messages to the receiving end of the channel.</p>
<p>If you run this, you'll <em>probably</em> see output like this:</p>
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>You might see the values in a different order, though. It depends on your
system! This is what makes concurrency interesting as well as difficult. If you
play around with <code>thread::sleep</code>, giving it different values in the different
threads, you can make the runs more non-deterministic and create different
output each time.</p>
<p>Now that we've seen how channels work, let's look at shared-memory concurrency.</p>
<a class="header" href="print.html#shared-state-concurrency" id="shared-state-concurrency"><h2>Shared State Concurrency</h2></a>
<p>While message passing is a fine way of dealing with concurrency, it's not the
only one. Consider this slogan again:</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by
communicating.</p>
</blockquote>
<p>What would &quot;communicate by sharing memory&quot; look like? And moreover, why would
message passing enthusiasts dislike it, and dislike it enough to invert it
entirely?</p>
<p>Remember how channels are sort of like single ownership? Shared memory
concurrency is sort of like multiple ownership: multiple threads can access the
same memory location at the same time. As we saw with multiple ownership made
possible by smart pointers in Chapter 15, multiple ownership can add additional
complexity, since we need to manage these different owners somehow.</p>
<p>Rust's type system and ownership can help a lot here in getting this management
correct, though. For an example, let's look at one of the more common
concurrency primitives for shared memory: mutexes.</p>
<a class="header" href="print.html#mutexes-allow-access-to-data-from-one-thread-at-a-time" id="mutexes-allow-access-to-data-from-one-thread-at-a-time"><h3>Mutexes Allow Access to Data from One Thread at a Time</h3></a>
<p>A <em>mutex</em> is a concurrency primitive for sharing memory. It's short for &quot;mutual
exclusion&quot;, that is, it only allows one thread to access some data at any given
time. Mutexes have a reputation for being hard to use, since there's a lot you
have to remember:</p>
<ol>
<li>You have to remember to attempt to acquire the lock before using the data.</li>
<li>Once you're done with the data that's being guarded by the mutex, you have
to remember to unlock the data so that other threads can acquire the lock.</li>
</ol>
<p>For a real-world example of a mutex, imagine a panel discussion at a conference
where there is only one microphone. Before a panelist may speak, they have to
ask or signal that they would like to use the microphone. Once they get the
microphone, they may talk for as long as they would like, then hand the
microphone to the next panelist who would like to speak. It would be rude for a
panelist to start shouting without having the microphone or to steal the
microphone before another panelist was finished. No one else would be able to
speak if a panelist forgot to hand the microphone to the next person when they
finished using it. If the management of the shared microphone went wrong in any
of these ways, the panel would not work as planned!</p>
<p>Management of mutexes can be incredibly tricky to get right, and that's why so
many people are enthusiastic about channels. However, in Rust, we can't get
locking and unlocking wrong, thanks to the type system and ownership.</p>
<a class="header" href="print.html#the-api-of-mutext" id="the-api-of-mutext"><h4>The API of <code>Mutex&lt;T&gt;</code></h4></a>
<p>Let's look at an example of using a mutex in Listing 16-12, without involving
multiple threads for the moment:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}
</code></pre></pre>
<p><span class="caption">Listing 16-12: Exploring the API of <code>Mutex&lt;T&gt;</code> in a
single threaded context for simplicity</span></p>
<p>Like many types, we create a <code>Mutex&lt;T&gt;</code> through an associated function named
<code>new</code>. To access the data inside the mutex, we use the <code>lock</code> method to acquire
the lock. This call will block until it's our turn to have the lock. This call
can fail if another thread was holding the lock and then that thread panicked.
In a similar way as we did in Listing 16-6 in the last section, we're using
<code>unwrap()</code> for now, rather than better error handling. See Chapter 9 for better
tools.</p>
<p>Once we have acquired the lock, we can treat the return value, named <code>num</code> in
this case, as a mutable reference to the data inside. The type system is how
Rust ensures that we acquire a lock before using this value: <code>Mutex&lt;i32&gt;</code> is
not an <code>i32</code>, so we <em>must</em> acquire the lock in order to be able to use the
<code>i32</code> value. We can't forget; the type system won't let us do otherwise.</p>
<p>As you may have suspected, <code>Mutex&lt;T&gt;</code> is a smart pointer. Well, more
accurately, the call to <code>lock</code> returns a smart pointer called <code>MutexGuard</code>.
This smart pointer implements <code>Deref</code> to point at our inner data, similar to
the other smart pointers we saw in Chapter 15. In addition, <code>MutexGuard</code> has a
<code>Drop</code> implementation that releases the lock. This way, we can't forget to
release the lock. It happens for us automatically when the <code>MutexGuard</code> goes
out of scope, which it does at the end of the inner scope in Listing 16-12. We
can print out the mutex value and see that we were able to change the inner
<code>i32</code> to 6.</p>
<a class="header" href="print.html#sharing-a-mutext-between-multiple-threads" id="sharing-a-mutext-between-multiple-threads"><h4>Sharing a <code>Mutex&lt;T&gt;</code> Between Multiple Threads</h4></a>
<p>Let's now try to share a value between multiple threads using <code>Mutex&lt;T&gt;</code>. We'll
spin up ten threads, and have them each increment a counter value by 1 so that
the counter goes from 0 to 10. Note that the next few examples will have
compiler errors, and we're going to use those errors to learn more about using
<code>Mutex&lt;T&gt;</code> and how Rust helps us use it correctly. Listing 16-13 has our
starting example:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(|| {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">Listing 16-13: The start of a program having 10 threads
each increment a counter guarded by a <code>Mutex&lt;T&gt;</code></span></p>
<p>We're creating a <code>counter</code> variable to hold an <code>i32</code> inside a <code>Mutex&lt;T&gt;</code>, like
we did in Listing 16-12. Next, we're creating 10 threads by mapping over a
range of numbers. We use <code>thread::spawn</code> and give all the threads the same
closure: they're each going to acquire a lock on the <code>Mutex&lt;T&gt;</code> by calling the
<code>lock</code> method and then add 1 to the value in the mutex. When a thread finishes
running its closure, <code>num</code> will go out of scope and release the lock so that
another thread can acquire it.</p>
<p>In the main thread, we're collecting all the join handles like we did in
Listing 16-2, and then calling <code>join</code> on each of them to make sure all the
threads finish. At that point, the main thread will acquire the lock and print
out the result of this program.</p>
<p>We hinted that this example won't compile, let's find out why!</p>
<pre><code class="language-text">error[E0373]: closure may outlive the current function, but it borrows
`counter`, which is owned by the current function
  --&gt;
   |
9  |         let handle = thread::spawn(|| {
   |                                    ^^ may outlive borrowed value `counter`
10 |             let mut num = counter.lock().unwrap();
   |                           ------- `counter` is borrowed here
   |
help: to force the closure to take ownership of `counter` (and any other
referenced variables), use the `move` keyword, as shown:
   |         let handle = thread::spawn(move || {
</code></pre>
<p>This is similar to the problem we solved in Listing 16-5. Given that we spin up
multiple threads, Rust can't know how long the threads will run and whether
<code>counter</code> will still be valid when each thread tries to borrow it. The help
message has a reminder for how to solve this: we can use <code>move</code> to give
ownership to each thread. Let's try it by making this change to the closure:</p>
<pre><code class="language-rust ignore">thread::spawn(move || {
</code></pre>
<p>And trying to compile again. We'll get different errors this time!</p>
<pre><code class="language-text">error[E0382]: capture of moved value: `counter`
  --&gt;
   |
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved (into closure) here
10 |             let mut num = counter.lock().unwrap();
   |                           ^^^^^^^ value captured here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error[E0382]: use of moved value: `counter`
  --&gt;
   |
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved (into closure) here
...
21 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value used here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error: aborting due to 2 previous errors
</code></pre>
<p><code>move</code> didn't fix this program like it fixed Listing 16-5. Why not? This error
message is a little confusing to read, because it's saying that the <code>counter</code>
value is moved into the closure, then is captured when we call <code>lock</code>. That
sounds like what we wanted, but it's not allowed.</p>
<p>Let's reason this out. Instead of making 10 threads in a <code>for</code> loop, let's just
make two threads without a loop and see what happens then. Replace the first
<code>for</code> loop in Listing 16-13 with this code instead:</p>
<pre><code class="language-rust ignore">let handle = thread::spawn(move || {
    let mut num = counter.lock().unwrap();

    *num += 1;
});
handles.push(handle);

let handle2 = thread::spawn(move || {
    let mut num2 = counter.lock().unwrap();

    *num2 += 1;
});
handles.push(handle2);
</code></pre>
<p>Here we're making 2 threads, and we changed the variable names used with the
second thread to <code>handle2</code> and <code>num2</code>. We're simplifying our example for the
moment to see if we can understand the error message we're getting. This time,
compiling gives us:</p>
<pre><code class="language-text">error[E0382]: capture of moved value: `counter`
  --&gt;
   |
8  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
16 |         let mut num2 = counter.lock().unwrap();
   |                        ^^^^^^^ value captured here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error[E0382]: use of moved value: `counter`
  --&gt;
   |
8  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
26 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value used here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error: aborting due to 2 previous errors
</code></pre>
<p>Aha! In the first error message, Rust is showing us that <code>counter</code> is moved
into the closure for the thread that goes with <code>handle</code>. That move is
preventing us from capturing <code>counter</code> when we try to call <code>lock</code> on it and
store the result in <code>num2</code>, which is in the second thread! So Rust is telling
us that we can't move ownership of <code>counter</code> into multiple threads. This was
hard to see before since we were creating multiple threads in a loop, and Rust
can't point to different threads in different iterations of the loop.</p>
<a class="header" href="print.html#multiple-ownership-with-multiple-threads" id="multiple-ownership-with-multiple-threads"><h4>Multiple Ownership with Multiple Threads</h4></a>
<p>In Chapter 15, we were able to have multiple ownership of a value by using the
smart pointer <code>Rc&lt;T&gt;</code> to create a reference-counted value. We mentioned in
Chapter 15 that <code>Rc&lt;T&gt;</code> was only for single-threaded contexts, but let's try
using <code>Rc&lt;T&gt;</code> in this case anyway and see what happens. We'll wrap the
<code>Mutex&lt;T&gt;</code> in <code>Rc&lt;T&gt;</code> in Listing 16-14, and clone the <code>Rc&lt;T&gt;</code> before moving
ownership to the thread. We'll switch back to the <code>for</code> loop for creating the
threads, and keep the <code>move</code> keyword with the closure:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = counter.clone();
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">Listing 16-14: Attempting to use <code>Rc&lt;T&gt;</code> to allow
multiple threads to own the <code>Mutex&lt;T&gt;</code></span></p>
<p>Once again, we compile and get... different errors! The compiler is teaching us
a lot!</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;:
std::marker::Send` is not satisfied
  --&gt;
   |
11 |         let handle = thread::spawn(move || {
   |                      ^^^^^^^^^^^^^ the trait `std::marker::Send` is not
   implemented for `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
   |
   = note: `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads
   safely
   = note: required because it appears within the type
   `[closure@src/main.rs:11:36: 15:10
   counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`
   = note: required by `std::thread::spawn`
</code></pre>
<p>Wow, that's quite wordy! Some important parts to pick out: the first note says
<code>Rc&lt;Mutex&lt;i32&gt;&gt; cannot be sent between threads safely</code>. The reason for this is
in the error message, which, once distilled, says <code>the trait bound Send is not satisfied</code>. We're going to talk about <code>Send</code> in the next section; it's one of
the traits that ensures the types we use with threads are meant for use in
concurrent situations.</p>
<p>Unfortunately, <code>Rc&lt;T&gt;</code> is not safe to share across threads. When <code>Rc&lt;T&gt;</code>
manages the reference count, it has to add to the count for each call to
<code>clone</code> and subtract from the count when each clone is dropped. <code>Rc&lt;T&gt;</code> doesn't
use any concurrency primitives to make sure that changes to the count happen in
an operation that couldn't be interrupted by another thread. This could lead to
subtle bugs where the counts are wrong, which could lead to memory leaks or
dropping a value before we're done with it. So what if we had a type that was
exactly like <code>Rc&lt;T&gt;</code>, but made changes to the reference count in a thread-safe
way?</p>
<a class="header" href="print.html#atomic-reference-counting-with-arct" id="atomic-reference-counting-with-arct"><h4>Atomic Reference Counting with <code>Arc&lt;T&gt;</code></h4></a>
<p>If you thought that question sounded like a leading one, you'd be right. There
is a type like <code>Rc&lt;T&gt;</code> that's safe to use in concurrent situations: <code>Arc&lt;T&gt;</code>.
The 'a' stands for <em>atomic</em>, so it's an <em>atomically reference counted</em> type.
Atomics are an additional kind of concurrency primitive that we won't cover
here; see the standard library documentation for <code>std::sync::atomic</code> for more
details. The gist of it is this: atomics work like primitive types, but are
safe to share across threads.</p>
<p>Why aren't all primitive types atomic, and why aren't all standard library
types implemented to use <code>Arc&lt;T&gt;</code> by default? Thread safety comes with a
performance penalty that we only want to pay when we need it. If we're only
doing operations on values within a single thread, our code can run faster
since it doesn't need the guarantees that atomics give us.</p>
<p>Back to our example: <code>Arc&lt;T&gt;</code> and <code>Rc&lt;T&gt;</code> are identical except for the atomic
internals of <code>Arc&lt;T&gt;</code>. Their API is the same, so we can change the <code>use</code> line
and the call to <code>new</code>. The code in Listing 16-15 will finally compile and run:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = counter.clone();
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<p><span class="caption">Listing 16-15: Using an <code>Arc&lt;T&gt;</code> to wrap the <code>Mutex&lt;T&gt;</code>
to be able to share ownership across multiple threads</span></p>
<p>This will print:</p>
<pre><code class="language-text">Result: 10
</code></pre>
<p>We did it! We counted from 0 to 10, which may not seem very impressive, but we
learned a lot about <code>Mutex&lt;T&gt;</code> and thread safety along the way! The structure
that we've built in this example could be used to do more complicated
operations than just incrementing a counter. Calculations that can be divided
up into independent parts could be split across threads in this way, and we can
use a <code>Mutex&lt;T&gt;</code> to allow each thread to update the final result with its part.</p>
<p>You may have noticed that, since <code>counter</code> is immutable but we could get a
mutable reference to the value inside it, this means <code>Mutex&lt;T&gt;</code> provides
interior mutability, like the <code>Cell</code> family does. In the same way that we used
<code>RefCell&lt;T&gt;</code> in Chapter 15 to be able to mutate contents inside an <code>Rc&lt;T&gt;</code>, we
use <code>Mutex&lt;T&gt;</code> to be able to mutate contents inside of an <code>Arc&lt;T&gt;</code>.</p>
<p>Recall that <code>Rc&lt;T&gt;</code> did not prevent every possible problem: we also talked
about the possibility of creating reference cycles where two <code>Rc&lt;T&gt;</code> values
refer to each other, which would cause a memory leak. We have a similar problem
with <code>Mutex&lt;T&gt;</code> that Rust also doesn't prevent: deadlocks. A <em>deadlock</em> is a
situation in which an operation needs to lock two resources, and two threads
have each acquired one of the locks and will now wait for each other forever.
If you're interested in this topic, try creating a Rust program that has a
deadlock, then research deadlock mitigation strategies that apply to the use of
mutexes in any language and try implementing them in Rust. The standard library
API documentation for <code>Mutex&lt;T&gt;</code> and <code>MutexGuard</code> will have useful information.</p>
<p>Rust's type system and ownership has made sure that our threads have exclusive
access to the shared value when they're updating it, so the threads won't
overwrite each other's answers in unpredictable ways. It took us a while to
work with the compiler to get everything right, but we've saved future time
that might be spent trying to reproduce subtly incorrect scenarios that only
happen when the threads run in a particular order.</p>
<p>Let's round out this chapter by talking about the <code>Send</code> and <code>Sync</code> traits and
how we could use them with custom types.</p>
<a class="header" href="print.html#extensible-concurrency-with-the-sync-and-send-traits" id="extensible-concurrency-with-the-sync-and-send-traits"><h2>Extensible Concurrency with the <code>Sync</code> and <code>Send</code> Traits</h2></a>
<p>One interesting aspect of Rust's concurrency model is that the language knows
<em>very</em> little about concurrency. Almost everything we've been talking about so
far has been part of the standard library, not the language itself. Because we
don't need the language to provide everything we need to program in a
concurrent context, we're not limited to the concurrency options that the
standard library or language provide: we can write our own or use ones others
have written.</p>
<p>We said <em>almost</em> everything wasn't in the language, so what is? There are two
traits, both in <code>std::marker</code>: <code>Sync</code> and <code>Send</code>.</p>
<a class="header" href="print.html#send-for-indicating-ownership-may-be-transferred-to-another-thread" id="send-for-indicating-ownership-may-be-transferred-to-another-thread"><h3><code>Send</code> for Indicating Ownership May Be Transferred to Another Thread</h3></a>
<p>The <code>Send</code> marker trait indicates that ownership of that type may be
transferred between threads. Almost every Rust type is <code>Send</code>, but there are
some exceptions. One type provided by the standard library that is not <code>Send</code>
is <code>Rc&lt;T&gt;</code>: if we clone an <code>Rc&lt;T&gt;</code> value and try to transfer ownership of the
clone to another thread, both threads might update the reference count at the
same time. As we mentioned in the previous section, <code>Rc&lt;T&gt;</code> is implemented for
use in single-threaded situations where you don't want to pay the performance
penalty of having a threadsafe reference count.</p>
<p>Because <code>Rc&lt;T&gt;</code> is not marked <code>Send</code>, Rust's type system and trait bounds
ensure that we can never forget and accidentally send an <code>Rc&lt;T&gt;</code> value across
threads unsafely. We tried to do this in Listing 16-14, and we got an error
that said <code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>. When we
switched to <code>Arc&lt;T&gt;</code>, which is <code>Send</code>, the code compiled.</p>
<p>Any type that is composed entirely of <code>Send</code> types is automatically marked as
<code>Send</code> as well. Almost all primitive types are <code>Send</code>, aside from raw pointers,
which we'll discuss in Chapter 19. Most standard library types are <code>Send</code>,
aside from <code>Rc&lt;T&gt;</code>.</p>
<a class="header" href="print.html#sync-for-indicating-access-from-multiple-threads-is-safe" id="sync-for-indicating-access-from-multiple-threads-is-safe"><h3><code>Sync</code> for Indicating Access from Multiple Threads is Safe</h3></a>
<p>The <code>Sync</code> marker trait indicates that a type is safe to have references to a
value from multiple threads. Another way to say this is for any type <code>T</code>, <code>T</code>
is <code>Sync</code> if <code>&amp;T</code> (a reference to <code>T</code>) is <code>Send</code> so that the reference can be
sent safely to another thread. In a similar manner as <code>Send</code>, primitive types
are <code>Sync</code> and types composed entirely of types that are <code>Sync</code> are also <code>Sync</code>.</p>
<p><code>Rc&lt;T&gt;</code> is also not <code>Sync</code>, for the same reasons that it's not <code>Send</code>.
<code>RefCell&lt;T&gt;</code> (which we talked about in Chapter 15) and the family of related
<code>Cell&lt;T&gt;</code> types are not <code>Sync</code>. The implementation of the borrow checking at
runtime that <code>RefCell&lt;T&gt;</code> does is not threadsafe. <code>Mutex&lt;T&gt;</code> is <code>Sync</code>, and can
be used to share access with multiple threads as we saw in the previous section.</p>
<a class="header" href="print.html#implementing-send-and-sync-manually-is-unsafe" id="implementing-send-and-sync-manually-is-unsafe"><h3>Implementing <code>Send</code> and <code>Sync</code> Manually is Unsafe</h3></a>
<p>Usually, we don't need to implement the <code>Send</code> and <code>Sync</code> traits, since types
that are made up of <code>Send</code> and <code>Sync</code> traits are automatically also <code>Send</code> and
<code>Sync</code>. Because they're marker traits, they don't even have any methods to
implement. They're just useful for enforcing concurrency-related invariants.</p>
<p>Implementing the guarantees that these traits are markers for involves
implementing unsafe Rust code. We're going to be talking about using unsafe
Rust code in Chapter 19; for now, the important information is that building
new concurrent types that aren't made up of <code>Send</code> and <code>Sync</code> parts requires
careful thought to make sure the safety guarantees are upheld. <a href="https://doc.rust-lang.org/stable/nomicon/">The Nomicon</a>
has more information about these guarantees and how to uphold them.</p>
<a class="header" href="print.html#summary-8" id="summary-8"><h2>Summary</h2></a>
<p>This isn't the last time we'll see concurrency in this book; the project in
Chapter 20 will use these concepts in a more realistic situation than the
smaller examples we discussed in this chapter.</p>
<p>As we mentioned, since very little of how Rust deals with concurrency has to be
part of the language, there are many concurrency solutions implemented as
crates. These evolve more quickly than the standard library; search online for
the current state-of-the-art crates for use in multithreaded situations.</p>
<p>Rust provides channels for message passing and smart pointer types like
<code>Mutex&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code> that are safe to use in concurrent contexts. The type
system and the borrow checker will make sure the code we write using these
solutions won't have data races or invalid references. Once we get our code
compiling, we can rest assured that our code will happily run on multiple
threads without the kinds of hard-to-track-down bugs common in other
programming languages. Concurrent programming is no longer something to be
afraid of: go forth and make your programs concurrent, fearlessly!</p>
<p>Next, let's talk about idiomatic ways to model problems and structure solutions
as your Rust programs get bigger, and how Rust's idioms relate to those you
might be familiar with from Object Oriented Programming.</p>
<a class="header" href="print.html#is-rust-an-object-oriented-programming-language" id="is-rust-an-object-oriented-programming-language"><h1>Is Rust an Object-Oriented Programming Language?</h1></a>
<p>Object-Oriented Programming is a way of modeling programs that originated with
Simula in the 1960s and became popular with C++ in the 1990s. There are many
competing definitions for what OOP is: under some definitions, Rust is
object-oriented; under other definitions, Rust is not. In this chapter, we'll
explore some characteristics that are commonly considered to be object-oriented
and how those characteristics translate to idiomatic Rust.</p>
<a class="header" href="print.html#what-does-object-oriented-mean" id="what-does-object-oriented-mean"><h2>What Does Object-Oriented Mean?</h2></a>
<p>There isn't consensus in the programming community about the features a
language needs to have in order to be called object-oriented. Rust is
influenced by many different programming paradigms; we explored the features it
has that come from functional programming in Chapter 13. Some of the
characteristics that object-oriented programming languages tend to share are
objects, encapsulation, and inheritance. Let's take a look at what each of
those mean and whether Rust supports them.</p>
<a class="header" href="print.html#objects-contain-data-and-behavior" id="objects-contain-data-and-behavior"><h3>Objects Contain Data and Behavior</h3></a>
<p>The book &quot;Design Patterns: Elements of Reusable Object-Oriented Software,&quot;
colloquially referred to as &quot;The Gang of Four book,&quot; is a catalog of
object-oriented design patterns. It defines object-oriented programming in this
way:</p>
<blockquote>
<p>Object-oriented programs are made up of objects. An <em>object</em> packages both
data and the procedures that operate on that data. The procedures are
typically called <em>methods</em> or <em>operations</em>.</p>
</blockquote>
<p>Under this definition, then, Rust is object-oriented: structs and enums have
data and <code>impl</code> blocks provide methods on structs and enums. Even though
structs and enums with methods aren't <em>called</em> objects, they provide the same
functionality that objects do, using the Gang of Four's definition of objects.</p>
<a class="header" href="print.html#encapsulation-that-hides-implementation-details" id="encapsulation-that-hides-implementation-details"><h3>Encapsulation that Hides Implementation Details</h3></a>
<p>Another aspect commonly associated with object-oriented programming is the idea
of <em>encapsulation</em>: the implementation details of an object aren't accessible
to code using that object. The only way to interact with an object is through
the public API the object offers; code using the object should not be able to
reach into the object's internals and change data or behavior directly.
Encapsulation enables changing and refactoring an object's internals without
needing to change the code that uses the object.</p>
<p>As we discussed in Chapter 7, we can use the <code>pub</code> keyword to decide what
modules, types, functions, and methods in our code should be public, and by
default, everything is private. For example, we can define a struct
<code>AveragedCollection</code> that has a field containing a vector of <code>i32</code> values. The
struct can also have a field that knows the average of the values in the vector
so that whenever anyone wants to know the average of the values that the struct
has in its vector, we don't have to compute it on-demand. <code>AveragedCollection</code>
will cache the calculated average for us. Listing 17-1 has the definition of
the <code>AveragedCollection</code> struct:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-1: An <code>AveragedCollection</code> struct that
maintains a list of integers and the average of the items in the
collection.</span></p>
<p>Note that the struct itself is marked <code>pub</code> so that other code may use this
struct, but the fields within the struct remain private. This is important in
this case because we want to ensure that whenever a value is added or removed
from the list, we also update the average. We do this by implementing <code>add</code>,
<code>remove</code>, and <code>average</code> methods on the struct as shown in Listing 17-2:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct AveragedCollection {
#     list: Vec&lt;i32&gt;,
#     average: f64,
# }
impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            },
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-2: Implementations of the public methods
<code>add</code>, <code>remove</code>, and <code>average</code> on <code>AveragedCollection</code></span></p>
<p>The public methods <code>add</code>, <code>remove</code>, and <code>average</code> are the only way to modify an
instance of a <code>AveragedCollection</code>. When an item is added to <code>list</code> using the
<code>add</code> method or removed using the <code>remove</code> method, the implementations of those
methods call the private <code>update_average</code> method that takes care of updating
the <code>average</code> field as well. Because the <code>list</code> and <code>average</code> fields are
private, there's no way for external code to add or remove items to the <code>list</code>
field directly, which could cause the <code>average</code> field to get out of sync. The
<code>average</code> method returns the value in the <code>average</code> field, which allows
external code to read the <code>average</code> but not modify it.</p>
<p>Because we've encapsulated the implementation details of <code>AveragedCollection</code>,
we can easily change aspects like the data structure in the future. For
instance, we could use a <code>HashSet</code> instead of a <code>Vec</code> for the <code>list</code> field. As
long as the signatures of the <code>add</code>, <code>remove</code>, and <code>average</code> public methods
stay the same, code using <code>AveragedCollection</code> wouldn't need to change. This
wouldn't necessarily be the case if we exposed <code>list</code> to external code:
<code>HashSet</code> and <code>Vec</code> have different methods for adding and removing items, so
the external code would likely have to change if it was modifying <code>list</code>
directly.</p>
<p>If encapsulation is a required aspect for a language to be considered
object-oriented, then Rust meets that requirement. Using <code>pub</code> or not for
different parts of code enables encapsulation of implementation details.</p>
<a class="header" href="print.html#inheritance-as-a-type-system-and-as-code-sharing" id="inheritance-as-a-type-system-and-as-code-sharing"><h3>Inheritance as a Type System and as Code Sharing</h3></a>
<p><em>Inheritance</em> is a mechanism that some programming languages provide whereby an
object can be defined to inherit from another object's definition, thus gaining
the parent object's data and behavior without having to define those again.
Inheritance is a characteristic that is part of some people's definitions of
what an OOP language is.</p>
<p>If a language must have inheritance to be an object-oriented language, then
Rust is not object-oriented. There is not a way to define a struct that
inherits from another struct in order to gain the parent struct's fields and
method implementations. However, if you're used to having inheritance in your
programming toolbox, there are other solutions in Rust depending on the reason
you want to use inheritance.</p>
<p>There are two main reasons to reach for inheritance. The first is to be able to
re-use code: once a particular behavior is implemented for one type,
inheritance can enable re-using that implementation for a different type. Rust
code can be shared using default trait method implementations instead, which we
saw in Listing 10-14 when we added a default implementation of the <code>summary</code>
method on the <code>Summarizable</code> trait. Any type implementing the <code>Summarizable</code>
trait would have the <code>summary</code> method available on it without any further code.
This is similar to a parent class having an implementation of a method, and a
child class inheriting from the parent class also having the implementation of
the method due to the inheritance. We can also choose to override the default
implementation of the <code>summary</code> method when we implement the <code>Summarizable</code>
trait, which is similar to a child class overriding the implementation of a
method inherited from a parent class.</p>
<p>The second reason to use inheritance is with the type system: to express that a
child type can be used in the same places that the parent type can be used.
This is also called <em>polymorphism</em>, which means that multiple objects can be
substituted for each other at runtime if they have the same shape.</p>
<!-- PROD: START BOX -->
<blockquote>
<p>While many people use &quot;polymorphism&quot; to describe inheritance, it's actually
a specific kind of polymorphism, called &quot;sub-type polymorphism.&quot; There are
other forms as well; a generic parameter with a trait bound in Rust is
also polymorphism, more specifically &quot;parametric polymorphism.&quot; The exact
details between the different kinds of polymorphism aren't crucial here,
so don't worry too much about the details: just know that Rust has multiple
polymorphism-related features, unlike many OOP languages.</p>
</blockquote>
<!-- PROD: END BOX -->
<p>To support this sort of pattern, Rust has <em>trait objects</em> so that we can
specify that we would like values of any type, as long as the values implement
a particular trait.</p>
<p>Inheritance has recently fallen out of favor as a programming design solution
in many programming languages. Using inheritance to re-use some code can
require more code to be shared than you actually need. Subclasses shouldn't
always share all characteristics of their parent class, but inheritance means
the subclass gets all of its parent's data and behavior. This can make a
program's design less flexible, and creates the possibility of calling methods
on subclasses that don't make sense or cause errors since the methods don't
apply to the subclass but must be inherited from the parent class. In addition,
some languages only allow a subclass to inherit from one class, further
restricting the flexibility of a program's design.</p>
<p>For these reasons, Rust chose to take a different approach with trait objects
instead of inheritance. Let's take a look at how trait objects enable
polymorphism in Rust.</p>
<a class="header" href="print.html#trait-objects-for-using-values-of-different-types" id="trait-objects-for-using-values-of-different-types"><h2>Trait Objects for Using Values of Different Types</h2></a>
<p>In Chapter 8, we said that a limitation of vectors is that vectors can only
store elements of one type. We had an example in Listing 8-1 where we defined a
<code>SpreadsheetCell</code> enum that had variants to hold integers, floats, and text so
that we could store different types of data in each cell and still have a
vector represent a row of cells. This works for cases in which the kinds of
things we want to be able to treat interchangeably are a fixed set of types that
we know when our code gets compiled.</p>
<!-- The code example I want to reference did not have a listing number; it's
the one with SpreadsheetCell. I will go back and add Listing 8-1 next time I
get Chapter 8 for editing. /Carol -->
<p>Sometimes we want the set of types that we use to be extensible by the
programmers who use our library. For example, many Graphical User Interface
tools have a concept of a list of items that get drawn on the screen by
iterating through the list and calling a <code>draw</code> method on each of the items.
We're going to create a library crate containing the structure of a GUI library
called <code>rust_gui</code>. Our GUI library could include some types for people to use,
such as <code>Button</code> or <code>TextField</code>. Programmers that use <code>rust_gui</code> will want to
create more types that can be drawn on the screen: one programmer might add an
<code>Image</code>, while another might add a <code>SelectBox</code>. We're not going to implement a
fully-fledged GUI library in this chapter, but we will show how the pieces
would fit together.</p>
<p>When we're writing the <code>rust_gui</code> library, we don't know all the types that
other programmers will want to create, so we can't define an <code>enum</code> containing
all the types. What we do know is that <code>rust_gui</code> needs to be able to keep
track of a bunch of values of all these different types, and it needs to be
able to call a <code>draw</code> method on each of these values. Our GUI library doesn't
need to know what will happen exactly when we call the <code>draw</code> method, just that
the value will have that method available for us to call.</p>
<p>In a language with inheritance, we might define a class named <code>Component</code> that
has a method named <code>draw</code> on it. The other classes like <code>Button</code>, <code>Image</code>, and
<code>SelectBox</code> would inherit from <code>Component</code> and thus inherit the <code>draw</code> method.
They could each override the <code>draw</code> method to define their custom behavior, but
the framework could treat all of the types as if they were <code>Component</code>
instances and call <code>draw</code> on them.</p>
<a class="header" href="print.html#defining-a-trait-for-the-common-behavior" id="defining-a-trait-for-the-common-behavior"><h3>Defining a Trait for the Common Behavior</h3></a>
<p>In Rust, though, we can define a trait that we'll name <code>Draw</code> and that will
have one method named <code>draw</code>. Then we can define a vector that takes a <em>trait
object</em>, which is a trait behind some sort of pointer, such as a <code>&amp;</code> reference
or a <code>Box&lt;T&gt;</code> smart pointer. We'll talk about the reason trait objects have to
be behind a pointer in Chapter 19.</p>
<p>We mentioned that we don't call structs and enums &quot;objects&quot; to distinguish
structs and enums from other languages' objects. The data in the struct or enum
fields and the behavior in <code>impl</code> blocks is separated, as opposed to other
languages that have data and behavior combined into one concept called an
object. Trait objects <em>are</em> more like objects in other languages, in the sense
that they combine the data made up of the pointer to a concrete object with the
behavior of the methods defined in the trait. However, trait objects are
different from objects in other languages because we can't add data to a trait
object. Trait objects aren't as generally useful as objects in other languages:
their purpose is to allow abstraction across common behavior.</p>
<p>A trait defines behavior that we need in a given situation. We can then use a
trait as a trait object in places where we would use a concrete type or a
generic type. Rust's type system will ensure that any value we substitute in
for the trait object will implement the methods of the trait. Then we don't
need to know all the possible types at compile time, and we can treat all the
instances the same way. Listing 17-3 shows how to define a trait named <code>Draw</code>
with one method named <code>draw</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Draw {
    fn draw(&amp;self);
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-3: Definition of the <code>Draw</code> trait</span></p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>This should look familiar since we talked about how to define traits in
Chapter 10. Next comes something new: Listing 17-4 has the definition of a
struct named <code>Screen</code> that holds a vector named <code>components</code> that are of type
<code>Box&lt;Draw&gt;</code>. That <code>Box&lt;Draw&gt;</code> is a trait object: it's a stand-in for any type
inside a <code>Box</code> that implements the <code>Draw</code> trait.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Screen {
    pub components: Vec&lt;Box&lt;Draw&gt;&gt;,
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-4: Definition of the <code>Screen</code> struct with a
<code>components</code> field that holds a vector of trait objects that implement the
<code>Draw</code> trait</span></p>
<p>On the <code>Screen</code> struct, we'll define a method named <code>run</code>, which will call the
<code>draw</code> method on each of its <code>components</code> as shown in Listing 17-5:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
# pub struct Screen {
#     pub components: Vec&lt;Box&lt;Draw&gt;&gt;,
# }
#
impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-5: Implementing a <code>run</code> method on <code>Screen</code>
that calls the <code>draw</code> method on each component</span></p>
<p>This is different than defining a struct that uses a generic type parameter
with trait bounds. A generic type parameter can only be substituted with one
concrete type at a time, while trait objects allow for multiple concrete types
to fill in for the trait object at runtime. For example, we could have defined
the <code>Screen</code> struct using a generic type and a trait bound as in Listing 17-6:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
    where T: Draw {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-6: An alternate implementation of the <code>Screen</code>
struct and its <code>run</code> method using generics and trait bounds</span></p>
<p>This only lets us have a <code>Screen</code> instance that has a list of components that
are all of type <code>Button</code> or all of type <code>TextField</code>. If you'll only ever have
homogeneous collections, using generics and trait bounds is preferable since
the definitions will be monomorphized at compile time to use the concrete types.</p>
<p>With the definition of <code>Screen</code> that holds a component list of trait objects in
<code>Vec&lt;Box&lt;Draw&gt;&gt;</code> instead, one <code>Screen</code> instance can hold a <code>Vec</code> that contains
a <code>Box&lt;Button&gt;</code> as well as a <code>Box&lt;TextField&gt;</code>. Let's see how that works, and
then talk about the runtime performance implications.</p>
<a class="header" href="print.html#implementations-of-the-trait-from-us-or-library-users" id="implementations-of-the-trait-from-us-or-library-users"><h3>Implementations of the Trait from Us or Library Users</h3></a>
<p>Now to add some types that implement the <code>Draw</code> trait. We're going to provide
the <code>Button</code> type, and again, actually implementing a GUI library is out of
scope of this book, so the <code>draw</code> method won't have any useful implementation
in its body. To imagine what the implementation might look like, a <code>Button</code>
struct might have fields for <code>width</code>, <code>height</code>, and <code>label</code>, as shown in
Listing 17-7:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // Code to actually draw a button
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-7: A <code>Button</code> struct that implements the
<code>Draw</code> trait</span></p>
<p>The <code>width</code>, <code>height</code>, and <code>label</code> fields on <code>Button</code> will differ from other
components, such as a <code>TextField</code> type that might have <code>width</code>, <code>height</code>,
<code>label</code>, and <code>placeholder</code> fields instead. Each of the types that we want to be
able to draw on the screen will implement the <code>Draw</code> trait with different code
in the <code>draw</code> method that defines how to draw that type like <code>Button</code> has here
(without any actual GUI code that's out of scope of this chapter). In addition
to implementing the <code>Draw</code> trait, <code>Button</code> might also have another <code>impl</code> block
containing methods having to do with what happens if the button is clicked.
These kinds of methods won't apply to types like <code>TextField</code>.</p>
<p>Someone using our library has decided to implement a <code>SelectBox</code> struct that
has <code>width</code>, <code>height</code>, and <code>options</code> fields. They implement the <code>Draw</code> trait on
the <code>SelectBox</code> type as well, as shown in Listing 17-8:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rust_gui;
use rust_gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // Code to actually draw a select box
    }
}
</code></pre>
<p><span class="caption">Listing 17-8: Another crate using <code>rust_gui</code> and
implementing the <code>Draw</code> trait on a <code>SelectBox</code> struct</span></p>
<p>The user of our library can now write their <code>main</code> function to create a
<code>Screen</code> instance and add a <code>SelectBox</code> and a <code>Button</code> to the screen by putting
each in a <code>Box&lt;T&gt;</code> to become a trait object. They can then call the <code>run</code>
method on the <code>Screen</code> instance, which will call <code>draw</code> on each of the
components. Listing 17-9 shows this implementation:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rust_gui::{Screen, Button};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;)
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">Listing 17-9: Using trait objects to store values of
different types that implement the same trait</span></p>
<p>Even though we didn't know that someone would add the <code>SelectBox</code> type someday,
our <code>Screen</code> implementation was able to operate on the <code>SelectBox</code> and draw it
because <code>SelectBox</code> implements the <code>Draw</code> type, which means it implements the
<code>draw</code> method.</p>
<p>Only being concerned with the messages a value responds to, rather than the
value's concrete type, is similar to a concept called <em>duck typing</em> in
dynamically typed languages: if it walks like a duck, and quacks like a duck,
then it must be a duck! In the implementation of <code>run</code> on <code>Screen</code> in Listing
17-5, <code>run</code> doesn't need to know what the concrete type of each component is.
It doesn't check to see if a component is an instance of a <code>Button</code> or a
<code>SelectBox</code>, it just calls the <code>draw</code> method on the component. By specifying
<code>Box&lt;Draw&gt;</code> as the type of the values in the <code>components</code> vector, we've defined
that <code>Screen</code> needs values that we can call the <code>draw</code> method on.</p>
<p>The advantage with using trait objects and Rust's type system to do duck typing
is that we never have to check that a value implements a particular method at
runtime or worry about getting errors if a value doesn't implement a method but
we call it. Rust won't compile our code if the values don't implement the
traits that the trait objects need.</p>
<p>For example, Listing 17-10 shows what happens if we try to create a <code>Screen</code>
with a <code>String</code> as a component:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rust_gui;
use rust_gui::Draw;

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(String::from(&quot;Hi&quot;)),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">Listing 17-10: Attempting to use a type that doesn't
implement the trait object's trait</span></p>
<p>We'll get this error because <code>String</code> doesn't implement the <code>Draw</code> trait:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: Draw` is not satisfied
  --&gt;
   |
 4 |             Box::new(String::from(&quot;Hi&quot;)),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not
   implemented for `std::string::String`
   |
   = note: required for the cast to the object type `Draw`
</code></pre>
<p>This lets us know that either we're passing something we didn't mean to pass to
<code>Screen</code> and we should pass a different type, or we should implement <code>Draw</code> on
<code>String</code> so that <code>Screen</code> is able to call <code>draw</code> on it.</p>
<a class="header" href="print.html#trait-objects-perform-dynamic-dispatch" id="trait-objects-perform-dynamic-dispatch"><h3>Trait Objects Perform Dynamic Dispatch</h3></a>
<p>Recall in Chapter 10 when we discussed the process of monomorphization that the
compiler performs when we use trait bounds on generics: the compiler generates
non-generic implementations of functions and methods for each concrete type
that we use in place of a generic type parameter. The code that results from
monomorphization is doing <em>static dispatch</em>: when the method is called, the
code that goes with that method call has been determined at compile time, and
looking up that code is very fast.</p>
<p>When we use trait objects, the compiler can't perform monomorphization because
we don't know all the types that might be used with the code. Instead, Rust
keeps track of the code that might be used when a method is called and figures
out at runtime which code needs to be used for a particular method call. This
is known as <em>dynamic dispatch</em>, and there's a runtime cost when this lookup
happens. Dynamic dispatch also prevents the compiler from choosing to inline a
method's code, which prevents some optimizations. We did get extra flexibility
in the code that we wrote and were able to support, though, so it's a tradeoff
to consider.</p>
<a class="header" href="print.html#object-safety-is-required-for-trait-objects" id="object-safety-is-required-for-trait-objects"><h3>Object Safety is Required for Trait Objects</h3></a>
<!-- Liz: we're conflicted on including this section. Not being able to use a
trait as a trait object because of object safety is something that
beginner/intermediate Rust developers run into sometimes, but explaining it
fully is long and complicated. Should we just cut this whole section? Leave it
(and finish the explanation of how to fix the error at the end)? Shorten it to
a quick caveat, that just says something like "Some traits can't be trait
objects. Clone is an example of one. You'll get errors that will let you know
if a trait can't be a trait object, look up object safety if you're interested
in the details"? Thanks! /Carol -->
<p>Not all traits can be made into trait objects; only <em>object safe</em> traits can. A
trait is object safe as long as both of the following are true:</p>
<ul>
<li>The trait does not require <code>Self</code> to be <code>Sized</code></li>
<li>All of the trait's methods are object safe.</li>
</ul>
<p><code>Self</code> is a keyword that is an alias for the type that we're implementing
traits or methods on. <code>Sized</code> is a marker trait like the <code>Send</code> and <code>Sync</code>
traits that we talked about in Chapter 16. <code>Sized</code> is automatically implemented
on types that have a known size at compile time, such as <code>i32</code> and references.
Types that do not have a known size include slices (<code>[T]</code>) and trait objects.</p>
<p><code>Sized</code> is an implicit trait bound on all generic type parameters by default.
Most useful operations in Rust require a type to be <code>Sized</code>, so making <code>Sized</code>
a default requirement on trait bounds means we don't have to write <code>T: Sized</code>
with most every use of generics. If we want to be able to use a trait on
slices, however, we need to opt out of the <code>Sized</code> trait bound, and we can do
that by specifying <code>T: ?Sized</code> as a trait bound.</p>
<p>Traits have a default bound of <code>Self: ?Sized</code>, which means that they can be
implemented on types that may or may not be <code>Sized</code>. If we create a trait <code>Foo</code>
that opts out of the <code>Self: ?Sized</code> bound, that would look like the following:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo: Sized {
    fn some_method(&amp;self);
}
#}</code></pre></pre>
<p>The trait <code>Sized</code> is now a <em>supertrait</em> of trait <code>Foo</code>, which means trait <code>Foo</code>
requires types that implement <code>Foo</code> (that is, <code>Self</code>) to be <code>Sized</code>. We're
going to talk about supertraits in more detail in Chapter 19.</p>
<p>The reason a trait like <code>Foo</code> that requires <code>Self</code> to be <code>Sized</code> is not allowed
to be a trait object is that it would be impossible to implement the trait
<code>Foo</code> for the trait object <code>Foo</code>: trait objects aren't sized, but <code>Foo</code>
requires <code>Self</code> to be <code>Sized</code>. A type can't be both sized and unsized at the
same time!</p>
<p>For the second object safety requirement that says all of a trait's methods
must be object safe, a method is object safe if either:</p>
<ul>
<li>It requires <code>Self</code> to be <code>Sized</code> or</li>
<li>It meets all three of the following:
<ul>
<li>It must not have any generic type parameters</li>
<li>Its first argument must be of type <code>Self</code> or a type that dereferences to
the Self type (that is, it must be a method rather than an associated
function and have <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code> as the first argument)</li>
<li>It must not use <code>Self</code> anywhere else in the signature except for the
first argument</li>
</ul>
</li>
</ul>
<p>Those rules are a bit formal, but think of it this way: if your method requires
the concrete <code>Self</code> type somewhere in its signature, but an object forgets the
exact type that it is, there's no way that the method can use the original
concrete type that it's forgotten. Same with generic type parameters that are
filled in with concrete type parameters when the trait is used: the concrete
types become part of the type that implements the trait. When the type is
erased by the use of a trait object, there's no way to know what types to fill
in the generic type parameters with.</p>
<p>An example of a trait whose methods are not object safe is the standard
library's <code>Clone</code> trait. The signature for the <code>clone</code> method in the <code>Clone</code>
trait looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
#}</code></pre></pre>
<p><code>String</code> implements the <code>Clone</code> trait, and when we call the <code>clone</code> method on
an instance of <code>String</code> we get back an instance of <code>String</code>. Similarly, if we
call <code>clone</code> on an instance of <code>Vec</code>, we get back an instance of <code>Vec</code>. The
signature of <code>clone</code> needs to know what type will stand in for <code>Self</code>, since
that's the return type.</p>
<p>If we try to implement <code>Clone</code> on a trait like the <code>Draw</code> trait from Listing
17-3, we wouldn't know whether <code>Self</code> would end up being a <code>Button</code>, a
<code>SelectBox</code>, or some other type that will implement the <code>Draw</code> trait in the
future.</p>
<p>The compiler will tell you if you're trying to do something that violates the
rules of object safety in regards to trait objects. For example, if we had
tried to implement the <code>Screen</code> struct in Listing 17-4 to hold types that
implement the <code>Clone</code> trait instead of the <code>Draw</code> trait, like this:</p>
<pre><code class="language-rust ignore">pub struct Screen {
    pub components: Vec&lt;Box&lt;Clone&gt;&gt;,
}
</code></pre>
<p>We'll get this error:</p>
<pre><code class="language-text">error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --&gt;
  |
2 |     pub components: Vec&lt;Box&lt;Clone&gt;&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be
  made into an object
  |
  = note: the trait cannot require that `Self : Sized`
</code></pre>
<!-- If we are including this section, we would explain how to fix this
problem. It involves adding another trait and implementing Clone manually for
that trait. Because this section is getting long, I stopped because it feels
like we're off in the weeds with an esoteric detail that not everyone will need
to know about. /Carol -->
<a class="header" href="print.html#object-oriented-design-pattern-implementation" id="object-oriented-design-pattern-implementation"><h2>Object-Oriented Design Pattern Implementation</h2></a>
<p>Let's look at an example of the state design pattern and how to use it in Rust.
The <em>state pattern</em> is when a value has some internal state, and the value's
behavior changes based on the internal state. The internal state is represented
by a set of objects that inherit shared functionality (we'll use structs and
traits since Rust doesn't have objects and inheritance). Each state object is
responsible for its own behavior and the rules for when it should change into
another state. The value that holds one of these state objects doesn't know
anything about the different behavior of the states or when to transition
between states. In the future when requirements change, we won't need to change
the code of the value holding the state or the code that uses the value. We'll
only need to update the code inside one of the state objects to change its
rules, or perhaps add more state objects.</p>
<p>In order to explore this idea, we're going to implement a blog post workflow in
an incremental way. The workflow that we want our blog posts to follow, once
we're done with the implementation, is:</p>
<ol>
<li>A blog post starts as an empty draft.</li>
<li>Once the draft is done, we request a review of the post.</li>
<li>Once the post is approved, it gets published.</li>
<li>Only published blog posts return content to print so that we can't
accidentally print the text of a post that hasn't been approved.</li>
</ol>
<p>Any other changes attempted on a post should have no effect. For example, if we
try to approve a draft blog post before we've requested a review, the post
should stay an unpublished draft.</p>
<p>Listing 17-11 shows this workflow in code form. This is an example usage of the
API we're going to implement in a library crate named <code>blog</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">Listing 17-11: Code that demonstrates the desired
behavior we want our <code>blog</code> crate to have</span></p>
<p>We want to be able to create a new draft blog post with <code>Post::new</code>. Then, we
want to add some text to the blog post while we're in the draft state. If we
try to print out the post's content immediately, though, we shouldn't get any
text, since the post is still a draft. We've added an <code>assert_eq!</code> here for
demonstration purposes. Asserting that a draft blog post returns an empty
string from the <code>content</code> method would make an excellent unit test in our
library, but we're not going to write tests for this example.</p>
<p>Next, we want to be able to request a review of our post, and <code>content</code> should
still return an empty string while waiting for a review. Lastly, when we
approve the blog post, it should get published, which means the text we added
will be returned when we call <code>content</code>.</p>
<p>Notice that the only type we're interacting with from the crate is the <code>Post</code>
type. The various states a post can be in (draft, waiting for review,
published) are managed internally to the <code>Post</code> type. The states change due to
the methods we call on the <code>Post</code> instance, but we don't have to manage the
state changes directly. This also means we won't make a mistake with the
states, like forgetting to request a review before publishing.</p>
<a class="header" href="print.html#defining-post-and-creating-a-new-instance-in-the-draft-state" id="defining-post-and-creating-a-new-instance-in-the-draft-state"><h3>Defining <code>Post</code> and Creating a New Instance in the Draft State</h3></a>
<p>Let's get started on the implementation of the library! We know we want to have
a public <code>Post</code> struct that holds some content, so let's start with the
definition of the struct and an associated public <code>new</code> function to create an
instance of <code>Post</code> as shown in Listing 17-12. We're also going to have a
private trait <code>State</code>. <code>Post</code> will hold a trait object of <code>Box&lt;State&gt;</code> inside
an <code>Option</code> in a private field named <code>state</code>. We'll see why the <code>Option</code> is
necessary in a bit. The <code>State</code> trait defines all the behavior different post
states share, and the <code>Draft</code>, <code>PendingReview</code>, and <code>Published</code> states will all
implement the <code>State</code> trait. For now, the trait does not have any methods, and
we're going to start by defining just the <code>Draft</code> state since that's the state
we want to start in:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Post {
    state: Option&lt;Box&lt;State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
#}</code></pre></pre>
<p><span class="caption">Listing 17-12: Definition of a <code>Post</code> struct and a <code>new</code>
function that creates a new <code>Post</code> instance, a <code>State</code> trait, and a <code>Draft</code>
struct that implements <code>State</code></span></p>
<p>When we create a new <code>Post</code>, we set its <code>state</code> field to a <code>Some</code> value holding
a <code>Box</code> pointing to a new instance of the <code>Draft</code> struct. This ensures whenever
we create a new instance of <code>Post</code>, it'll start out as a draft. Because the
<code>state</code> field of <code>Post</code> is private, there's no way to create a <code>Post</code> in any
other state!</p>
<a class="header" href="print.html#storing-the-text-of-the-post-content" id="storing-the-text-of-the-post-content"><h3>Storing the Text of the Post Content</h3></a>
<p>In the <code>Post::new</code> function, we set the <code>content</code> field to a new, empty
<code>String</code>. In Listing 17-11, we showed that we want to be able to call a method
named <code>add_text</code> and pass a <code>&amp;str</code> to it to add that text to the content of the
blog post. We're choosing to implement this as a method rather than exposing
the <code>content</code> field as <code>pub</code> because we want to be able to control how the
<code>content</code> field's data is read by implementing a method later. The <code>add_text</code>
method is pretty straightforward though, let's add the implementation in
Listing 17-13 to the <code>impl Post</code> block:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String,
# }
#
impl Post {
    // ...snip...
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-13: Implementing the <code>add_text</code> method to add
text to a post's <code>content</code></span></p>
<p><code>add_text</code> takes a mutable reference to <code>self</code>, since we're changing the <code>Post</code>
instance that we're calling <code>add_text</code> on. We then call <code>push_str</code> on the
<code>String</code> in <code>content</code> and pass the <code>text</code> argument to add to the saved
<code>content</code>. This isn't part of the state pattern since its behavior doesn't
depend on the state that the post is in. The <code>add_text</code> method doesn't interact
with the <code>state</code> field at all, but it is part of the behavior we want to
support.</p>
<a class="header" href="print.html#content-of-a-draft-post-is-empty" id="content-of-a-draft-post-is-empty"><h3>Content of a Draft Post is Empty</h3></a>
<p>After we've called <code>add_text</code> and added some content to our post, we still want
the <code>content</code> method to return an empty string slice since the post is still in
the draft state, as shown on line 8 of Listing 17-11. For now, let's implement
the <code>content</code> method with the simplest thing that will fulfill this requirement:
always returning an empty string slice. We're going to change this later once
we implement the ability to change a post's state to be published. With what we
have so far, though, posts can only be in the draft state, which means the post
content should always be empty. Listing 17-14 shows this placeholder
implementation:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String,
# }
#
impl Post {
    // ...snip...
    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-14: Adding a placeholder implementation for
the <code>content</code> method on <code>Post</code> that always returns an empty string slice</span></p>
<p>With this added <code>content</code> method, everything in Listing 17-11 up to line 8
works as we intend.</p>
<a class="header" href="print.html#requesting-a-review-of-the-post-changes-its-state" id="requesting-a-review-of-the-post-changes-its-state"><h3>Requesting a Review of the Post Changes its State</h3></a>
<p>Next up is requesting a review of a post, which should change its state from
<code>Draft</code> to <code>PendingReview</code>. We want <code>post</code> to have a public method named
<code>request_review</code> that will take a mutable reference to <code>self</code>. Then we're going
to call an internal <code>request_review</code> method on the state that we're holding, and
this second <code>request_review</code> method will consume the current state and return a
new state. In order to be able to consume the old state, the second <code>request_review</code>
method needs to take ownership of the state value. This is where the <code>Option</code> comes
in: we're going to <code>take</code> the <code>Some</code> value out of the <code>state</code> field and leave a
<code>None</code> in its place since Rust doesn't let us have unpopulated fields in
structs. Then we'll set the post's <code>state</code> value to the result of this
operation. Listing 17-15 shows this code:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     state: Option&lt;Box&lt;State&gt;&gt;,
#     content: String,
# }
#
impl Post {
    // ...snip...
    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-15: Implementing <code>request_review</code> methods on
<code>Post</code> and the <code>State</code> trait</span></p>
<p>We've added the <code>request_review</code> method to the <code>State</code> trait; all types that
implement the trait will now need to implement the <code>request_review</code> method.
Note that rather than having <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code> as the first
parameter of the method, we have <code>self: Box&lt;Self&gt;</code>. This syntax means the
method is only valid when called on a <code>Box</code> holding the type. This syntax takes
ownership of <code>Box&lt;Self&gt;</code>, which is what we want because we're transforming the
old state into a new state, and we want the old state to no longer be valid.</p>
<p>The implementation for the <code>request_review</code> method on <code>Draft</code> is to return a
new, boxed instance of the <code>PendingReview</code> struct, which is a new type we've
introduced that represents the state when a post is waiting for a review. The
<code>PendingReview</code> struct also implements the <code>request_review</code> method, but it
doesn't do any transformations. It returns itself since requesting a review on
a post that's already in the <code>PendingReview</code> state should stay in the
<code>PendingReview</code> state.</p>
<p>Now we can start seeing the advantages of the state pattern: the
<code>request_review</code> method on <code>Post</code> is the same no matter what its <code>state</code> value
is. Each state is responsible for its own rules.</p>
<p>We're going to leave the <code>content</code> method on <code>Post</code> as it is, returning an
empty string slice. We can now have a <code>Post</code> in the <code>PendingReview</code> state, not
just the <code>Draft</code> state, but we want the same behavior in the <code>PendingReview</code>
state. Listing 17-11 now works up until line 11!</p>
<a class="header" href="print.html#approving-a-post-changes-the-behavior-of-content" id="approving-a-post-changes-the-behavior-of-content"><h3>Approving a Post Changes the Behavior of <code>content</code></h3></a>
<p>The <code>approve</code> method on <code>Post</code> will be similar to that of the <code>request_review</code>
method: it will set the <code>state</code> to the value that the current state says it
should have when that state is approved. We'll need to add the <code>approve</code> method
to the <code>State</code> trait, and we'll add a new struct that implements <code>State</code>, the
<code>Published</code> state. Listing 17-16 shows the new code:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     state: Option&lt;Box&lt;State&gt;&gt;,
#     content: String,
# }
#
impl Post {
    // ...snip...
    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
}

struct Draft {}

impl State for Draft {
#     fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
#         Box::new(PendingReview {})
#     }
#
    // ...snip...
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
#     fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
#         Box::new(PendingReview {})
#     }
#
    // ...snip...
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-16: Implementing the <code>approve</code> method on
<code>Post</code> and the <code>State</code> trait</span></p>
<p>Similarly to <code>request_review</code>, if we call the <code>approve</code> method on a <code>Draft</code>, it
will have no effect since it will return <code>self</code>. When we call <code>approve</code> on
<code>PendingReview</code>, it returns a new, boxed instance of the <code>Published</code> struct.
The <code>Published</code> struct implements the <code>State</code> trait, and for both the
<code>request_review</code> method and the <code>approve</code> method, it returns itself since the
post should stay in the <code>Published</code> state in those cases.</p>
<p>Now for updating the <code>content</code> method on <code>Post</code>: we want to return the value in
the post's <code>content</code> field if its state is <code>Published</code>, otherwise we want to
return an empty string slice. Because the goal is to keep all the rules like
this in the structs that implement <code>State</code>, we're going to call a <code>content</code>
method on the value in <code>state</code> and pass the post instance (that is, <code>self</code>) as
an argument. Then we'll return the value returned from the <code>content</code> method on
the <code>state</code> value as shown in Listing 17-17:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait State {
#     fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str;
# }
# pub struct Post {
#     state: Option&lt;Box&lt;State&gt;&gt;,
#     content: String,
# }
#
impl Post {
    // ...snip...
    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(&amp;self)
    }
    // ...snip...
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-17: Updating the <code>content</code> method on <code>Post</code> to
delegate to a <code>content</code> method on <code>State</code></span></p>
<p>We're calling the <code>as_ref</code> method on the <code>Option</code> because we want a reference
to the value inside the <code>Option</code>. We're then calling the <code>unwrap</code> method, which
we know will never panic because all the methods on <code>Post</code> ensure that the
<code>state</code> value will have a <code>Some</code> value in it when those methods are done. This
is one of the cases we talked about in Chapter 12 where we know that a <code>None</code>
value is never possible even though the compiler isn't able to understand that.</p>
<p>The <code>content</code> method on the <code>State</code> trait is where the logic for what content
to return will be. We're going to add a default implementation for the
<code>content</code> method that returns an empty string slice. That lets us not need to
implement <code>content</code> on the <code>Draft</code> and <code>PendingReview</code> structs. The <code>Published</code>
struct will override the <code>content</code> method and will return the value in
<code>post.content</code>, as shown in Listing 17-18:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String
# }
trait State {
    // ...snip...
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// ...snip...
struct Published {}

impl State for Published {
    // ...snip...
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-18: Adding the <code>content</code> method to the <code>State</code>
trait</span></p>
<p>Note that we need lifetime annotations on this method, like we discussed in
Chapter 10. We're taking a reference to a <code>post</code> as an argument, and we're
returning a reference to a part of that <code>post</code>, so the lifetime of the returned
reference is related to the lifetime of the <code>post</code> argument.</p>
<a class="header" href="print.html#tradeoffs-of-the-state-pattern" id="tradeoffs-of-the-state-pattern"><h3>Tradeoffs of the State Pattern</h3></a>
<p>We've shown that Rust is capable of implementing the object-oriented state
pattern in order to encapsulate the different kinds of behavior that a post
should have that depends on the state that the post is in. The methods on
<code>Post</code> don't know anything about the different kinds of behavior. The way this
code is organized, we have one place to look in order to find out all the
different ways that a published post behaves: the implementation of the <code>State</code>
trait on the <code>Published</code> struct.</p>
<p>An alternative implementation that didn't use the state pattern might have
<code>match</code> statements in the methods on <code>Post</code> or even in the code that uses
<code>Post</code> (<code>main</code> in our case) that checks what the state of the post is and
changes behavior in those places instead. That would mean we'd have a lot of
places to look in order to understand all the implications of a post being in
the published state! This would get worse the more states we added: each of
those <code>match</code> statements would need another arm. With the state pattern, the
<code>Post</code> methods and the places we use <code>Post</code> don't need <code>match</code> statements and
adding a new state only involves adding a new <code>struct</code> and implementing the
trait methods on that one struct.</p>
<p>This implementation is easy to extend to add more functionality. Here are some
changes you can try making to the code in this section to see for yourself what
it's like to maintain code using this pattern over time:</p>
<ul>
<li>Only allow adding text content when a post is in the <code>Draft</code> state</li>
<li>Add a <code>reject</code> method that changes the post's state from <code>PendingReview</code> back
to <code>Draft</code></li>
<li>Require two calls to <code>approve</code> before changing the state to <code>Published</code></li>
</ul>
<p>A downside of the state pattern is that since the states implement the
transitions between the states, some of the states are coupled to each other.
If we add another state between <code>PendingReview</code> and <code>Published</code>, such as
<code>Scheduled</code>, we would have to change the code in <code>PendingReview</code> to transition
to <code>Scheduled</code> instead. It would be nicer if <code>PendingReview</code> wouldn't need to
change because of the addition of a new state, but that would mean switching to
another design pattern.</p>
<p>There are a few bits of duplicated logic that are a downside of this
implementation in Rust. It would be nice if we could make default
implementations for the <code>request_review</code> and <code>approve</code> methods on the <code>State</code>
trait that return <code>self</code>, but this would violate object safety since the trait
doesn't know what the concrete <code>self</code> will be exactly. We want to be able to
use <code>State</code> as a trait object, so we need its methods to be object safe.</p>
<p>The other duplication that would be nice to get rid of is the similar
implementations of the <code>request_review</code> and <code>approve</code> methods on <code>Post</code>. They
both delegate to the implementation of the same method on the value in the
<code>Option</code> in the <code>state</code> field, and set the new value of the <code>state</code> field to
the result. If we had a lot of methods on <code>Post</code> that followed this pattern, we
might consider defining a macro to eliminate the repetition (see Appendix E on
macros).</p>
<p>A downside of implementing this object-oriented pattern exactly as it's defined
for object-oriented languages is that we're not taking advantage of Rust's
strengths as much as we could be. Let's take a look at some changes we can make
to this code that can make invalid states and transitions into compile time
errors.</p>
<a class="header" href="print.html#encoding-states-and-behavior-as-types" id="encoding-states-and-behavior-as-types"><h4>Encoding States and Behavior as Types</h4></a>
<p>We're going to show how to rethink the state pattern a bit in order to get a
different set of tradeoffs. Rather than encapsulating the states and
transitions completely so that outside code has no knowledge of them, we're
going to encode the states into different types. When the states are types,
Rust's type checking will make any attempt to use a draft post where we should
only use published posts into a compiler error.</p>
<p>Let's consider the first part of <code>main</code> from Listing 17-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());
}
</code></pre>
<p>We still want to create a new post in the draft state using <code>Post::new</code>, and we
still want to be able to add text to the post's content. But instead of having
a <code>content</code> method on a draft post that returns an empty string, we're going to
make it so that draft posts don't have the <code>content</code> method at all. That way,
if we try to get a draft post's content, we'll get a compiler error that the
method doesn't exist. This will make it impossible for us to accidentally
display draft post content in production, since that code won't even compile.
Listing 17-19 shows the definition of a <code>Post</code> struct, a <code>DraftPost</code> struct,
and methods on each:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
       &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-19: A <code>Post</code> with a <code>content</code> method and a
<code>DraftPost</code> without a <code>content</code> method</span></p>
<p>Both the <code>Post</code> and <code>DraftPost</code> structs have a private <code>content</code> field that stores the
blog post text. The structs no longer have the <code>state</code> field since we're moving
the encoding of the state to the types of the structs. <code>Post</code> will represent a
published post, and it has a <code>content</code> method that returns the <code>content</code>.</p>
<p>We still have a <code>Post::new</code> function, but instead of returning an instance of
<code>Post</code>, it returns an instance of <code>DraftPost</code>. It's not possible to create an
instance of <code>Post</code> right now since <code>content</code> is private and there aren't any
functions that return <code>Post</code>. <code>DraftPost</code> has an <code>add_text</code> method defined on
it so that we can add text to <code>content</code> as before, but note that <code>DraftPost</code>
does not have a <code>content</code> method defined! So we've enforced that all posts
start as draft posts, and draft posts don't have their content available for
display. Any attempt to get around these constraints will be a compiler error.</p>
<a class="header" href="print.html#implementing-transitions-as-transformations-into-different-types" id="implementing-transitions-as-transformations-into-different-types"><h4>Implementing Transitions as Transformations into Different Types</h4></a>
<p>So how do we get a published post then? The rule we want to enforce is that a
draft post has to be reviewed and approved before it can be published. A post
in the pending review state should still not display any content. Let's
implement these constraints by adding another struct, <code>PendingReviewPost</code>,
defining the <code>request_review</code> method on <code>DraftPost</code> to return a
<code>PendingReviewPost</code>, and defining an <code>approve</code> method on <code>PendingReviewPost</code> to
return a <code>Post</code> as shown in Listing 17-20:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String,
# }
#
# pub struct DraftPost {
#     content: String,
# }
#
impl DraftPost {
    // ...snip...

    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 17-20: A <code>PendingReviewPost</code> that gets created by
calling <code>request_review</code> on <code>DraftPost</code>, and an <code>approve</code> method that turns a
<code>PendingReviewPost</code> into a published <code>Post</code></span></p>
<p>The <code>request_review</code> and <code>approve</code> methods take ownership of <code>self</code>, thus
consuming the <code>DraftPost</code> and <code>PendingReviewPost</code> instances and transforming
them into a <code>PendingReviewPost</code> and a published <code>Post</code>, respectively. This way,
we won't have any <code>DraftPost</code> instances lingering around after we've called
<code>request_review</code> on them, and so forth. <code>PendingReviewPost</code> doesn't have a
<code>content</code> method defined on it, so attempting to read its content is a compiler
error like it is with <code>DraftPost</code>. Because the only way to get a published
<code>Post</code> instance that does have a <code>content</code> method defined is to call the
<code>approve</code> method on a <code>PendingReviewPost</code>, and the only way to get a
<code>PendingReviewPost</code> is to call the <code>request_review</code> method on a <code>DraftPost</code>,
we've now encoded the blog post workflow into the type system.</p>
<p>This does mean we have to make some small changes to <code>main</code>. Because
<code>request_review</code> and <code>approve</code> return new instances rather than modifying the
struct they're called on, we need to add more <code>let post =</code> shadowing
assignments to save the returned instances. We also can't have the assertions
about the draft and pending review post's contents being empty string anymore,
nor do we need them: we can't compile code that tries to use the content of
posts in those states any longer. The updated code in <code>main</code> is shown in
Listing 17-21:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">Listing 17-21: Modifications to <code>main</code> to use the new
implementation of the blog post workflow</span></p>
<p>Having to change <code>main</code> to reassign <code>post</code> is what makes this implementation
not quite following the object-oriented state pattern anymore: the
transformations between the states are no longer encapsulated entirely within
the <code>Post</code> implementation. However, we've gained the property of having invalid
states be impossible because of the type system and type checking that happens
at compile time! This ensures that certain bugs, such as displaying the content
of an unpublished post, will be discovered before they make it to production.</p>
<p>Try the tasks suggested that add additional requirements that we mentioned at
the start of this section to see how working with this version of the code
feels.</p>
<p>Even though Rust is capable of implementing object-oriented design patterns,
there are other patterns like encoding state into the type system that are
available in Rust. These patterns have different tradeoffs than the
object-oriented patterns do. While you may be very familiar with
object-oriented patterns, rethinking the problem in order to take advantage of
Rust's features can give benefits like preventing some bugs at compile-time.
Object-oriented patterns won't always be the best solution in Rust, since Rust
has features like ownership that object-oriented languages don't have.</p>
<a class="header" href="print.html#summary-9" id="summary-9"><h2>Summary</h2></a>
<p>No matter whether you think Rust is an object-oriented language or not after
reading this chapter, you've now seen that trait objects are a way to get some
object-oriented features in Rust. Dynamic dispatch can give your code some
flexibility in exchange for a bit of runtime performance. This flexibility can
be used to implement object-oriented patterns that can help with the
maintainability of your code. Rust also has different features, like ownership,
than object-oriented languages. An object-oriented pattern won't always be the
best way to take advantage of Rust's strengths.</p>
<p>Next, let's look at another feature of Rust that enables lots of flexibility:
patterns. We've looked at them briefly throughout the book, but haven't seen
everything they're capable of yet. Let's go!</p>
<a class="header" href="print.html#patterns-match-the-structure-of-values" id="patterns-match-the-structure-of-values"><h1>Patterns Match the Structure of Values</h1></a>
<p>Patterns are a special syntax within Rust for matching against the structure of
our types, complex or simple. A pattern is made up of some combination of
literals; destructured arrays, enums, structs, or tuples; variables, wildcards,
and placeholders. These pieces describe the &quot;shape&quot; of the data we're working
with.</p>
<p>We use a pattern by taking some value and comparing it against the pattern. If
the pattern matches our value, we do something with the value parts. Recall in
Chapter 6 when we discussed the <code>match</code> expression that uses patterns like a
coin sorting machine. We can name pieces within the shape, like we named the
state that appeared on quarters in Chapter 6, and if the data fits the shape,
we can use the named pieces.</p>
<p>This chapter is a reference on all things related to patterns. We'll cover the
valid places to use patterns, the difference between <em>refutable</em> and
<em>irrefutable</em> patterns, and the different kinds of pattern syntax that you
might see.</p>
<a class="header" href="print.html#all-the-places-patterns-may-be-used" id="all-the-places-patterns-may-be-used"><h2>All the Places Patterns May be Used</h2></a>
<p>Patterns pop up in a number of places in Rust. You've been using them a lot
without realizing it! This section is a reference to all the places where
patterns are valid.</p>
<a class="header" href="print.html#match-arms" id="match-arms"><h3><code>match</code> Arms</h3></a>
<p>As we discussed in Chapter 6, a common place patterns are used is in the arms
of <code>match</code> expressions. Formally, <code>match</code> expressions are defined as the
keyword <code>match</code>, a value to match on, and one or more match arms that consist
of a pattern and an expression to run if the value matches that arm's pattern:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<a class="header" href="print.html#exhaustiveness-and-the-default-pattern-_" id="exhaustiveness-and-the-default-pattern-_"><h4>Exhaustiveness and the Default Pattern <code>_</code></h4></a>
<p><code>match</code> expressions are required to be exhaustive. When we put all of the
patterns in the arms together, all possibilities for the value in the <code>match</code>
expression must be accounted for. One way to ensure you have every possibility
covered is to have a catch-all pattern for the last arm, like a variable name.
A name matching any value can never fail and thus covers every case remaining
after the previous arms' patterns.</p>
<p>There's an additional pattern that's often used in the last match arm: <code>_</code>. It
matches anything, but it never binds any variables. This can be useful when you
only want to run code for some patterns but ignore any other value, for example.</p>
<a class="header" href="print.html#if-let-expressions" id="if-let-expressions"><h3><code>if let</code> Expressions</h3></a>
<p>We discussed <code>if let</code> expressions in Chapter 6, and how they're mostly a
shorter way to write the equivalent of a <code>match</code> that only cares about matching
one case. <code>if let</code> can optionally have a corresponding <code>else</code> with code to run
if the pattern in the <code>if let</code> doesn't match.</p>
<p>Listing 18-1 shows that it's even possible to mix and match <code>if let</code>, <code>else if</code>, and <code>else if let</code>. This code shows a series of checks of a bunch of
different conditions to decide what the background color should be. For the
purposes of the example, we've created variables with hardcoded values that a
real program might get by asking the user. If the user has specified a favorite
color, we'll use that as the background color. If today is Tuesday, the
background color will be green. If the user has specified their age as a string
and we can parse it as a number successfully, we'll use either purple or orange
depending on the value of the parsed number. Finally, if none of these
conditions apply, the background color will be blue:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        println!(&quot;Using your favorite color, {}, as the background&quot;, color);
    } else if is_tuesday {
        println!(&quot;Tuesday is green day!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Using purple as the background color&quot;);
        } else {
            println!(&quot;Using orange as the background color&quot;);
        }
    } else {
        println!(&quot;Using blue as the background color&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-1: Mixing <code>if let</code>, <code>else if</code>, <code>else if let</code>,
and <code>else</code></span></p>
<p>This conditional structure lets us support complex requirements. With the
hardcoded values we have here, this example will print <code>Using purple as the background color</code>.</p>
<p>Note that <code>if let</code> can also introduce shadowed variables like <code>match</code> arms can:
<code>if let Ok(age) = age</code> introduces a new shadowed <code>age</code> variable that contains
the value inside the <code>Ok</code> variant. This also means the <code>if age &gt; 30</code> condition
needs to go within the block; we aren't able to combine these two conditions
into <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code> since the shadowed <code>age</code> that we want
to compare to 30 isn't valid until the new scope starts with the curly brace.</p>
<p>Also note that conditionals with many cases like these are not as powerful as
<code>match</code> expression since exhaustiveness is not checked by the compiler. If we
leave off the last <code>else</code> block and miss handling some cases, the compiler will
not error. This example might be too complex to rewrite as a readable <code>match</code>,
so we should take extra care to check that we're handling all the cases since
the compiler is not checking exhaustiveness for us.</p>
<a class="header" href="print.html#while-let" id="while-let"><h3><code>while let</code></h3></a>
<p>A similar construction to <code>if let</code> is <code>while let</code>: this allows you to do a
<code>while</code> loop as long as a pattern continues to match. Listing 18-2 shows an
example using a <code>while let</code> loop to use a vector as a stack and print out the
values in the vector in the opposite order that we pushed the values in:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut stack = Vec::new();

stack.push(1);
stack.push(2);
stack.push(3);

while let Some(top) = stack.pop() {
    println!(&quot;{}&quot;, top);
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-2: Using a <code>while let</code> loop to print out values
as long as <code>stack.pop()</code> returns <code>Some</code></span></p>
<p>This example will print 3, 2, then 1. The <code>pop</code> method takes the last element
out of the vector and returns <code>Some(value)</code>. If the vector is empty, it returns
<code>None</code>. The <code>while</code> loop will continue running the code in its block as long as
<code>pop</code> is returning <code>Some</code>. Once it returns <code>None</code>, the <code>while</code> loop stops. We
can use <code>while let</code> to pop every element off our stack.</p>
<a class="header" href="print.html#for-loops" id="for-loops"><h3><code>for</code> loops</h3></a>
<p>Looping with <code>for</code>, as we discussed in Chapter 3, is the most common loop
construction in Rust code. What we didn't talk about in that chapter was that
<code>for</code> takes a pattern. In Listing 18-3, we're demonstrating how we can use a
pattern in a <code>for</code> loop to destructure a tuple. The <code>enumerate</code> method adapts
an iterator to produce a value and the index of the value in the iterator in a
tuple:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];

for (index, value) in v.iter().enumerate() {
    println!(&quot;{} is at index {}&quot;, value, index);
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-3: Using a pattern in a <code>for</code> loop to
destructure the tuple returned from <code>enumerate</code> into its pieces</span></p>
<p>This will print:</p>
<pre><code class="language-text">1 is at index 0
2 is at index 1
3 is at index 2
</code></pre>
<p>The first call to <code>enumerate</code> produces the tuple <code>(0, 1)</code>. When this value is
matched to the pattern <code>(index, value)</code>, <code>index</code> will be 0 and <code>value</code> will
be 1.</p>
<a class="header" href="print.html#let-statements" id="let-statements"><h3><code>let</code> Statements</h3></a>
<p><code>match</code> and <code>if let</code> are the places we've explicitly discussed using patterns
earlier in the book, but they aren't the only places we've <em>used</em> patterns. For
example, consider this straightforward variable assignment with <code>let</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
#}</code></pre></pre>
<p>We've done this hundreds of times throughout this book. You may not have
realized it, but you were using patterns! A <code>let</code> statement looks like this,
more formally:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>We've seen statements like <code>let x = 5;</code> with a variable name in the <code>PATTERN</code>
slot; a variable name is just a particularly humble form of pattern.</p>
<p>With <code>let</code>, we compare the expression against the pattern, and assign any names
we find. So for example, in our <code>let x = 5;</code> case, <code>x</code> is a pattern that says
&quot;bind what matches here to the variable <code>x</code>.&quot; And since the name <code>x</code> is the
whole pattern, this pattern effectively means &quot;bind everything to the variable
<code>x</code>, whatever the value is.&quot;</p>
<p>To see the pattern matching aspect of <code>let</code> a bit more clearly, consider
Listing 18-4 where we're using a pattern with <code>let</code> to destructuring a tuple:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let (x, y, z) = (1, 2, 3);
#}</code></pre></pre>
<p><span class="caption">Listing 18-4: Using a pattern to destructure a tuple and
create 3 variables at once</span></p>
<p>Here, we have a tuple that we're matching against a pattern. Rust will compare
the value <code>(1, 2, 3)</code> to the pattern <code>(x, y, z)</code> and see that the value matches
the pattern. In this case, it will bind <code>1</code> to <code>x</code>, <code>2</code> to <code>y</code>, and <code>3</code> to <code>z</code>.
You can think of this tuple pattern as nesting three individual variable
patterns inside of it.</p>
<p>We saw another example of destructuring a tuple in Chapter 16, Listing 16-6,
where we destructured the return value of <code>mpsc::channel()</code> into the <code>tx</code>
(transmitter) and <code>rx</code> (receiver) parts.</p>
<a class="header" href="print.html#function-parameters" id="function-parameters"><h3>Function Parameters</h3></a>
<p>Similarly to <code>let</code>, function parameters can also be patterns. The code in
Listing 18-5 declaring a function named <code>foo</code> that takes one parameter named
<code>x</code> of type <code>i32</code> should look familiar:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(x: i32) {
    // code goes here
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-5: A function signature uses patterns in the
parameters</span></p>
<p>The <code>x</code> part is a pattern! In a similar way as we did with <code>let</code>, we could
match a tuple in a function's arguments. Listing 18-6 shows how we could split
apart the values in a tuple as part of passing the tuple to a function:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}
</code></pre></pre>
<p><span class="caption">Listing 18-6: A function with parameters that destructure
a tuple</span></p>
<p>This will print <code>Current location: (3, 5)</code>. When we pass the value <code>&amp;(3, 5)</code> to
<code>print_coordinates</code>, the values match the pattern <code>&amp;(x, y)</code>. <code>x</code> gets the value
3, and <code>y</code> gets the value 5.</p>
<p>Because closures are similar to functions, as we discussed in Chapter 13, we
can use patterns in closure parameter lists as well.</p>
<p>One difference between the places we can use patterns is that with <code>for</code> loops,
<code>let</code>, and in function parameters, the patterns must be <em>irrefutable</em>. Let's
discuss that next.</p>
<a class="header" href="print.html#refutability-whether-a-pattern-might-fail-to-match" id="refutability-whether-a-pattern-might-fail-to-match"><h2>Refutability: Whether a Pattern Might Fail to Match</h2></a>
<p>Patterns come in two forms: refutable and irrefutable. Patterns which cannot
fail to match for any possible value are said to be <em>irrefutable</em>, and patterns
which can fail to match for some possible value are said to be <em>refutable</em>.
<code>let</code> statements, function parameters, and <code>for</code> loops are restricted to only
accept irrefutable patterns, since there's nothing correct the program could do
if the pattern fails to match. <code>if let</code>, and <code>while let</code> expressions are
restricted to only accept refutable patterns, since they're made to handle
possible failure and we wouldn't need their functionality if the pattern could
never fail.</p>
<p>In general, you shouldn't have to worry about the distinction between refutable
and irrefutable patterns; just be familiar with the concept of refutability
when you see it mentioned in an error message. When you get an error message
involving refutability, you'll need to change either the pattern or the
construct you're using the pattern with, depending on your intentions for the
behavior of the code.</p>
<p>Let's look at some examples. Earlier in this chapter, we had <code>let x = 5;</code>. <code>x</code>
is indeed an irrefutable pattern we're allowed to use: since it matches
anything, it can't fail to match. In contrast, consider trying to match one
variant of an enum with <code>let</code>, such as matching only a <code>Some&lt;T&gt;</code> value from the
<code>Option&lt;T&gt;</code> enum as shown in Listing 18-7:</p>
<pre><code class="language-rust ignore">let Some(x) = some_option_value;
</code></pre>
<p><span class="caption">Listing 18-7: Attempting to use a refutable pattern with
<code>let</code></span></p>
<p>If <code>some_option_value</code> was a <code>None</code> value, <code>some_option_value</code> would not match
the pattern <code>Some(x)</code>. The pattern <code>Some(x)</code> is refutable since there exists a
case in which it would fail to match a value. There's nothing valid that our
code could do with this <code>let</code> statement if <code>some_option_value</code> was the <code>None</code>
value. Therefore, Rust will complain at compile time that we've tried to use a
refutable pattern where an irrefutable pattern is required:</p>
<pre><code class="language-text">error[E0005]: refutable pattern in local binding: `None` not covered
 --&gt; &lt;anon&gt;:3:5
  |
3 | let Some(x) = some_option_value;
  |     ^^^^^^^ pattern `None` not covered
</code></pre>
<p>We didn't cover (and couldn't cover!) every valid value with the pattern
<code>Some(x)</code>, so Rust will rightfully complain.</p>
<p>If we have a refutable pattern, instead of using <code>let</code>, we can use <code>if let</code>.
That way, if the pattern doesn't match, the code inside the curly braces won't
execute. That code will only make sense and run if the value matches the
pattern. Listing 18-8 shows how to fix the code in Listing 18-7 with <code>Some(x)</code>
matching <code>some_option_value</code>. Using the refutable pattern <code>Some(x)</code> is allowed,
since this example uses <code>if let</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let some_option_value: Option&lt;i32&gt; = None;
if let Some(x) = some_option_value {
    println!(&quot;{}&quot;, x);
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-8: Using <code>if let</code> and a block with refutable
patterns instead of <code>let</code></span></p>
<p>Consequently, if we give <code>if let</code> an irrefutable pattern that will always match,
such as <code>x</code> as shown in Listing 18-9:</p>
<pre><code class="language-rust ignore">if let x = 5 {
    println!(&quot;{}&quot;, x);
};
</code></pre>
<p><span class="caption">Listing 18-9: Attempting to use an irrefutable pattern
with <code>if let</code></span></p>
<p>Rust will complain that it doesn't make sense to use <code>if let</code> with an
irrefutable pattern:</p>
<pre><code class="language-text">error[E0162]: irrefutable if-let pattern
 --&gt; &lt;anon&gt;:2:8
  |
2 | if let x = 5 {
  |        ^ irrefutable pattern
</code></pre>
<p>Generally, match arms use refutable patterns, except for the last arm that
might match any remaining values with an irrefutable pattern. A <code>match</code> with
only one arm whose pattern is irrefutable is allowed, but it's not particularly
useful and could be replaced with a simpler <code>let</code> statement. Both the expressions
associated with a <code>let</code> statement and a single arm irrefutable match will
unconditionally be run, so the end result is the same if their expressions are.</p>
<p>Now that we've discussed all the places that patterns can be used and the
difference between refutable and irrefutable patterns, let's go over all the
syntax we can use to create patterns.</p>
<a class="header" href="print.html#all-the-pattern-syntax" id="all-the-pattern-syntax"><h2>All the Pattern Syntax</h2></a>
<p>We've seen some examples of different kinds of patterns throughout the book.
This section lists all the syntax valid in patterns and why you might want to
use each of them.</p>
<a class="header" href="print.html#literals" id="literals"><h3>Literals</h3></a>
<p>As we saw in Chapter 6, you can match against literals directly:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
#}</code></pre></pre>
<p>This prints <code>one</code> since the value in <code>x</code> is 1.</p>
<a class="header" href="print.html#named-variables" id="named-variables"><h3>Named Variables</h3></a>
<p>Named variables are irrefutable patterns that match any value.</p>
<p>As with all variables, variables declared as part of a pattern will shadow
variables with the same name outside of the <code>match</code> construct since a <code>match</code>
starts a new scope. In Listing 18-10, we declare a variable named <code>x</code> with the
value <code>Some(5)</code> and a variable <code>y</code> with the value <code>10</code>. Then we have a <code>match</code>
expression on the value <code>x</code>. Take a look at the patterns in the match arms and
the <code>println!</code> at the end, and make a guess about what will be printed before
running this code or reading further:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {:?}&quot;, y),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">Listing 18-10: A <code>match</code> statement with an arm that
introduces a shadowed variable <code>y</code></span></p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>Let's walk through what happens when the <code>match</code> statement runs. The first
match arm has the pattern <code>Some(50)</code>, and the value in <code>x</code> (<code>Some(5)</code>) does not
match <code>Some(50)</code>, so we continue. In the second match arm, the pattern
<code>Some(y)</code> introduces a new variable name <code>y</code> that will match any value inside a
<code>Some</code> value. Because we're in a new scope inside the <code>match</code> expression, this
is a new variable, not the <code>y</code> we declared at the beginning that has the
value 10. The new <code>y</code> binding will match any value inside a <code>Some</code>, which is
what we have in <code>x</code>, so we execute the expression for that arm and print
<code>Matched, y = 5</code> since this <code>y</code> binds to the inner value of the <code>Some</code> in <code>x</code>,
which is 5.</p>
<p>If <code>x</code> had been a <code>None</code> value instead of <code>Some(5)</code>, we would have matched the
underscore since the other two arms' patterns would not have matched. In the
expression for that match arm, since we did not introduce an <code>x</code> variable in
the pattern of the arm, this <code>x</code> is still the outer <code>x</code> that has not been
shadowed. In this hypothetical case, the <code>match</code> would print <code>Default case, x = None</code>.</p>
<p>Once the <code>match</code> expression is over, its scope ends, and so does the scope of
the inner <code>y</code>. The last <code>println!</code> produces <code>at the end: x = Some(5), y = 10</code>.</p>
<p>In order to make a <code>match</code> expression that compares the values of the outer <code>x</code>
and <code>y</code> rather than introducing a shadowed variable, we would need to use a
match guard conditional instead. We'll be talking about match guards later in
this section.</p>
<a class="header" href="print.html#multiple-patterns" id="multiple-patterns"><h3>Multiple patterns</h3></a>
<p>In <code>match</code> expressions only, you can match multiple patterns with <code>|</code>, which
means <em>or</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;one or two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
#}</code></pre></pre>
<p>This prints <code>one or two</code>.</p>
<a class="header" href="print.html#matching-ranges-of-values-with-" id="matching-ranges-of-values-with-"><h3>Matching Ranges of Values with <code>...</code></h3></a>
<p>You can match an inclusive range of values with <code>...</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

match x {
    1 ... 5 =&gt; println!(&quot;one through five&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
#}</code></pre></pre>
<p>If <code>x</code> is 1, 2, 3, 4, or 5, the first arm will match.</p>
<p>Ranges are only allowed with numeric values or <code>char</code> values. Here's an example
using ranges of <code>char</code> values:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 'c';

match x {
    'a' ... 'j' =&gt; println!(&quot;early ASCII letter&quot;),
    'k' ... 'z' =&gt; println!(&quot;late ASCII letter&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
#}</code></pre></pre>
<p>This will print <code>early ASCII letter</code>.</p>
<a class="header" href="print.html#destructuring-to-break-apart-values" id="destructuring-to-break-apart-values"><h3>Destructuring to Break Apart Values</h3></a>
<p>Patterns can be used to <em>destructure</em> structs, enums, tuples, and references.
Destructuring means to break a value up into its component pieces. Listing
18-11 shows a <code>Point</code> struct with two fields, <code>x</code> and <code>y</code>, that we can break
apart by using a pattern with a <code>let</code> statement:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<p><span class="caption">Listing 18-11: Destructuring using struct field
shorthand</span></p>
<p>This creates the variables <code>x</code> and <code>y</code> that match the <code>x</code> and <code>y</code> of <code>p</code>. The
names of the variables must match the names of the fields to use this
shorthand. If we wanted to use names different than the variable names, we can
specify <code>field_name: variable_name</code> in the pattern. In Listing 18-12, <code>a</code> will
have the value in the <code>Point</code> instance's <code>x</code> field and <code>b</code> will have the value
in the <code>y</code> field:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<p><span class="caption">Listing 18-12: Destructuring struct fields into variables
with different names than the fields</span></p>
<p>We can also use destructuring with literal values in order to test and use
inner parts of a value. Listing 18-13 shows a <code>match</code> statement that determines
whether a point lies directly on the <code>x</code> axis (which is true when <code>y = 0</code>), on
the <code>y</code> axis (<code>x = 0</code>), or neither:</p>
<pre><pre class="playpen"><code class="language-rust"># struct Point {
#     x: i32,
#     y: i32,
# }
#
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-13: Destructuring and matching literal values
in one pattern</span></p>
<p>This will print <code>On the y axis at 7</code> since the value <code>p</code> matches the second arm
by virtue of <code>x</code> having the value 0.</p>
<p>We used destructuring on enums in Chapter 6, such as in Listing 6-5 where we
destructured an <code>Option&lt;i32&gt;</code> using a <code>match</code> expression and added one to the
inner value of the <code>Some</code> variant.</p>
<p>When the value we're matching against a pattern contains a reference, we can
specify a <code>&amp;</code> in the pattern in order to separate the reference and the value.
This is especially useful in closures used with iterators that iterate over
references to values when we want to use the values in the closure rather than
the references. Listing 18-14 shows how to iterate over references to <code>Point</code>
instances in a vector, and destructure both the reference and the struct in
order to be able to perform calculations on the <code>x</code> and <code>y</code> values easily:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
let points = vec![
    Point { x: 0, y: 0 },
    Point { x: 1, y: 5 },
    Point { x: 10, y: -3 },
];
let sum_of_squares: i32 = points
    .iter()
    .map(|&amp;Point {x, y}| x * x + y * y)
    .sum();
#}</code></pre></pre>
<p><span class="caption">Listing 18-14: Destructuring a reference to a struct into
the struct field values</span></p>
<p>Because <code>iter</code> iterates over references to the items in the vector, if we
forgot the <code>&amp;</code> in the closure arguments in the <code>map</code>, we'd get a type mismatch
error like this:</p>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt;
   |
14 |         .map(|Point {x, y}| x * x + y * y)
   |               ^^^^^^^^^^^^ expected &amp;Point, found struct `Point`
   |
   = note: expected type `&amp;Point`
              found type `Point`
</code></pre>
<p>This says Rust was expecting our closure to match <code>&amp;Point</code>, but we tried to
match the value with a pattern that was a <code>Point</code> value, not a reference to a
<code>Point</code>.</p>
<p>We can mix, match, and nest destructuring patterns in even more complex ways:
we can do something complicated like this example where we nest structs and
tuples inside of a tuple and destructure all the primitive values out:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
#}</code></pre></pre>
<p>This lets us break complex types into their component parts.</p>
<a class="header" href="print.html#ignoring-values-in-a-pattern" id="ignoring-values-in-a-pattern"><h3>Ignoring Values in a Pattern</h3></a>
<p>There are a few ways to ignore entire values or parts of values: using the <code>_</code>
pattern, using the <code>_</code> pattern within another pattern, using a name that starts
with an underscore, or using <code>..</code> to ignore all remaining parts of a value.
Let's explore how and why to do each of these.</p>
<a class="header" href="print.html#ignoring-an-entire-value-with-_" id="ignoring-an-entire-value-with-_"><h4>Ignoring an Entire Value with <code>_</code></h4></a>
<p>We've seen the use of underscore as a wildcard pattern that will match any value
but not bind to the value. While the underscore pattern is especially useful as
the last arm in a <code>match</code> expression, we can use it in any pattern, such as
function arguments as shown in Listing 18-15:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(_: i32) {
    // code goes here
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-15: Using <code>_</code> in a function signature</span></p>
<p>Normally, you would change the signature to not have the unused parameter. In
cases such as implementing a trait, where you need a certain type signature,
using an underscore lets you ignore a parameter, and the compiler won't warn
about unused function parameters like it would if we had used a name instead.</p>
<a class="header" href="print.html#ignoring-parts-of-a-value-with-a-nested-_" id="ignoring-parts-of-a-value-with-a-nested-_"><h4>Ignoring Parts of a Value with a Nested <code>_</code></h4></a>
<p>We can also use <code>_</code> inside of another pattern to ignore just part of a value.
In Listing 18-16, the first <code>match</code> arm's pattern matches a <code>Some</code> value but
ignores the value inside of the <code>Some</code> variant as specified by the underscore:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = Some(5);

match x {
    Some(_) =&gt; println!(&quot;got a Some and I don't care what's inside&quot;),
    None =&gt; (),
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-16: Ignoring the value inside of the <code>Some</code>
variant by using a nested underscore</span></p>
<p>This is useful when the code associated with the <code>match</code> arm doesn't use the
nested part of the variable at all.</p>
<p>We can also use underscores in multiple places within one pattern, as shown in
Listing 18-17 where we're ignoring the second and fourth values in a tuple of
five items:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) =&gt; {
        println!(&quot;Some numbers: {}, {}, {}&quot;, first, third, fifth)
    },
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-17: Ignoring multiple parts of a tuple</span></p>
<p>This will print <code>Some numbers: 2, 8, 32</code>, and the values 4 and 16 will be
ignored.</p>
<a class="header" href="print.html#ignoring-an-unused-variable-by-starting-its-name-with-an-underscore" id="ignoring-an-unused-variable-by-starting-its-name-with-an-underscore"><h4>Ignoring an Unused Variable by Starting its Name with an Underscore</h4></a>
<p>Usually, Rust will warn you if you create a variable but don't use it anywhere,
since that could be a bug. If you're prototyping or just starting a project,
though, you might create a variable that you'll use eventually, but temporarily
it will be unused. If you're in this situation and would like to tell Rust not
to warn you about the unused variable, you can start the name of the variable
with an underscore. This works just like a variable name in any pattern, only
Rust won't warn you if the variable goes unused. In Listing 18-18, we
do get a warning about not using the variable <code>y</code>, but we don't get a warning
about not using the variable <code>_x</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<p><span class="caption">Listing 18-18: Starting a variable name with an underscore
in order to not get unused variable warnings</span></p>
<p>Note that there is a subtle difference between using only <code>_</code> and using a name
that starts with an underscore like <code>_x</code>: <code>_x</code> still binds the value to the
variable, but <code>_</code> doesn't bind at all.</p>
<p>Listing 18-19 shows a case where this distinction matters: <code>s</code> will still be
moved into <code>_s</code>, which prevents us from using <code>s</code> again:</p>
<pre><code class="language-rust ignore">let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_s) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
</code></pre>
<p><span class="caption">Listing 18-19: An unused variable starting with an
underscore still binds the value, which may take ownership of the value</span></p>
<p>Using underscore by itself, however, doesn't ever bind to the value. Listing
18-20 will compile without any errors since <code>s</code> does not get moved into <code>_</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
#}</code></pre></pre>
<p><span class="caption">Listing 18-20: Using underscore does not bind the
value</span></p>
<p>This works just fine. Because we never bind <code>s</code> to anything, it's not moved.</p>
<a class="header" href="print.html#ignoring-remaining-parts-of-a-value-with-" id="ignoring-remaining-parts-of-a-value-with-"><h4>Ignoring Remaining Parts of a Value with <code>..</code></h4></a>
<p>With values that have many parts, we can extract only a few parts and avoid
having to list underscores for each remaining part by instead using <code>..</code>. The
<code>..</code> pattern will ignore any parts of a value that we haven't explicitly
matched in the rest of the pattern. In Listing 18-21, we have a <code>Point</code> struct
that holds a coordinate in three dimensional space. In the <code>match</code> expression,
we only want to operate on the <code>x</code> coordinate and ignore the values in the <code>y</code>
and <code>z</code> fields:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-21: Ignoring all fields of a <code>Point</code> except
for <code>x</code> by using <code>..</code></span></p>
<p>Using <code>..</code> is shorter to type than having to list out <code>y: _</code> and <code>z: _</code>. The
<code>..</code> pattern is especially useful when working with structs that have lots of
fields in situations where only one or two fields are relevant.</p>
<p><code>..</code> will expand to as many values as it needs to be. Listing 18-22 shows a use
of <code>..</code> with a tuple:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {}, {}&quot;, first, last);
        },
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-22: Matching only the first and last values in
a tuple and ignoring all other values with <code>..</code></span></p>
<p>Here, we have the first and last value matched, with <code>first</code> and <code>last</code>. The
<code>..</code> will match and ignore all of the things in the middle.</p>
<p>Using <code>..</code> must be unambiguous, however. Listing 18-23 shows an example where
it's not clear to Rust which values we want to match and which values we want
to ignore:</p>
<pre><code class="language-rust ignore">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {}&quot;, second)
        },
    }
}
</code></pre>
<p><span class="caption">Listing 18-23: An attempt to use <code>..</code> in a way that is
ambiguous</span></p>
<p>If we compile this example, we get this error:</p>
<pre><code class="language-text">error: `..` can only be used once per tuple or tuple struct pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |                      ^^
</code></pre>
<p>It's not possible to determine how many values in the tuple should be ignored
before one value is matched with <code>second</code>, and then how many further values are
ignored after that. We could mean that we want to ignore 2, bind <code>second</code> to 4,
then ignore 8, 16, and 32, or we could mean that we want to ignore 2 and 4,
bind <code>second</code> to 8, then ignore 16 and 32, and so forth. The variable name
<code>second</code> doesn't mean anything special to Rust, so we get a compiler error
since using <code>..</code> in two places like this is ambiguous.</p>
<a class="header" href="print.html#ref-and-ref-mut-to-create-references-in-patterns" id="ref-and-ref-mut-to-create-references-in-patterns"><h3><code>ref</code> and <code>ref mut</code> to Create References in Patterns</h3></a>
<p>Usually, when you match against a pattern, the variables that the pattern
introduces are bound to a value. This means you'll end up moving the value into
the <code>match</code> (or wherever you're using the pattern) since the ownership rules
apply. Listing 18-24 shows an example:</p>
<pre><code class="language-rust ignore">let robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    Some(name) =&gt; println!(&quot;Found a name: {}&quot;, name),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
</code></pre>
<p><span class="caption">Listing 18-24: Creating a variable in a match arm pattern
takes ownership of the value</span></p>
<p>This example will fail to compile since the value inside the <code>Some</code> value in
<code>robot_name</code> is moved within the <code>match</code> when <code>name</code> binds to that value.</p>
<p>Using <code>&amp;</code> in a pattern matches an existing reference in the value, as we saw in
the &quot;Destructuring to Break Apart Values&quot; section. If you want to create a
reference instead in order to borrow the value in a pattern variable, use the
<code>ref</code> keyword before the new variable, as shown in Listing 18-25:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    Some(ref name) =&gt; println!(&quot;Found a name: {}&quot;, name),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
#}</code></pre></pre>
<p><span class="caption">Listing 18-25: Creating a reference so that a pattern
variable does not take ownership of a value</span></p>
<p>This example will compile because the value in the <code>Some</code> variant in
<code>robot_name</code> is not moved into the <code>Some(ref name)</code> arm of the match; the match
only took a reference to the data in <code>robot_name</code> rather than moving it.</p>
<p>To create a mutable reference, use <code>ref mut</code> for the same reason as shown in
Listing 18-26:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    Some(ref mut name) =&gt; *name = String::from(&quot;Another name&quot;),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
#}</code></pre></pre>
<p><span class="caption">Listing 18-26: Creating a mutable reference to a value as
part of a pattern using <code>ref mut</code></span></p>
<p>This example will compile and print <code>robot_name is: Some(&quot;Another name&quot;)</code>.
Since <code>name</code> is a mutable reference, within the match arm code, we need to
dereference using the <code>*</code> operator in order to be able to mutate the value.</p>
<a class="header" href="print.html#extra-conditionals-with-match-guards" id="extra-conditionals-with-match-guards"><h3>Extra Conditionals with Match Guards</h3></a>
<p>You can introduce <em>match guards</em> as part of a match arm by specifying an
additional <code>if</code> conditional after the pattern. The conditional can use
variables created in the pattern. Listing 18-27 has a <code>match</code> expression with a
match guard in the first arm:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let num = Some(4);

match num {
    Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: {}&quot;, x),
    Some(x) =&gt; println!(&quot;{}&quot;, x),
    None =&gt; (),
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-27: Adding a match guard to a pattern</span></p>
<p>This example will print <code>less than five: 4</code>. If <code>num</code> was instead <code>Some(7)</code>,
this example would print <code>7</code>. Match guards allow you to express more complexity
than patterns alone give you.</p>
<p>In Listing 18-10, we saw that since patterns shadow variables, we weren't able
to specify a pattern to express the case when a value was equal to a variable
outside the <code>match</code>. Listing 18-28 shows how we can use a match guard to
accomplish this:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Matched, n = {:?}&quot;, n),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">Listing 18-28: Using a match guard to test for equality
with an outer variable</span></p>
<p>This will now print <code>Default case, x = Some(5)</code>. Because the second match arm
is not introducing a new variable <code>y</code> that shadows the outer <code>y</code> in the
pattern, we can use <code>y</code> in the match guard. We're still destructuring <code>x</code> to
get the inner value <code>n</code>, and then we can compare <code>n</code> and <code>y</code> in the match guard.</p>
<p>If you're using a match guard with multiple patterns specified by <code>|</code>, the
match guard condition applies to all of the patterns. Listing 18-29 shows a
match guard that applies to the value matched by all three patterns in the
first arm:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 4;
let y = false;

match x {
    4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
    _ =&gt; println!(&quot;no&quot;),
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-29: Combining multiple patterns with a match
guard</span></p>
<p>This prints <code>no</code> since the <code>if</code> condition applies to the whole pattern <code>4 | 5 | 6</code>, not only to the last value <code>6</code>. In other words, the precedence of a match
guard in relation to a pattern behaves like this:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>rather than this:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<a class="header" href="print.html#-bindings" id="-bindings"><h3><code>@</code> Bindings</h3></a>
<p>In order to test a value in a pattern but also be able to create a variable
bound to the value, we can use <code>@</code>. Listing 18-30 shows an example where we
want to test that a <code>Message::Hello</code> <code>id</code> field is within the range <code>3...7</code> but
also be able to bind to the value so that we can use it in the code associated
with the arm:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello { id: id @ 3...7 } =&gt; {
        println!(&quot;Found an id in range: {}&quot;, id)
    },
    Message::Hello { id: 10...12 } =&gt; {
        println!(&quot;Found an id in another range&quot;)
    },
    Message::Hello { id } =&gt; {
        println!(&quot;Found some other id: {}&quot;, id)
    },
}
#}</code></pre></pre>
<p><span class="caption">Listing 18-30: Using <code>@</code> to bind to a value in a pattern
while also testing it</span></p>
<p>This example will print <code>Found an id in range: 5</code>. By specifying <code>id @</code> before
the range, we're capturing whatever value matched the range while also testing
it. In the second arm where we only have a range specified in the pattern, the
code associated with the arm doesn't know if <code>id</code> is 10, 11, or 12, since we
haven't saved the <code>id</code> value in a variable: we only know that the value matched
something in that range if that arm's code is executed. In the last arm where
we've specified a variable without a range, we do have the value available to
use in the arm's code, but we haven't applied any other test to the value.
Using <code>@</code> lets us test a value and save it in a variable within one pattern.</p>
<a class="header" href="print.html#summary-10" id="summary-10"><h2>Summary</h2></a>
<p>Patterns are a useful feature of Rust that help to distinguish between
different kinds of data. When used in <code>match</code> statements, Rust makes sure that
your patterns cover every possible value. Patterns in <code>let</code> statements and
function parameters make those constructs more powerful, enabling the
destructuring of values into smaller parts at the same time as assigning to
variables.</p>
<p>Now, for the penultimate chapter of the book, let's take a look at some
advanced parts of a variety of Rust's features.</p>
<a class="header" href="print.html#advanced-features" id="advanced-features"><h1>Advanced Features</h1></a>
<p>We've come a long way! By now, we've learned 99% of the things you'll need to
know when writing Rust. Before we do one more project in Chapter 20, let's talk
about a few things that you may run into that last 1% of the time. Feel free to
skip this chapter and come back to it once you run into these things in the
wild; the features we'll learn to use here are useful in very specific
situations. We don't want to leave these features out, but you won't find
yourself reaching for them often.</p>
<p>In this chapter, we're going to cover:</p>
<ul>
<li>Unsafe Rust: for when you need to opt out of some of Rust's guarantees and
tell the compiler that you will be responsible for upholding the guarantees
instead</li>
<li>Advanced Lifetimes: Additional lifetime syntax for complex situations</li>
<li>Advanced Traits: Associated Types, default type parameters, fully qualified
syntax, supertraits, and the newtype pattern in relation to traits</li>
<li>Advanced Types: some more about the newtype pattern, type aliases, the
&quot;never&quot; type, and dynamically sized types</li>
<li>Advanced Functions and Closures: function pointers and returning closures</li>
</ul>
<p>It's a panoply of Rust features with something for everyone! Let's dive in!</p>
<a class="header" href="print.html#unsafe-rust" id="unsafe-rust"><h2>Unsafe Rust</h2></a>
<p>In all of the previous chapters in this book, we've been discussing code
written in Rust that has memory safety guarantees enforced at compile time.
However, Rust has a second language hiding out inside of it, unsafe Rust, which
does not enforce these memory safety guarantees. Unsafe Rust works just like
regular Rust does, but it gives you extra superpowers not available in safe
Rust code.</p>
<p>Unsafe Rust exists because, by nature, static analysis is conservative. When
trying to determine if code upholds some guarantees or not, it's better to
reject some programs that are valid than it is to accept some programs that are
invalid. There are some times when your code might be okay, but Rust thinks
it's not! In these cases, you can use unsafe code to tell the compiler, &quot;trust
me, I know what I'm doing.&quot; The downside is that you're on your own; if you get
unsafe code wrong, problems due to memory unsafety like null pointer
dereferencing can occur.</p>
<p>There's another reason that Rust needs to have unsafe code: the underlying
hardware of computers is inherently not safe. If Rust didn't let you do unsafe
operations, there would be some tasks that you simply could not do. But Rust
needs to be able to let you do low-level systems programming like directly
interacting with your operating system, or even writing your own operating
system! That's part of the goals of the language. We need some way to do these
kinds of things.</p>
<a class="header" href="print.html#unsafe-superpowers" id="unsafe-superpowers"><h3>Unsafe Superpowers</h3></a>
<p>We switch into unsafe Rust by using the <code>unsafe</code> keyword and starting a new
block that holds the unsafe code. There are four actions that you can take in
unsafe Rust that you can't in safe Rust. We call these the &quot;unsafe
superpowers.&quot; We haven't seen most of these features yet since they're only
usable with <code>unsafe</code>!</p>
<ol>
<li>Dereferencing a raw pointer</li>
<li>Calling an unsafe function or method</li>
<li>Accessing or modifying a mutable static variable</li>
<li>Implementing an unsafe trait</li>
</ol>
<p>It's important to understand that <code>unsafe</code> doesn't turn off the borrow checker
or disable any other of Rust's safety checks: if you use a reference in unsafe
code, it will still be checked. The only thing the <code>unsafe</code> keyword does is
give you access to these four features that aren't checked by the compiler for
memory safety. You still get some degree of safety inside of an unsafe block!
Furthermore, <code>unsafe</code> does not mean the code inside the block is dangerous or
definitely will have memory safety problems: the intent is that you as the
programmer will ensure that the code inside an <code>unsafe</code> block will have valid
memory, since you've turned off the compiler checks.</p>
<p>People are fallible, however, and mistakes will happen. By requiring these four
unsafe operations to be inside blocks annotated with <code>unsafe</code>, if you make a
mistake and get an error related to memory safety, you'll know that it has to
be related to one of the places that you opted into this unsafety. That makes
the cause of memory safety bugs much easier to find, since we know Rust is
checking all of the other code for us. To get this benefit of only having a few
places to investigate memory safety bugs, it's important to contain your unsafe
code to as small of an area as possible. Any code inside of an <code>unsafe</code> block
is suspect when debugging a memory problem: keep <code>unsafe</code> blocks small and
you'll thank yourself later since you'll have less code to investigate.</p>
<p>In order to isolate unsafe code as much as possible, it's a good idea to
enclose unsafe code within a safe abstraction and provide a safe API, which
we'll be discussing once we get into unsafe functions and methods. Parts of the
standard library are implemented as safe abstractions over unsafe code that has
been audited. This prevents uses of <code>unsafe</code> from leaking out into all the
places that you or your users might want to make use of the functionality
implemented with <code>unsafe</code> code, since using a safe abstraction is safe.</p>
<p>Let's talk about each of the four unsafe superpowers in turn, and along the way
we'll look at some abstractions that provide a safe interface to unsafe code.</p>
<a class="header" href="print.html#dereferencing-a-raw-pointer" id="dereferencing-a-raw-pointer"><h3>Dereferencing a Raw Pointer</h3></a>
<p>Way back in Chapter 4, we first learned about references. We also learned that
the compiler ensures that references are always valid. Unsafe Rust has two new
types similar to references called <em>raw pointers</em>. Just like references, we can
have an immutable raw pointer and a mutable raw pointer. In the context of raw
pointers, &quot;immutable&quot; means that the pointer can't be directly dereferenced and
assigned to. Listing 19-1 shows how to create raw pointers from references:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;
#}</code></pre></pre>
<p><span class="caption">Listing 19-1: Creating raw pointers from references</span></p>
<p>The <code>*const T</code> type is an immutable raw pointer, and <code>*mut T</code> is a mutable raw
pointer. We've created raw pointers by using <code>as</code> to cast an immutable and a
mutable reference into their corresponding raw pointer types. Unlike
references, these pointers may or may not be valid.</p>
<p>Listing 19-2 shows how to create a raw pointer to an arbitrary location in
memory. Trying to use arbitrary memory is undefined: there may be data at that
address, there may not be any data at that address, the compiler might optimize
the code so that there is no memory access, or your program might segfault.
There's not usually a good reason to be writing code like this, but it is
possible:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let address = 0x012345;
let r = address as *const i32;
#}</code></pre></pre>
<p><span class="caption">Listing 19-2: Creating a raw pointer to an arbitrary
memory address</span></p>
<p>Note there's no <code>unsafe</code> block in either Listing 19-1 or 19-2. You can <em>create</em>
raw pointers in safe code, but you can't <em>dereference</em> raw pointers and read
the data being pointed to. Using the dereference operator, <code>*</code>, on a raw
pointer requires an <code>unsafe</code> block, as shown in Listing 19-3:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;

unsafe {
    println!(&quot;r1 is: {}&quot;, *r1);
    println!(&quot;r2 is: {}&quot;, *r2);
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-3: Dereferencing raw pointers within an
<code>unsafe</code> block</span></p>
<p>Creating a pointer can't do any harm; it's only when accessing the value that
it points at that you might end up dealing with an invalid value.</p>
<p>Note also that in Listing 19-1 and 19-3 we created a <code>*const i32</code> and a <code>*mut i32</code> that both pointed to the same memory location, that of <code>num</code>. If we had
tried to create an immutable and a mutable reference to <code>num</code> instead of raw
pointers, this would not have compiled due to the rule that says we can't have
a mutable reference at the same time as any immutable references. With raw
pointers, we are able to create a mutable pointer and an immutable pointer to
the same location, and change data through the mutable pointer, potentially
creating a data race. Be careful!</p>
<p>With all of these dangers, why would we ever use raw pointers? One major use
case is interfacing with C code, as we'll see in the next section on unsafe
functions. Another case is to build up safe abstractions that the borrow
checker doesn't understand. Let's introduce unsafe functions then look at an
example of a safe abstraction that uses unsafe code.</p>
<a class="header" href="print.html#calling-an-unsafe-function-or-method" id="calling-an-unsafe-function-or-method"><h3>Calling an Unsafe Function or Method</h3></a>
<p>The second operation that requires an unsafe block is calling an unsafe
function. Unsafe functions and methods look exactly like regular functions and
methods, but they have an extra <code>unsafe</code> out front. Bodies of unsafe functions
are effectively <code>unsafe</code> blocks. Here's an unsafe function named <code>dangerous</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
unsafe fn dangerous() {}

unsafe {
    dangerous();
}
#}</code></pre></pre>
<p>If we try to call <code>dangerous</code> without the <code>unsafe</code> block, we'll get an error:</p>
<pre><code class="language-text">error[E0133]: call to unsafe function requires unsafe function or block
 --&gt; &lt;anon&gt;:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
</code></pre>
<p>By inserting the <code>unsafe</code> block around our call to <code>dangerous</code>, we're asserting
to Rust that we've read the documentation for this function, we understand how
to use it properly, and we've verified that everything is correct.</p>
<a class="header" href="print.html#creating-a-safe-abstraction-over-unsafe-code" id="creating-a-safe-abstraction-over-unsafe-code"><h4>Creating a Safe Abstraction Over Unsafe Code</h4></a>
<p>As an example, let's check out some functionality from the standard library,
<code>split_at_mut</code>, and explore how we might implement it ourselves. This safe
method is defined on mutable slices, and it takes one slice and makes it into
two by splitting the slice at the index given as an argument, as demonstrated
in Listing 19-4:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &amp;mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &amp;mut [1, 2, 3]);
assert_eq!(b, &amp;mut [4, 5, 6]);
#}</code></pre></pre>
<p><span class="caption">Listing 19-4: Using the safe <code>split_at_mut</code>
function</span></p>
<p>This function can't be implemented using only safe Rust. An attempt might look
like Listing 19-5. For simplicity, we're implementing <code>split_at_mut</code> as a
function rather than a method, and only for slices of <code>i32</code> values rather than
for a generic type <code>T</code>:</p>
<pre><code class="language-rust ignore">fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid],
     &amp;mut slice[mid..])
}
</code></pre>
<p><span class="caption">Listing 19-5: An attempted implementation of
<code>split_at_mut</code> using only safe Rust</span></p>
<p>This function first gets the total length of the slice, then asserts that the
index given as a parameter is within the slice by checking that the parameter
is less than or equal to the length. The assertion means that if we pass an
index that's greater than the length of the slice to split at, the function
will panic before it attempts to use that index.</p>
<p>Then we return two mutable slices in a tuple: one from the start of the initial
slice to the <code>mid</code> index, and another from <code>mid</code> to the end of the slice.</p>
<p>If we try to compile this, we'll get an error:</p>
<pre><code class="language-text">error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 --&gt; &lt;anon&gt;:6:11
  |
5 |     (&amp;mut slice[..mid],
  |           ----- first mutable borrow occurs here
6 |      &amp;mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
7 | }
  | - first borrow ends here
</code></pre>
<p>Rust's borrow checker can't understand that we're borrowing different parts of
the slice; it only knows that we're borrowing from the same slice twice.
Borrowing different parts of a slice is fundamentally okay; our two <code>&amp;mut [i32]</code>s aren't overlapping. However, Rust isn't smart enough to know this. When
we know something is okay, but Rust doesn't, it's time to reach for unsafe code.</p>
<p>Listing 19-6 shows how to use an <code>unsafe</code> block, a raw pointer, and some calls
to unsafe functions to make the implementation of <code>split_at_mut</code> work:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (slice::from_raw_parts_mut(ptr, mid),
         slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-6: Using unsafe code in the implementation of
the <code>split_at_mut</code> function</span></p>
<p>Recall from Chapter 4 that slices are a pointer to some data and the length of
the slice. We've often used the <code>len</code> method to get the length of a slice; we
can use the <code>as_mut_ptr</code> method to get access to the raw pointer of a slice. In
this case, since we have a mutable slice to <code>i32</code> values, <code>as_mut_ptr</code> returns
a raw pointer with the type <code>*mut i32</code>, which we've stored in the variable
<code>ptr</code>.</p>
<p>The assertion that the <code>mid</code> index is within the slice stays the same. Then,
the <code>slice::from_raw_parts_mut</code> function does the reverse from the <code>as_mut_ptr</code>
and <code>len</code> methods: it takes a raw pointer and a length and creates a slice. We
call <code>slice::from_raw_parts_mut</code> to create a slice that starts from <code>ptr</code> and is
<code>mid</code> items long. Then we call the <code>offset</code> method on <code>ptr</code> with <code>mid</code> as an
argument to get a raw pointer that starts at <code>mid</code>, and we create a slice using
that pointer and the remaining number of items after <code>mid</code> as the length.</p>
<p>Because slices are checked, they're safe to use once we've created them. The
function <code>slice::from_raw_parts_mut</code> is an unsafe function because it takes a
raw pointer and trusts that this pointer is valid. The <code>offset</code> method on raw
pointers is also unsafe, since it trusts that the location some offset after a
raw pointer is also a valid pointer. We've put an <code>unsafe</code> block around our
calls to <code>slice::from_raw_parts_mut</code> and <code>offset</code> to be allowed to call them,
and we can tell by looking at the code and by adding the assertion that <code>mid</code>
must be less than or equal to <code>len</code> that all the raw pointers used within the
<code>unsafe</code> block will be valid pointers to data within the slice. This is an
acceptable and appropriate use of <code>unsafe</code>.</p>
<p>Note that the resulting <code>split_at_mut</code> function is safe: we didn't have to add
the <code>unsafe</code> keyword in front of it, and we can call this function from safe
Rust. We've created a safe abstraction to the unsafe code by writing an
implementation of the function that uses <code>unsafe</code> code in a safe way by only
creating valid pointers from the data this function has access to.</p>
<p>In contrast, the use of <code>slice::from_raw_parts_mut</code> in Listing 19-7 would
likely crash when the slice is used. This code takes an arbitrary memory
location and creates a slice ten thousand items long:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::slice;

let address = 0x012345;
let r = address as *mut i32;

let slice = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};
#}</code></pre></pre>
<p><span class="caption">Listing 19-7: Creating a slice from an arbitrary memory
location</span></p>
<p>We don't own the memory at this arbitrary location, and there's no guarantee
that the slice this code creates contains valid <code>i32</code> values. Attempting to use
<code>slice</code> as if it was a valid slice would be undefined behavior.</p>
<a class="header" href="print.html#extern--functions-for-calling-external-code-are-unsafe" id="extern--functions-for-calling-external-code-are-unsafe"><h4><code>extern</code>  Functions for Calling External Code are Unsafe</h4></a>
<p>Sometimes, your Rust code may need to interact with code written in another
language. To do this, Rust has a keyword, <code>extern</code>, that facilitates creating
and using a <em>Foreign Function Interface</em> (FFI). Listing 19-8 demonstrates how
to set up an integration with a function named <code>some_function</code> defined in an
external library written in a language other than Rust. Functions declared
within <code>extern</code> blocks are always unsafe to call from Rust code:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern &quot;C&quot; {
    fn some_function();
}

fn main() {
    unsafe { some_function() };
}
</code></pre>
<p><span class="caption">Listing 19-8: Declaring and calling an <code>extern</code> function
defined in another language</span></p>
<p>Within the <code>extern &quot;C&quot;</code> block, we list the names and signatures of functions
defined in a library written in another language that we want to be able to
call.<code>&quot;C&quot;</code> defines which <em>application binary interface</em> (ABI) the external
function uses. The ABI defines how to call the function at the assembly level.
The <code>&quot;C&quot;</code> ABI is the most common, and follows the C programming language's ABI.</p>
<p>Calling an external function is always unsafe. If we're calling into some other
language, that language does not enforce Rust's safety guarantees. Since Rust
can't check that the external code is safe, we are responsible for checking the
safety of the external code and indicating we have done so by using an <code>unsafe</code>
block to call external functions.</p>
<!-- PROD: START BOX -->
<a class="header" href="print.html#calling-rust-functions-from-other-languages" id="calling-rust-functions-from-other-languages"><h5>Calling Rust Functions from Other Languages</h5></a>
<p>The <code>extern</code> keyword is also used for creating an interface that allows other
languages to call Rust functions. Instead of an <code>extern</code> block, we can add the
<code>extern</code> keyword and specifying the ABI to use just before the <code>fn</code> keyword. We
also add the <code>#[no_mangle]</code> annotation to tell the Rust compiler not to mangle
the name of this function. The <code>call_from_c</code> function in this example would be
accessible from C code, once we've compiled to a shared library and linked from
C:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
#}</code></pre></pre>
<p>This usage of <code>extern</code> does not require <code>unsafe</code></p>
<!-- PROD: END BOX -->
<a class="header" href="print.html#accessing-or-modifying-a-mutable-static-variable" id="accessing-or-modifying-a-mutable-static-variable"><h3>Accessing or Modifying a Mutable Static Variable</h3></a>
<p>We've gone this entire book without talking about <em>global variables</em>. Many
programming languages support them, and so does Rust. However, global variables
can be problematic: for example, if you have two threads accessing the same
mutable global variable, a data race can happen.</p>
<p>Global variables are called <em>static</em> in Rust. Listing 19-9 shows an example
declaration and use of a static variable with a string slice as a value:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name is: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<p><span class="caption">Listing 19-9: Defining and using an immutable static
variable</span></p>
<p><code>static</code> variables are similar to constants: their names are also in
<code>SCREAMING_SNAKE_CASE</code> by convention, and we <em>must</em> annotate the variable's
type, which is <code>&amp;'static str</code> in this case. Only references with the <code>'static</code>
lifetime may be stored in a static variable. Because of this, the Rust compiler
can figure out the lifetime by itself and we don't need to annotate it explicitly.
Accessing immutable static variables is safe. Values in a static variable have a
fixed address in memory, and using the value will always access the same data.
Constants, on the other hand, are allowed to duplicate their data whenever they
are used.</p>
<p>Another way in which static variables are different from constants is that
static variables can be mutable. Both accessing and modifying mutable static
variables is unsafe. Listing 19-10 shows how to declare, access, and modify a
mutable static variable named <code>COUNTER</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 19-10: Reading from or writing to a mutable
static variable is unsafe</span></p>
<p>Just like with regular variables, we specify that a static variable should be
mutable using the <code>mut</code> keyword. Any time that we read or write from <code>COUNTER</code>
has to be within an <code>unsafe</code> block. This code compiles and prints <code>COUNTER: 3</code>
as we would expect since it's single threaded, but having multiple threads
accessing <code>COUNTER</code> would likely result in data races.</p>
<p>Mutable data that is globally accessible is difficult to manage and ensure that
there are no data races, which is why Rust considers mutable static variables
to be unsafe. If possible, prefer using the concurrency techniques and
threadsafe smart pointers we discussed in Chapter 16 to have the compiler check
that data accessed from different threads is done safely.</p>
<a class="header" href="print.html#implementing-an-unsafe-trait" id="implementing-an-unsafe-trait"><h3>Implementing an Unsafe Trait</h3></a>
<p>Finally, the last action we're only allowed to take when we use the <code>unsafe</code>
keyword is implementing an unsafe trait. We can declare that a trait is
<code>unsafe</code> by adding the <code>unsafe</code> keyword before <code>trait</code>, and then implementing
the trait must be marked as <code>unsafe</code> too, as shown in Listing 19-11:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-11: Defining and implementing an unsafe
trait</span></p>
<p>Like unsafe functions, methods in an unsafe trait have some invariant that the
compiler cannot verify. By using <code>unsafe impl</code>, we're promising that we'll
uphold these invariants.</p>
<p>As an example, recall the <code>Sync</code> and <code>Send</code> marker traits from Chapter 16, and
that the compiler implements these automatically if our types are composed
entirely of <code>Send</code> and <code>Sync</code> types. If we implement a type that contains
something that's not <code>Send</code> or <code>Sync</code> such as raw pointers, and we want to mark
our type as <code>Send</code> or <code>Sync</code>, that requires using <code>unsafe</code>. Rust can't verify
that our type upholds the guarantees that a type can be safely sent across
threads or accessed from multiple threads, so we need to do those checks
ourselves and indicate as such with <code>unsafe</code>.</p>
<p>Using <code>unsafe</code> to take one of these four actions isn't wrong or frowned upon,
but it is trickier to get <code>unsafe</code> code correct since the compiler isn't able
to help uphold memory safety. When you have a reason to use <code>unsafe</code> code,
however, it's possible to do so, and having the explicit <code>unsafe</code> annotation
makes it easier to track down the source of problems if they occur.</p>
<a class="header" href="print.html#advanced-lifetimes" id="advanced-lifetimes"><h2>Advanced Lifetimes</h2></a>
<p>Back in Chapter 10, we learned how to annotate references with lifetime
parameters to help Rust understand how the lifetimes of different references
relate. We saw how most of the time, Rust will let you elide lifetimes, but
every reference has a lifetime. There are three advanced features of lifetimes
that we haven't covered though: <em>lifetime subtyping</em>, <em>lifetime
bounds</em>, and <em>trait object lifetimes</em>.</p>
<a class="header" href="print.html#lifetime-subtyping" id="lifetime-subtyping"><h3>Lifetime Subtyping</h3></a>
<p>Imagine that we want to write a parser. To do this, we'll have a structure that
holds a reference to the string that we're parsing, and we'll call that struct
<code>Context</code>. We'll write a parser that will parse this string and return success
or failure. The parser will need to borrow the context to do the parsing.
Implementing this would look like the code in Listing 19-12, which won't
compile because we've left off the lifetime annotations for now:</p>
<pre><code class="language-rust ignore">struct Context(&amp;str);

struct Parser {
    context: &amp;Context,
}

impl Parser {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
        Err(&amp;self.context.0[1..])
    }
}
</code></pre>
<p><span class="caption">Listing 19-12: Defining a <code>Context</code> struct that holds a
string slice, a <code>Parser</code> struct that holds a reference to a <code>Context</code> instance,
and a <code>parse</code> method that always returns an error referencing the string
slice</span></p>
<p>For simplicity's sake, our <code>parse</code> function returns a <code>Result&lt;(), &amp;str&gt;</code>. That
is, we don't do anything on success, and on failure we return the part of the
string slice that didn't parse correctly. A real implementation would have more
error information than that, and would actually return something created when
parsing succeeds, but we're leaving those parts of the implementation off since
they aren't relevant to the lifetimes part of this example. We're also defining
<code>parse</code> to always produce an error after the first byte. Note that this may
panic if the first byte is not on a valid character boundary; again, we're
simplifying the example in order to concentrate on the lifetimes involved.</p>
<p>So how do we fill in the lifetime parameters for the string slice in <code>Context</code>
and the reference to the <code>Context</code> in <code>Parser</code>? The most straightforward thing
to do is to use the same lifetime everywhere, as shown in Listing 19-13:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Context&lt;'a&gt;(&amp;'a str);

struct Parser&lt;'a&gt; {
    context: &amp;'a Context&lt;'a&gt;,
}

impl&lt;'a&gt; Parser&lt;'a&gt; {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
        Err(&amp;self.context.0[1..])
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-13: Annotating all references in <code>Context</code> and
<code>Parser</code> with the same lifetime parameter</span></p>
<p>This compiles fine. Next, in Listing 19-14, let's write a function that takes
an instance of <code>Context</code>, uses a <code>Parser</code> to parse that context, and returns
what <code>parse</code> returns. This won't quite work:</p>
<pre><code class="language-rust ignore">fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
    Parser { context: &amp;context }.parse()
}
</code></pre>
<p><span class="caption">Listing 19-14: An attempt to add a <code>parse_context</code>
function that takes a <code>Context</code> and uses a <code>Parser</code></span></p>
<p>We get two quite verbose errors when we try to compile the code with the
addition of the <code>parse_context</code> function:</p>
<pre><code class="language-text">error: borrowed value does not live long enough
  --&gt; &lt;anon&gt;:16:5
   |
16 |     Parser { context: &amp;context }.parse()
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ does not live long enough
17 | }
   | - temporary value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the
body at 15:55...
  --&gt; &lt;anon&gt;:15:56
   |
15 |   fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
   |  ________________________________________________________^
16 | |     Parser { context: &amp;context }.parse()
17 | | }
   | |_^

error: `context` does not live long enough
  --&gt; &lt;anon&gt;:16:24
   |
16 |     Parser { context: &amp;context }.parse()
   |                        ^^^^^^^ does not live long enough
17 | }
   | - borrowed value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the
body at 15:55...
  --&gt; &lt;anon&gt;:15:56
   |
15 |   fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
   |  ________________________________________________________^
16 | |     Parser { context: &amp;context }.parse()
17 | | }
   | |_^
</code></pre>
<p>These errors are saying that both the <code>Parser</code> instance we're creating and the
<code>context</code> parameter live from the line that the <code>Parser</code> is created until the
end of the <code>parse_context</code> function, but they both need to live for the entire
lifetime of the function.</p>
<p>In other words, <code>Parser</code> and <code>context</code> need to <em>outlive</em> the entire function
and be valid before the function starts as well as after it ends in order for
all the references in this code to always be valid. Both the <code>Parser</code> we're
creating and the <code>context</code> parameter go out of scope at the end of the
function, though (since <code>parse_context</code> takes ownership of <code>context</code>).</p>
<p>Let's look at the definitions in Listing 19-13 again, especially the signature
of the <code>parse</code> method:</p>
<pre><code class="language-rust ignore">    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
</code></pre>
<p>Remember the elision rules? If we annotate the lifetimes of the references, the
signature would be:</p>
<pre><code class="language-rust ignore">    fn parse&lt;'a&gt;(&amp;'a self) -&gt; Result&lt;(), &amp;'a str&gt; {
</code></pre>
<p>That is, the error part of the return value of <code>parse</code> has a lifetime that is
tied to the <code>Parser</code> instance's lifetime (that of <code>&amp;self</code> in the <code>parse</code> method
signature). That makes sense, as the returned string slice references the
string slice in the <code>Context</code> instance that the <code>Parser</code> holds, and we've
specified in the definition of the <code>Parser</code> struct that the lifetime of the
reference to <code>Context</code> that <code>Parser</code> holds and the lifetime of the string slice
that <code>Context</code> holds should be the same.</p>
<p>The problem is that the <code>parse_context</code> function returns the value returned
from <code>parse</code>, so the lifetime of the return value of <code>parse_context</code> is tied to
the lifetime of the <code>Parser</code> as well. But the <code>Parser</code> instance created in the
<code>parse_context</code> function won't live past the end of the function (it's
temporary), and the <code>context</code> will go out of scope at the end of the function
(<code>parse_context</code> takes ownership of it).</p>
<p>We're not allowed to return a reference to a value that goes out of scope at
the end of the function. Rust thinks that's what we're trying to do because we
annotated all the lifetimes with the same lifetime parameter. That told Rust
the lifetime of the string slice that <code>Context</code> holds is the same as that of
the lifetime of the reference to <code>Context</code> that <code>Parser</code> holds.</p>
<p>The <code>parse_context</code> function can't see that within the <code>parse</code> function, the
string slice returned will outlive both <code>Context</code> and <code>Parser</code>, and that the
reference <code>parse_context</code> returns refers to the string slice, not to <code>Context</code>
or <code>Parser</code>.</p>
<p>By knowing what the implementation of <code>parse</code> does, we know that the only
reason that the return value of <code>parse</code> is tied to the <code>Parser</code> is because it's
referencing the <code>Parser</code>'s <code>Context</code>, which is referencing the string slice, so
it's really the lifetime of the string slice that <code>parse_context</code> needs to care
about. We need a way to tell Rust that the string slice in <code>Context</code> and the
reference to the <code>Context</code> in <code>Parser</code> have different lifetimes and that the
return value of <code>parse_context</code> is tied to the lifetime of the string slice in
<code>Context</code>.</p>
<p>We could try only giving <code>Parser</code> and <code>Context</code> different lifetime parameters
as shown in Listing 19-15. We've chosen the lifetime parameter names <code>'s</code> and
<code>'c</code> here to be clearer about which lifetime goes with the string slice in
<code>Context</code> and which goes with the reference to <code>Context</code> in <code>Parser</code>. Note that
this won't completely fix the problem, but it's a start and we'll look at why
this isn't sufficient when we try to compile.</p>
<pre><code class="language-rust ignore">struct Context&lt;'s&gt;(&amp;'s str);

struct Parser&lt;'c, 's&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}

impl&lt;'c, 's&gt; Parser&lt;'c, 's&gt; {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;'s str&gt; {
        Err(&amp;self.context.0[1..])
    }
}

fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
    Parser { context: &amp;context }.parse()
}
</code></pre>
<p><span class="caption">Listing 19-15: Specifying different lifetime parameters
for the references to the string slice and to <code>Context</code></span></p>
<p>We've annotated the lifetimes of the references in all the same places that we
annotated them in Listing 19-13, but used different parameters depending on
whether the reference goes with the string slice or with <code>Context</code>. We've also
added an annotation to the string slice part of the return value of <code>parse</code> to
indicate that it goes with the lifetime of the string slice in <code>Context</code>.</p>
<p>Here's the error we get now:</p>
<pre><code class="language-text">error[E0491]: in type `&amp;'c Context&lt;'s&gt;`, reference has a longer lifetime than the data it references
 --&gt; src/main.rs:4:5
  |
4 |     context: &amp;'c Context&lt;'s&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
note: the pointer is valid for the lifetime 'c as defined on the struct at 3:0
 --&gt; src/main.rs:3:1
  |
3 | / struct Parser&lt;'c, 's&gt; {
4 | |     context: &amp;'c Context&lt;'s&gt;,
5 | | }
  | |_^
note: but the referenced data is only valid for the lifetime 's as defined on the struct at 3:0
 --&gt; src/main.rs:3:1
  |
3 | / struct Parser&lt;'c, 's&gt; {
4 | |     context: &amp;'c Context&lt;'s&gt;,
5 | | }
  | |_^
</code></pre>
<p>Rust doesn't know of any relationship between <code>'c</code> and <code>'s</code>. In order to be
valid, the referenced data in <code>Context</code> with lifetime <code>'s</code> needs to be
constrained to guarantee that it lives longer than the reference to <code>Context</code>
that has lifetime <code>'c</code>. If <code>'s</code> is not longer than <code>'c</code>, then the reference to
<code>Context</code> might not be valid.</p>
<p>Which gets us to the point of this section: Rust has a feature called <em>lifetime
subtyping</em>, which is a way to specify that one lifetime parameter lives at
least as long as another one. In the angle brackets where we declare lifetime
parameters, we can declare a lifetime <code>'a</code> as usual, and declare a lifetime
<code>'b</code> that lives at least as long as <code>'a</code> by declaring <code>'b</code> with the syntax <code>'b: 'a</code>.</p>
<p>In our definition of <code>Parser</code>, in order to say that <code>'s</code> (the lifetime of the
string slice) is guaranteed to live at least as long as <code>'c</code> (the lifetime of
the reference to <code>Context</code>), we change the lifetime declarations to look like
this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Context&lt;'a&gt;(&amp;'a str);
#
struct Parser&lt;'c, 's: 'c&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}
#}</code></pre></pre>
<p>Now, the reference to <code>Context</code> in the <code>Parser</code> and the reference to the string
slice in the <code>Context</code> have different lifetimes, and we've ensured that the
lifetime of the string slice is longer than the reference to the <code>Context</code>.</p>
<p>That was a very long-winded example, but as we mentioned at the start of this
chapter, these features are pretty niche. You won't often need this syntax, but
it can come up in situations like this one, where you need to refer to
something you have a reference to.</p>
<a class="header" href="print.html#lifetime-bounds" id="lifetime-bounds"><h3>Lifetime Bounds</h3></a>
<p>In Chapter 10, we discussed how to use trait bounds on generic types. We can
also add lifetime parameters as constraints on generic types. For example,
let's say we wanted to make a wrapper over references. Remember <code>RefCell&lt;T&gt;</code>
from Chapter 15? This is how the <code>borrow</code> and <code>borrow_mut</code> methods work; they
return wrappers over references in order to keep track of the borrowing rules
at runtime. The struct definition, without lifetime parameters for now, would
look like Listing 19-16:</p>
<pre><code class="language-rust ignore">struct Ref&lt;T&gt;(&amp;T);
</code></pre>
<p><span class="caption">Listing 19-16: Defining a struct to wrap a reference to a
generic type; without lifetime parameters to start</span></p>
<p>However, using no lifetime bounds at all gives an error because Rust doesn't
know how long the generic type <code>T</code> will live:</p>
<pre><code class="language-text">error[E0309]: the parameter type `T` may not live long enough
 --&gt; &lt;anon&gt;:2:19
  |
2 | struct Ref&lt;'a, T&gt;(&amp;'a T);
  |                   ^^^^^^
  |
  = help: consider adding an explicit lifetime bound `T: 'a`...
note: ...so that the reference type `&amp;'a T` does not outlive the data it points at
 --&gt; &lt;anon&gt;:2:19
  |
2 | struct Ref&lt;'a, T&gt;(&amp;'a T);
  |                   ^^^^^^
</code></pre>
<p>This is the same error that we'd get if we filled in <code>T</code> with a concrete type,
like <code>struct Ref(&amp;i32)</code>; all references in struct definitions need a lifetime
parameter. However, because we have a generic type parameter, we can't add a
lifetime parameter in the same way. Defining <code>Ref</code> as <code>struct Ref&lt;'a&gt;(&amp;'a T)</code>
will result in an error because Rust can't determine that <code>T</code> lives long
enough. Since <code>T</code> can be any type, <code>T</code> could itself be a reference or it could
be a type that holds one or more references, each of which have their own
lifetimes.</p>
<p>Rust helpfully gave us good advice on how to specify the lifetime parameter in
this case:</p>
<pre><code class="language-text">consider adding an explicit lifetime bound `T: 'a` so that the reference type
`&amp;'a T` does not outlive the data it points to.
</code></pre>
<p>The code in Listing 19-17 works because <code>T: 'a</code> syntax specifies that <code>T</code> can
be any type, but if it contains any references, <code>T</code> must live as long as <code>'a</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
#}</code></pre></pre>
<p><span class="caption">Listing 19-17: Adding lifetime bounds on <code>T</code> to specify
that any references in <code>T</code> live at least as long as <code>'a</code></span></p>
<p>We could choose to solve this in a different way as shown in Listing 19-18 by
bounding <code>T</code> on <code>'static</code>. This means if <code>T</code> contains any references, they must
have the <code>'static</code> lifetime:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct StaticRef&lt;T: 'static&gt;(&amp;'static T);
#}</code></pre></pre>
<p><span class="caption">Listing 19-18: Adding a <code>'static</code> lifetime bound to <code>T</code>
to constrain <code>T</code> to types that have only <code>'static</code> references or no
references</span></p>
<p>Types with no references count as <code>T: 'static</code>. Because <code>'static</code> means the
reference must live as long as the entire program, a type that contains no
references meets the criteria of all references living as long as the entire
program (since there are no references). Think of it this way: if the borrow
checker is concerned about references living long enough, then there's no real
distinction between a type that has no references and a type that has
references that live forever; both of them are the same for the purpose of
determining whether or not a reference has a shorter lifetime than what it
refers to.</p>
<a class="header" href="print.html#trait-object-lifetimes" id="trait-object-lifetimes"><h3>Trait Object Lifetimes</h3></a>
<p>In Chapter 17, we learned about trait objects that consist of putting a trait
behind a reference in order to use dynamic dispatch. However, we didn't discuss
what happens if the type implementing the trait used in the trait object has a
lifetime. Consider Listing 19-19, where we have a trait <code>Foo</code> and a struct
<code>Bar</code> that holds a reference (and thus has a lifetime parameter) that
implements trait <code>Foo</code>, and we want to use an instance of <code>Bar</code> as the trait
object <code>Box&lt;Foo&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo { }

struct Bar&lt;'a&gt; {
    x: &amp;'a i32,
}

impl&lt;'a&gt; Foo for Bar&lt;'a&gt; { }

let num = 5;

let obj = Box::new(Bar { x: &amp;num }) as Box&lt;Foo&gt;;
#}</code></pre></pre>
<p><span class="caption">Listing 19-19: Using a type that has a lifetime parameter
with a trait object</span></p>
<p>This code compiles without any errors, even though we haven't said anything
about the lifetimes involved in <code>obj</code>. This works because there are rules
having to do with lifetimes and trait objects:</p>
<ul>
<li>The default lifetime of a trait object is <code>'static</code>.</li>
<li>If we have <code>&amp;'a X</code> or <code>&amp;'a mut X</code>, then the default is <code>'a</code>.</li>
<li>If we have a single <code>T: 'a</code> clause, then the default is <code>'a</code>.</li>
<li>If we have multiple <code>T: 'a</code>-like clauses, then there is no default; we must
be explicit.</li>
</ul>
<p>When we must be explicit, we can add a lifetime bound on a trait object like
<code>Box&lt;Foo&gt;</code> with the syntax <code>Box&lt;Foo + 'a&gt;</code> or <code>Box&lt;Foo + 'static&gt;</code>, depending
on what's needed. Just as with the other bounds, this means that any
implementer of the <code>Foo</code> trait that has any references inside must have the
lifetime specified in the trait object bounds as those references.</p>
<p>Next, let's take a look at some other advanced features dealing with traits!</p>
<a class="header" href="print.html#advanced-traits" id="advanced-traits"><h2>Advanced Traits</h2></a>
<p>We covered traits in Chapter 10, but like lifetimes, we didn't get to all the
details. Now that we know more Rust, we can get into the nitty-gritty.</p>
<a class="header" href="print.html#associated-types" id="associated-types"><h3>Associated Types</h3></a>
<p><em>Associated types</em> are a way of associating a type placeholder with a trait
such that the trait method definitions can use these placeholder types in their
signatures. The implementer of a trait will specify the concrete type to be
used in this type's place for the particular implementation.</p>
<p>We've described most of the things in this chapter as being very rare.
Associated types are somewhere in the middle; they're more rare than the rest
of the book, but more common than many of the things in this chapter.</p>
<p>An example of a trait with an associated type is the <code>Iterator</code> trait provided
by the standard library. It has an associated type named <code>Item</code> that stands in
for the type of the values that we're iterating over. We mentioned in Chapter
13 that the definition of the <code>Iterator</code> trait is as shown in Listing 19-20:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-20: The definition of the <code>Iterator</code> trait
that has an associated type <code>Item</code></span></p>
<p>This says that the <code>Iterator</code> trait has an associated type named <code>Item</code>. <code>Item</code>
is a placeholder type, and the return value of the <code>next</code> method will return
values of type <code>Option&lt;Self::Item&gt;</code>. Implementers of this trait will specify
the concrete type for <code>Item</code>, and the <code>next</code> method will return an <code>Option</code>
containing a value of whatever type the implementer has specified.</p>
<a class="header" href="print.html#associated-types-versus-generics" id="associated-types-versus-generics"><h4>Associated Types Versus Generics</h4></a>
<p>When we implemented the <code>Iterator</code> trait on the <code>Counter</code> struct in Listing
13-6, we specified that the <code>Item</code> type was <code>u32</code>:</p>
<pre><code class="language-rust ignore">impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</code></pre>
<p>This feels similar to generics. So why isn't the <code>Iterator</code> trait defined as
shown in Listing 19-21?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-21: A hypothetical definition of the
<code>Iterator</code> trait using generics</span></p>
<p>The difference is that with the definition in Listing 19-21, we could also
implement <code>Iterator&lt;String&gt; for Counter</code>, or any other type as well, so that
we'd have multiple implementations of <code>Iterator</code> for <code>Counter</code>. In other words,
when a trait has a generic parameter, we can implement that trait for a type
multiple times, changing the generic type parameters' concrete types each time.
Then when we use the <code>next</code> method on <code>Counter</code>, we'd have to provide type
annotations to indicate which implementation of <code>Iterator</code> we wanted to use.</p>
<p>With associated types, we can't implement a trait on a type multiple times.
Using the actual definition of <code>Iterator</code> from Listing 19-20, we can only
choose once what the type of <code>Item</code> will be, since there can only be one <code>impl Iterator for Counter</code>. We don't have to specify that we want an iterator of
<code>u32</code> values everywhere that we call <code>next</code> on <code>Counter</code>.</p>
<p>The benefit of not having to specify generic type parameters when a trait uses
associated types shows up in another way as well. Consider the two traits
defined in Listing 19-22. Both are defining a trait having to do with a graph
structure that contains nodes of some type and edges of some type. <code>GGraph</code> is
defined using generics, and <code>AGraph</code> is defined using associated types:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait GGraph&lt;Node, Edge&gt; {
    // methods would go here
}

trait AGraph {
    type Node;
    type Edge;

    // methods would go here
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-22: Two graph trait definitions, <code>GGraph</code>
using generics and <code>AGraph</code> using associated types for <code>Node</code> and <code>Edge</code></span></p>
<p>Let's say we wanted to implement a function that computes the distance between
two nodes in any types that implement the graph trait. With the <code>GGraph</code> trait
defined using generics, our <code>distance</code> function signature would have to look
like Listing 19-23:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait GGraph&lt;Node, Edge&gt; {}
#
fn distance&lt;N, E, G: GGraph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; u32 {
#     0
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-23: The signature of a <code>distance</code> function
that uses the trait <code>GGraph</code> and has to specify all the generic
parameters</span></p>
<p>Our function would need to specify the generic type parameters <code>N</code>, <code>E</code>, and
<code>G</code>, where <code>G</code> is bound by the trait <code>GGraph</code> that has type <code>N</code> as its <code>Node</code>
type and type <code>E</code> as its <code>Edge</code> type. Even though <code>distance</code> doesn't need to
know the types of the edges, we're forced to declare an <code>E</code> parameter, because
we need to to use the <code>GGraph</code> trait and that requires specifying the type for
<code>Edge</code>.</p>
<p>Contrast with the definition of <code>distance</code> in Listing 19-24 that uses the
<code>AGraph</code> trait from Listing 19-22 with associated types:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait AGraph {
#     type Node;
#     type Edge;
# }
#
fn distance&lt;G: AGraph&gt;(graph: &amp;G, start: &amp;G::Node, end: &amp;G::Node) -&gt; u32 {
#     0
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-24: The signature of a <code>distance</code> function
that uses the trait <code>AGraph</code> and the associated type <code>Node</code></span></p>
<p>This is much cleaner. We only need to have one generic type parameter, <code>G</code>,
with the trait bound <code>AGraph</code>. Since <code>distance</code> doesn't use the <code>Edge</code> type at
all, it doesn't need to be specified anywhere. To use the <code>Node</code> type
associated with <code>AGraph</code>, we can specify <code>G::Node</code>.</p>
<a class="header" href="print.html#trait-objects-with-associated-types" id="trait-objects-with-associated-types"><h4>Trait Objects with Associated Types</h4></a>
<p>You may have been wondering why we didn't use a trait object in the <code>distance</code>
functions in Listing 19-23 and Listing 19-24. The signature for the <code>distance</code>
function using the generic <code>GGraph</code> trait does get a bit more concise using a
trait object:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait GGraph&lt;Node, Edge&gt; {}
#
fn distance&lt;N, E&gt;(graph: &amp;GGraph&lt;N, E&gt;, start: &amp;N, end: &amp;N) -&gt; u32 {
#     0
}
#}</code></pre></pre>
<p>This might be a more fair comparison to Listing 19-24. Specifying the <code>Edge</code>
type is still required, though, which means Listing 19-24 is still preferable
since we don't have to specify something we don't use.</p>
<p>It's not possible to change Listing 19-24 to use a trait object for the graph,
since then there would be no way to refer to the <code>AGraph</code> trait's associated
type.</p>
<p>It is possible in general to use trait objects of traits that have associated
types, though; Listing 19-25 shows a function named <code>traverse</code> that doesn't
need to use the trait's associated types in other arguments. We do, however,
have to specify the concrete types for the associated types in this case. Here,
we've chosen to accept types that implement the <code>AGraph</code> trait with the
concrete type of <code>usize</code> as their <code>Node</code> type and a tuple of two <code>usize</code> values
for their <code>Edge</code> type:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait AGraph {
#     type Node;
#     type Edge;
# }
#
fn traverse(graph: &amp;AGraph&lt;Node=usize, Edge=(usize, usize)&gt;) {}
#}</code></pre></pre>
<p>While trait objects mean that we don't need to know the concrete type of the
<code>graph</code> parameter at compile time, we do need to constrain the use of the
<code>AGraph</code> trait in the <code>traverse</code> function by the concrete types of the
associated types. If we didn’t provide this constraint, Rust wouldn't be able
to figure out which <code>impl</code> to match this trait object to, because the
associated types can be part of the signatures of the methods that Rust needs
to look up in the vtable.</p>
<a class="header" href="print.html#operator-overloading-and-default-type-parameters" id="operator-overloading-and-default-type-parameters"><h3>Operator Overloading and Default Type Parameters</h3></a>
<p>The <code>&lt;PlaceholderType=ConcreteType&gt;</code> syntax is used in another way as well: to
specify the default type for a generic type. A great example of a situation
where this is useful is operator overloading.</p>
<p>Rust does not allow you to create your own operators or overload arbitrary
operators, but the operations and corresponding traits listed in <code>std::ops</code> can
be overloaded by implementing the traits associated with the operator. For
example, Listing 19-25 shows how to overload the <code>+</code> operator by implementing
the <code>Add</code> trait on a <code>Point</code> struct so that we can add two <code>Point</code> instances
together:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::Add;

#[derive(Debug,PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
               Point { x: 3, y: 3 });
}
</code></pre></pre>
<p><span class="caption">Listing 19-25: Implementing the <code>Add</code> trait to overload
the <code>+</code> operator for <code>Point</code> instances</span></p>
<p>We've implemented the <code>add</code> method to add the <code>x</code> values of two <code>Point</code>
instances together and the <code>y</code> values of two <code>Point</code> instances together to
create a new <code>Point</code>. The <code>Add</code> trait has an <code>Output</code> associated type that's
used to determine the type returned from <code>add</code>. result of the operation.</p>
<p>Let's look at the <code>Add</code> trait in a bit more detail. Here's its definition:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Add&lt;RHS=Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
#}</code></pre></pre>
<p>This should look familiar; it's a trait with one method and an associated type.
The new part is the <code>RHS=Self</code> in the angle brackets: this syntax is called
<em>default type parameters</em>. <code>RHS</code> is a generic type parameter (short for &quot;right
hand side&quot;) that's used for the type of the <code>rhs</code> parameter in the <code>add</code>
method. If we don't specify a concrete type for <code>RHS</code> when we implement the
<code>Add</code> trait, the type of <code>RHS</code> will default to the type of <code>Self</code> (the type
that we're implementing <code>Add</code> on).</p>
<p>Let's look at another example of implementing the <code>Add</code> trait. Imagine we have
two structs holding values in different units, <code>Millimeters</code> and <code>Meters</code>. We
can implement <code>Add</code> for <code>Millimeters</code> in different ways as shown in Listing
19-26:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Millimeters) -&gt; Millimeters {
        Millimeters(self.0 + other.0)
    }
}

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-26: Implementing the <code>Add</code> trait on
<code>Millimeters</code> to be able to add <code>Millimeters</code> to <code>Millimeters</code> and
<code>Millimeters</code> to <code>Meters</code></span></p>
<p>If we're adding <code>Millimeters</code> to other <code>Millimeters</code>, we don't need to
parameterize the <code>RHS</code> type for <code>Add</code> since the default <code>Self</code> type is what we
want. If we want to implement adding <code>Millimeters</code> and <code>Meters</code>, then we need
to say <code>impl Add&lt;Meters&gt;</code> to set the value of the <code>RHS</code> type parameter.</p>
<p>Default type parameters are used in two main ways:</p>
<ol>
<li>To extend a type without breaking existing code.</li>
<li>To allow customization in a way most users don't want.</li>
</ol>
<p>The <code>Add</code> trait is an example of the second purpose: most of the time, you're
adding two like types together. Using a default type parameter in the <code>Add</code>
trait definition makes it easier to implement the trait since you don't have to
specify the extra parameter most of the time. In other words, we've removed a
little bit of implementation boilerplate.</p>
<p>The first purpose is similar, but in reverse: since existing implementations of
a trait won't have specified a type parameter, if we want to add a type
parameter to an existing trait, giving it a default will let us extend the
functionality of the trait without breaking the existing implementation code.</p>
<a class="header" href="print.html#fully-qualified-syntax-for-disambiguation" id="fully-qualified-syntax-for-disambiguation"><h3>Fully Qualified Syntax for Disambiguation</h3></a>
<p>Rust cannot prevent a trait from having a method with the same name as another
trait's method, nor can it prevent us from implementing both of these traits on
one type. We can also have a method implemented directly on the type with the
same name as well! In order to be able to call each of the methods with the
same name, then, we need to tell Rust which one we want to use. Consider the
code in Listing 19-27 where traits <code>Foo</code> and <code>Bar</code> both have method <code>f</code> and we
implement both traits on struct <code>Baz</code>, which also has a method named <code>f</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">trait Foo {
    fn f(&amp;self);
}

trait Bar {
    fn f(&amp;self);
}

struct Baz;

impl Foo for Baz {
    fn f(&amp;self) { println!(&quot;Baz’s impl of Foo&quot;); }
}

impl Bar for Baz {
    fn f(&amp;self) { println!(&quot;Baz’s impl of Bar&quot;); }
}

impl Baz {
    fn f(&amp;self) { println!(&quot;Baz's impl&quot;); }
}

fn main() {
    let b = Baz;
    b.f();
}
</code></pre></pre>
<p><span class="caption">Listing 19-27: Implementing two traits that both have a
method with the same name as a method defined on the struct directly</span></p>
<p>For the implementation of the <code>f</code> method for the <code>Foo</code> trait on <code>Baz</code>, we're
printing out <code>Baz's impl of Foo</code>. For the implementation of the <code>f</code> method for
the <code>Bar</code> trait on <code>Baz</code>, we're printing out <code>Baz's impl of Bar</code>. The
implementation of <code>f</code> directly on <code>Baz</code> prints out <code>Baz's impl</code>. What should
happen when we call <code>b.f()</code>? In this case, Rust will always use the
implementation on <code>Baz</code> directly and will print out <code>Baz's impl</code>.</p>
<p>In order to be able to call the <code>f</code> method from <code>Foo</code> and the <code>f</code> method from
<code>Baz</code> rather than the implementation of <code>f</code> directly on <code>Baz</code>, we need to use
the <em>fully qualified syntax</em> for calling methods. It works like this: for any
method call like:</p>
<pre><code class="language-rust ignore">receiver.method(args);
</code></pre>
<p>We can fully qualify the method call like this:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::method(receiver, args);
</code></pre>
<p>So in order to disambiguate and be able to call all the <code>f</code> methods defined in
Listing 19-27, we specify that we want to treat the type <code>Baz</code> as each trait
within angle brackets, then use two colons, then call the <code>f</code> method and pass
the instance of <code>Baz</code> as the first argument. Listing 19-28 shows how to call
<code>f</code> from <code>Foo</code> and then <code>f</code> from <code>Bar</code> on <code>b</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># trait Foo {
#     fn f(&amp;self);
# }
# trait Bar {
#     fn f(&amp;self);
# }
# struct Baz;
# impl Foo for Baz {
#     fn f(&amp;self) { println!(&quot;Baz’s impl of Foo&quot;); }
# }
# impl Bar for Baz {
#     fn f(&amp;self) { println!(&quot;Baz’s impl of Bar&quot;); }
# }
# impl Baz {
#     fn f(&amp;self) { println!(&quot;Baz's impl&quot;); }
# }
#
fn main() {
    let b = Baz;
    b.f();
    &lt;Baz as Foo&gt;::f(&amp;b);
    &lt;Baz as Bar&gt;::f(&amp;b);
}
</code></pre></pre>
<p><span class="caption">Listing 19-28: Using fully qualified syntax to call the
<code>f</code> methods defined as part of the <code>Foo</code> and <code>Bar</code> traits</span></p>
<p>This will print:</p>
<pre><code class="language-text">Baz's impl
Baz’s impl of Foo
Baz’s impl of Bar
</code></pre>
<p>We only need the <code>Type as</code> part if it's ambiguous, and we only need the <code>&lt;&gt;</code>
part if we need the <code>Type as</code> part. So if we only had the <code>f</code> method directly
on <code>Baz</code> and the <code>Foo</code> trait implemented on <code>Baz</code> in scope, we could call the
<code>f</code> method in <code>Foo</code> by using <code>Foo::f(&amp;b)</code> since we wouldn't have to
disambiguate from the <code>Bar</code> trait.</p>
<p>We could also have called the <code>f</code> defined directly on <code>Baz</code> by using
<code>Baz::f(&amp;b)</code>, but since that definition of <code>f</code> is the one that gets used by
default when we call <code>b.f()</code>, it's not required to fully specify that
implementation if that's what we want to call.</p>
<a class="header" href="print.html#supertraits-to-use-one-traits-functionality-within-another-trait" id="supertraits-to-use-one-traits-functionality-within-another-trait"><h3>Supertraits to Use One Trait's Functionality Within Another Trait</h3></a>
<p>Sometimes, we may want a trait to be able to rely on another trait also being
implemented wherever our trait is implemented, so that our trait can use the
other trait's functionality. The required trait is a <em>supertrait</em> of the trait
we're implementing.</p>
<p>For example, let's say we want to make an <code>OutlinePrint</code> trait with an
<code>outline_print</code> method that will print out a value outlined in asterisks. That
is, if our <code>Point</code> struct implements <code>Display</code> to result in <code>(x, y)</code>, calling
<code>outline_print</code> on a <code>Point</code> instance that has 1 for <code>x</code> and 3 for <code>y</code> would
look like:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>In the implementation of <code>outline_print</code>, since we want to be able to use the
<code>Display</code> trait's functionality, we need to be able to say that the
<code>OutlinePrint</code> trait will only work for types that also implement <code>Display</code> and
provide the functionality that <code>OutlinePrint</code> needs. We can do that in the
trait definition by specifying <code>OutlinePrint: Display</code>. It's like adding a
trait bound to the trait. Listing 19-29 shows an implementation of the
<code>OutlinePrint</code> trait:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

trait OutlinePrint: Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-29: Implementing the <code>OutlinePrint</code> trait that
requires the functionality from <code>Display</code></span></p>
<p>Because we've specified that <code>OutlinePrint</code> requires the <code>Display</code> trait, we
can use <code>to_string</code> in <code>outline_print</code> (<code>to_string</code> is automatically
implemented for any type that implements <code>Display</code>). If we hadn't added the <code>: Display</code> after the trait name and we tried to use <code>to_string</code> in
<code>outline_print</code>, we'd get an error that no method named <code>to_string</code> was found
for the type <code>&amp;Self</code> in the current scope.</p>
<p>If we try to implement <code>OutlinePrint</code> on a type that doesn't implement
<code>Display</code>, such as the <code>Point</code> struct:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait OutlinePrint {}
struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
#}</code></pre></pre>
<p>We'll get an error that <code>Display</code> isn't implemented and that <code>Display</code> is
required by <code>OutlinePrint</code>:</p>
<pre><code class="language-text">error[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for
   `Point`
   |
   = note: `Point` cannot be formatted with the default formatter; try using
   `:?` instead if you are using a format string
   = note: required by `OutlinePrint`
</code></pre>
<p>Once we implement <code>Display</code> on <code>Point</code> and satisfy the constraint that
<code>OutlinePrint</code> requires, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
#}</code></pre></pre>
<p>then implementing the <code>OutlinePrint</code> trait on <code>Point</code> will compile successfully
and we can call <code>outline_print</code> on a <code>Point</code> instance to display it within an
outline of asterisks.</p>
<a class="header" href="print.html#the-newtype-pattern-to-implement-external-traits-on-external-types" id="the-newtype-pattern-to-implement-external-traits-on-external-types"><h3>The Newtype Pattern to Implement External Traits on External Types</h3></a>
<p>In Chapter 10, we mentioned the orphan rule, which says we're allowed to
implement a trait on a type as long as either the trait or the type are local
to our crate. One way to get around this restriction is to use the <em>newtype
pattern</em>, which involves creating a new type using a tuple struct with one
field as a thin wrapper around the type we want to implement a trait for. Then
the wrapper type is local to our crate, and we can implement the trait on the
wrapper. &quot;Newtype&quot; is a term originating from the Haskell programming language.
There's no runtime performance penalty for using this pattern. The wrapper type
is elided at compile time.</p>
<p>For example, if we wanted to implement <code>Display</code> on <code>Vec</code>, we can make a
<code>Wrapper</code> struct that holds an instance of <code>Vec</code>. Then we can implement
<code>Display</code> on <code>Wrapper</code> and use the <code>Vec</code> value as shown in Listing 19-30:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<p><span class="caption">Listing 19-30: Creating a <code>Wrapper</code> type around
<code>Vec&lt;String&gt;</code> to be able to implement <code>Display</code></span></p>
<p>The implementation of <code>Display</code> uses <code>self.0</code> to access the inner <code>Vec</code>, and
then we can use the functionality of the <code>Display</code> type on <code>Wrapper</code>.</p>
<p>The downside is that since <code>Wrapper</code> is a new type, it doesn't have the methods
of the value it's holding; we'd have to implement all the methods of <code>Vec</code> like
<code>push</code>, <code>pop</code>, and all the rest directly on <code>Wrapper</code> to delegate to <code>self.0</code>
in order to be able to treat <code>Wrapper</code> exactly like a <code>Vec</code>. If we wanted the
new type to have every single method that the inner type has, implementing the
<code>Deref</code> trait that we discussed in Chapter 15 on the wrapper to return the
inner type can be a solution. If we don't want the wrapper type to have all the
methods of the inner type, in order to restrict the wrapper type's behavior for
example, we'd have to implement just the methods we do want ourselves.</p>
<p>That's how the newtype pattern is used in relation to traits; it's also a
useful pattern without having traits involved. Let's switch focus now to talk
about some advanced ways to interact with Rust's type system.</p>
<a class="header" href="print.html#advanced-types" id="advanced-types"><h2>Advanced Types</h2></a>
<p>The Rust type system has some features that we've mentioned or used without
discussing. We started talking about the newtype pattern in regards to traits;
we'll start with a more general discussion about why newtypes are useful as
types. We'll then move to type aliases, a feature that is similar to newtypes
but has slightly different semantics. We'll also discuss the <code>!</code> type and
dynamically sized types.</p>
<a class="header" href="print.html#using-the-newtype-pattern-for-type-safety-and-abstraction" id="using-the-newtype-pattern-for-type-safety-and-abstraction"><h3>Using the Newtype Pattern for Type Safety and Abstraction</h3></a>
<p>The newtype pattern that we started discussing at the end of the &quot;Advanced
Traits&quot; section, where we create a new type as a tuple struct with one field
that wraps a type can also be useful for statically enforcing that values are
never confused, and is often used to indicate the units of a value. We actually
had an example of this in Listing 19-26: the <code>Millimeters</code> and <code>Meters</code> structs
both wrap <code>u32</code> values in a new type. If we write a function with a parameter
of type <code>Millimeters</code>, we won't be able to compile a program that accidentally
tries to call that function with a value of type <code>Meters</code> or a plain <code>u32</code>.</p>
<p>Another reason to use the newtype pattern is to abstract away some
implementation details of a type: the wrapper type can expose a different
public API than the private inner type would if we used it directly in order to
restrict the functionality that is available, for example. New types can also
hide internal generic types. For example, we could provide a <code>People</code> type that
wraps a <code>HashMap&lt;i32, String&gt;</code> that stores a person's ID associated with their
name. Code using <code>People</code> would only interact with the public API we provide,
such as a method to add a name string to the <code>People</code> collection, and that code
wouldn't need to know that we assign an <code>i32</code> ID to names internally. The
newtype pattern is a lightweight way to achieve encapsulation to hide
implementation details that we discussed in Chapter 17.</p>
<a class="header" href="print.html#type-aliases-create-type-synonyms" id="type-aliases-create-type-synonyms"><h3>Type Aliases Create Type Synonyms</h3></a>
<p>The newtype pattern involves creating a new struct to be a new, separate type.
Rust also provides the ability to declare a <em>type alias</em> with the <code>type</code>
keyword to give an existing type another name. For example, we can create the
alias <code>Kilometers</code> to <code>i32</code> like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Kilometers = i32;
#}</code></pre></pre>
<p>This means <code>Kilometers</code> is a <em>synonym</em> for <code>i32</code>; unlike the <code>Millimeters</code> and
<code>Meters</code> types we created in Listing 19-26, <code>Kilometers</code> is not a separate, new
type. Values that have the type <code>Kilometers</code> will be treated exactly the same
as values of type <code>i32</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Kilometers = i32;

let x: i32 = 5;
let y: Kilometers = 5;

println!(&quot;x + y = {}&quot;, x + y);
#}</code></pre></pre>
<p>Since <code>Kilometers</code> is an alias for <code>i32</code>, they're the same type. We can add
values of type <code>i32</code> and <code>Kilometers</code> together, and we can pass <code>Kilometers</code>
values to functions that take <code>i32</code> parameters. We don't get the type checking
benefits that we get from the newtype pattern that we discussed in the previous
section.</p>
<p>The main use case for type synonyms is to reduce repetition. For example, we
may have a lengthy type like this:</p>
<pre><code class="language-rust ignore">Box&lt;FnOnce() + Send + 'static&gt;
</code></pre>
<p>Writing this out in function signatures and as type annotations all over the
place can be tiresome and error-prone. Imagine having a project full of code
like that in Listing 19-31:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let f: Box&lt;FnOnce() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Box&lt;FnOnce() + Send + 'static&gt;) {
    // ...
}

fn returns_long_type() -&gt; Box&lt;FnOnce() + Send + 'static&gt; {
    // ...
#     Box::new(|| ())
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-31: Using a long type in many places</span></p>
<p>A type alias makes this code more manageable by reducing the amount of
repetition this project has. Here, we've introduced an alias named <code>Thunk</code> for
the verbose type, and we can replace all uses of the type with the shorter
<code>Thunk</code> as shown in Listing 19-32:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Thunk = Box&lt;FnOnce() + Send + 'static&gt;;

let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Thunk) {
    // ...
}

fn returns_long_type() -&gt; Thunk {
    // ...
#     Box::new(|| ())
}
#}</code></pre></pre>
<p><span class="caption">Listing 19-32: Introducing a type alias <code>Thunk</code> to reduce
repetition</span></p>
<p>Much easier to read and write! Choosing a good name for a type alias can help
communicate your intent as well (<em>thunk</em> is a word for code to be evaluated at
a later time, so it's an appropriate name for a closure that gets stored).</p>
<p>Another common use of type aliases is with the <code>Result&lt;T, E&gt;</code> type. Consider
the <code>std::io</code> module in the standard library. I/O operations often return a
<code>Result&lt;T, E&gt;</code>, since their operations may fail to work. There's a
<code>std::io::Error</code> struct that represents all of the possible I/O errors. Many of
the functions in <code>std::io</code> will be returning <code>Result&lt;T, E&gt;</code> where the <code>E</code> is
<code>std::io::Error</code>, such as these functions in the <code>Write</code> trait:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io::Error;
# use std::fmt::Arguments;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: Arguments) -&gt; Result&lt;(), Error&gt;;
}
#}</code></pre></pre>
<p>We're writing <code>Result&lt;..., Error&gt;</code> a lot. As such, <code>std::io</code> has this type
alias declaration:</p>
<pre><code class="language-rust ignore">type Result&lt;T&gt; = Result&lt;T, std::io::Error&gt;;
</code></pre>
<p>Because this is in the <code>std::io</code> module, the fully qualified alias that we can
use is <code>std::io::Result&lt;T&gt;</code>; that is, a <code>Result&lt;T, E&gt;</code> with the <code>E</code> filled in
as <code>std::io::Error</code>. The <code>Write</code> trait function signatures end up looking like
this:</p>
<pre><code class="language-rust ignore">pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: Arguments) -&gt; Result&lt;()&gt;;
}
</code></pre>
<p>The type alias helps in two ways: this is easier to write <em>and</em> it gives us a
consistent interface across all of <code>std::io</code>. Because it's an alias, it is just
another <code>Result&lt;T, E&gt;</code>, which means we can use any methods that work on
<code>Result&lt;T, E&gt;</code> with it, and special syntax like <code>?</code>.</p>
<a class="header" href="print.html#the-never-type--that-never-returns" id="the-never-type--that-never-returns"><h3>The Never Type, <code>!</code>, that Never Returns</h3></a>
<p>Rust has a special type named <code>!</code>. In type theory lingo, it's called the
<em>bottom type</em>, but we prefer to call it the <em>never type</em>. The name describes
what it does: it stands in the place of the return type when a function will
never return. For example:</p>
<pre><code class="language-rust ignore">fn bar() -&gt; ! {
</code></pre>
<p>This is read as &quot;the function <code>bar</code> returns never,&quot; and functions that return
never are called <em>diverging functions</em>. We can't create values of the type <code>!</code>,
so <code>bar</code> can never possibly return. What use is a type you can never create
values for? If you think all the way back to Chapter 2, we had some code that
looked like this, reproduced here in Listing 19-33:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let guess = &quot;3&quot;;
# loop {
let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
# break;
# }
#}</code></pre></pre>
<p><span class="caption">Listing 19-33: A <code>match</code> with an arm that ends in
<code>continue</code></span></p>
<p>At the time, we skipped over some details in this code. In Chapter 6, we
learned that <code>match</code> arms must return the same type. This doesn't work:</p>
<pre><code class="language-rust ignore">let guess = match guess.trim().parse()  {
    Ok(_) =&gt; 5,
    Err(_) =&gt; &quot;hello&quot;,
}
</code></pre>
<p>What would the type of <code>guess</code> be here? It'd have to be both an integer and a
string, and Rust requires that <code>guess</code> can only have one type. So what does
<code>continue</code> return? Why are we allowed to return a <code>u32</code> from one arm in Listing
19-33 and have another arm that ends with <code>continue</code>?</p>
<p>As you may have guessed, <code>continue</code> has a value of <code>!</code>. That is, when Rust goes
to compute the type of <code>guess</code>, it looks at both of the match arms. The former
has a value of <code>u32</code>, and the latter has a value of <code>!</code>. Since <code>!</code> can never
have a value, Rust is okay with this, and decides that the type of <code>guess</code> is
<code>u32</code>. The formal way of describing this behavior of <code>!</code> is that the never type
unifies with all other types. We're allowed to end this <code>match</code> arm with
<code>continue</code> because <code>continue</code> doesn't actually return a value; it instead moves
control back to the top of the loop, so in the <code>Err</code> case, we never actually
assign a value to <code>guess</code>.</p>
<p>Another use of the never type is <code>panic!</code>. Remember the <code>unwrap</code> function that
we call on <code>Option&lt;T&gt;</code> values to produce a value or panic? Here's its
definition:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<p>Here, the same thing happens as in the <code>match</code> in Listing 19-33: we know that
<code>val</code> has the type <code>T</code>, and <code>panic!</code> has the type <code>!</code>, so the result of the
overall <code>match</code> expression is <code>T</code>. This works because <code>panic!</code> doesn't produce
a value; it ends the program. In the <code>None</code> case, we won't be returning a value
from <code>unwrap</code>, so this code is valid.</p>
<p>One final expression that has the type <code>!</code> is a <code>loop</code>:</p>
<pre><code class="language-rust ignore">print!(&quot;forever &quot;);

loop {
    print!(&quot;and ever &quot;);
}
</code></pre>
<p>Here, the loop never ends, so the value of the expression is <code>!</code>. This wouldn't
be true if we included a <code>break</code>, however, as the loop would terminate when it
gets to the <code>break</code>.</p>
<a class="header" href="print.html#dynamically-sized-types--sized" id="dynamically-sized-types--sized"><h3>Dynamically Sized Types &amp; <code>Sized</code></h3></a>
<p>Because Rust needs to know things like memory layout, there's a particular
corner of its type system that can be confusing, and that's the concept of
<em>dynamically sized types</em>. Sometimes referred to as 'DSTs' or 'unsized types',
these types let us talk about types whose size we can only know at runtime.</p>
<p>Let's dig into the details of a dynamically sized type that we've been using
this whole book: <code>str</code>. That's right, not <code>&amp;str</code>, but <code>str</code> on its own. <code>str</code>
is a DST; we can't know how long the string is until runtime. Since we can't
know that, we can't create a variable of type <code>str</code>, nor can we take an
argument of type <code>str</code>. Consider this code, which does not work:</p>
<pre><code class="language-rust ignore">let s1: str = &quot;Hello there!&quot;;
let s2: str = &quot;How's it going?&quot;;
</code></pre>
<p>These two <code>str</code> values would need to have the exact same memory layout, but
they have different lengths: <code>s1</code> needs 12 bytes of storage, and <code>s2</code> needs 15.
This is why it's not possible to create a variable holding a dynamically sized
type.</p>
<p>So what to do? Well, you already know the answer in this case: the types of
<code>s1</code> and <code>s2</code> are <code>&amp;str</code> rather than <code>str</code>. If you think back to Chapter 4, we
said this about <code>&amp;str</code>:</p>
<blockquote>
<p>... it’s a reference to an internal position in the String and the number of
elements that it refers to.</p>
</blockquote>
<p>So while a <code>&amp;T</code> is a single value that stores the memory address of where the
<code>T</code> is located, a <code>&amp;str</code> is <em>two</em> values: the address of the <code>str</code> and how long
it is. As such, a <code>&amp;str</code> has a size we can know at compile time: it's two times
the size of a <code>usize</code> in length. That is, we always know the size of a <code>&amp;str</code>,
no matter how long the string it refers to is. This is the general way in which
dynamically sized types are used in Rust; they have an extra bit of metadata
that stores the size of the dynamic information. This leads us to the golden
rule of dynamically sized types: we must always put values of dynamically sized
types behind a pointer of some kind.</p>
<!-- Note for Carol: `Rc<str>` is only in an accepted RFC right now, check on
its progress and pull this out if it's not going to be stable by Oct -->
<p>While we've talked a lot about <code>&amp;str</code>, we can combine <code>str</code> with all kinds of
pointers: <code>Box&lt;str&gt;</code>, for example, or <code>Rc&lt;str&gt;</code>. In fact, you've already seen
this before, but with a different dynamically sized type: traits. Every trait
is a dynamically sized type we can refer to by using the name of the trait. In
Chapter 17, we mentioned that in order to use traits as trait objects, we have
to put them behind a pointer like <code>&amp;Trait</code> or <code>Box&lt;Trait&gt;</code> (<code>Rc&lt;Trait&gt;</code> would
work too). Traits being dynamically sized is the reason we have to do that!</p>
<a class="header" href="print.html#the-sized-trait" id="the-sized-trait"><h4>The <code>Sized</code> Trait</h4></a>
<!-- If we end up keeping the section on object safety in ch 17, we should add
a back reference here. /Carol -->
<p>To work with DSTs, Rust has a trait that determines if a type's size is known
at compile time or not, which is <code>Sized</code>. This trait is automatically
implemented for everything the compiler knows the size of at compile time. In
addition, Rust implicitly adds a bound on <code>Sized</code> to every generic function.
That is, a generic function definition like this:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
</code></pre>
<p>is actually treated as if we had written this:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
</code></pre>
<p>By default, generic functions will only work on types that have a known size at
compile time. There is, however, special syntax you can use to relax this
restriction:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
</code></pre>
<p>A trait bound on <code>?Sized</code> is the opposite of a trait bound on <code>Sized</code>; that is,
we would read this as &quot;<code>T</code> may or may not be <code>Sized</code>&quot;. This syntax is only
available for <code>Sized</code>, no other traits.</p>
<p>Also note we switched the type of the <code>t</code> parameter from <code>T</code> to <code>&amp;T</code>: since the
type might not be <code>Sized</code>, we need to use it behind some kind of pointer. In
this case, we've chosen a reference.</p>
<p>Next let's talk about functions and closures!</p>
<a class="header" href="print.html#advanced-functions--closures" id="advanced-functions--closures"><h2>Advanced Functions &amp; Closures</h2></a>
<p>Finally, let's discuss some advanced features having to do with functions and
closures: function pointers, diverging functions, and returning closures.</p>
<a class="header" href="print.html#function-pointers" id="function-pointers"><h3>Function pointers</h3></a>
<p>We've talked about how to pass closures to functions, but you can pass regular
functions to functions too! Functions have the type <code>fn</code>, with a lower case 'f'
not to be confused with the <code>Fn</code> closure trait. <code>fn</code> is called a <em>function
pointer</em>. The syntax for specifying that a parameter is a function pointer is
similar to that of closures, as shown in Listing 19-34:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&quot;The answer is: {}&quot;, answer);
}
</code></pre></pre>
<p><span class="caption">Listing 19-34: Using the <code>fn</code> type to accept a function
pointer as an argument</span></p>
<p>This prints <code>The answer is: 12</code>. We specify that the parameter <code>f</code> in
<code>do_twice</code> is an <code>fn</code> that takes one parameter of type <code>i32</code> and returns an
<code>i32</code>. We can then call <code>f</code> in the body of <code>do_twice</code>. In <code>main</code>, we can pass
the function name <code>add_one</code> as the first argument to <code>do_twice</code>.</p>
<p>Unlike closures, <code>fn</code> is a type rather than a trait, so we specify <code>fn</code> as the
parameter type directly rather than declaring a generic type parameter with one
of the <code>Fn</code> traits as a trait bound.</p>
<p>Function pointers implement all three of the closure traits (<code>Fn</code>, <code>FnMut</code>, and
<code>FnOnce</code>), so we can always pass a function pointer as an argument when calling
a function that expects a closure. Prefer to write functions using a generic
type and one of the closure traits, so that your functions can accept either
functions or closures. An example of a case where you'd only want to accept
<code>fn</code> is when interfacing with external code that doesn't have closures: C
functions can accept functions as arguments, but C doesn't have closures.</p>
<p>For example, if we wanted to use the <code>map</code> function to turn a vector of numbers
into a vector of strings, we could use a closure:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(|i| i.to_string())
    .collect();
#}</code></pre></pre>
<p>Or we could name a function as the argument to <code>map</code> instead of the closure:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(ToString::to_string)
    .collect();
#}</code></pre></pre>
<p>Note that we do have to use the fully qualified syntax that we talked about in
the &quot;Advanced Traits&quot; section because there are multiple functions available
named <code>to_string</code>; here, we're using the <code>to_string</code> function defined in the
<code>ToString</code> trait, which the standard library has implemented for any type that
implements <code>Display</code>.</p>
<p>Some people prefer this style, some people prefer the closure. They end up
with the same code, so use whichever feels more clear to you.</p>
<a class="header" href="print.html#returning-closures" id="returning-closures"><h3>Returning Closures</h3></a>
<p>Because closures are represented by traits, returning closures is a little
tricky; we can't do it directly. In most cases where we may want to return a
trait, we can instead use the concrete type that implements the trait of what
we're returning as the return value of the function. We can't do that with
closures, though. They don't have a concrete type that's returnable; we're not
allowed to use the function pointer <code>fn</code> as a return type, for example.</p>
<p>This code that tries to return a closure directly won't compile:</p>
<pre><code class="language-rust ignore">fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
    |x| x + 1
}
</code></pre>
<p>The compiler error is:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::ops::Fn(i32) -&gt; i32 + 'static:
std::marker::Sized` is not satisfied
 --&gt; &lt;anon&gt;:2:25
  |
2 | fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^ the trait `std::marker::Sized` is
  not implemented for `std::ops::Fn(i32) -&gt; i32 + 'static`
  |
  = note: `std::ops::Fn(i32) -&gt; i32 + 'static` does not have a constant size
  known at compile-time
  = note: the return type of a function must have a statically known size
</code></pre>
<p>The <code>Sized</code> trait again! Rust doesn't know much space it'll need to store the
closure. We saw a solution to this in the previous section, though: we can use
a trait object:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn returns_closure() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
#}</code></pre></pre>
<p>For more about trait objects, refer back to Chapter 18.</p>
<a class="header" href="print.html#summary-11" id="summary-11"><h2>Summary</h2></a>
<p>Whew! Now we've gone over features of Rust that aren't used very often, but are
available if you need them. We've introduced a lot of complex topics so that
when you encounter them in error message suggestions or when reading others'
code, you'll at least have seen these concepts and syntax once before.</p>
<p>Now, let's put everything we've learned throughout the book into practice with
one more project!</p>
<a class="header" href="print.html#final-project-building-a-multithreaded-web-server" id="final-project-building-a-multithreaded-web-server"><h1>Final Project: Building a Multithreaded Web Server</h1></a>
<p>It's been a long journey, but here we are! It's the end of the book. Parting is
such sweet sorrow. But before we go, let's build one more project together, to
show off some of the things we learned in these final chapters, as well as
re-cap some of the earlier ones.</p>
<p>Here's what we're going to make: a web server that says hello:</p>
<p><img src="hello.png" alt="hello from rust" /></p>
<p>To do this, we will:</p>
<ol>
<li>Learn a little bit about TCP and HTTP</li>
<li>Listen for TCP connections on a socket</li>
<li>Parse a tiny number of HTTP requests</li>
<li>Create a proper HTTP response</li>
<li>Improve the throughput of our server with a thread pool</li>
</ol>
<p>Before we get started, however, there's one thing we should mention: if you
were writing this code in production, there are a lot of better ways to write
it. Specifically, there are a number of robust crates on crates.io that provide
much more complete web server and thread pool implementations than we are going
to build.</p>
<p>However, for this chapter, our intention is to learn, not to take the easy
route. Since Rust is a systems programming language, we're able to choose what
level of abstraction we want to work with. We're able to go to a lower level
than is possible or practical in other languages if we so choose. So we'll be
writing a basic HTTP server and thread pool ourselves in order to learn the
general ideas and techniques behind the crates we might use in the future.</p>
<a class="header" href="print.html#a-single-threaded-web-server" id="a-single-threaded-web-server"><h2>A Single Threaded Web Server</h2></a>
<p>First, let's get a single threaded web server working. We're going to work with
the raw bytes of TCP and HTTP requests and responses to send HTML from our
server to a web browser. Let's start with a quick overview of the protocols
involved.</p>
<p>The <em>Hypertext Transfer Protocol</em> (<em>HTTP</em>) that powers the web is built on top
of the <em>Transmission Control Protocol</em> (<em>TCP</em>). We won't get into the details
too much, but here's a short overview: TCP is a low-level protocol, and HTTP
builds a higher-level protocol on top of TCP. Both protocols are what's called a
<em>request-response protocol</em>, that is, there is a <em>client</em> that initiates
requests, and a <em>server</em> that listens to requests and provides a response to
the client. The contents of those requests and responses are defined by the
protocols themselves.</p>
<p>TCP describes the low-level details of how information gets from one server to
another, but doesn't specify what that information is; it's just a bunch of
ones and zeroes. HTTP builds on top of TCP by defining what the content of the
requests and responses should be. As such, it's technically possible to use
HTTP with other protocols, but in the vast majority of cases, HTTP sends its
data over TCP.</p>
<p>So the first thing we need to build for our web server is to be able to listen
to a TCP connection. The standard library has a <code>std::net</code> module that lets us
do this. Let's make a new project:</p>
<pre><code class="language-text">$ cargo new hello --bin
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>And put the code in Listing 20-1 in <code>src/main.rs</code> to start. This code will
listen at the address <code>127.0.0.1:8080</code> for incoming TCP streams. When it gets
an incoming stream, it will print <code>Connection established!</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:8080&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!(&quot;Connection established!&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 20-1: Listening for incoming streams and printing
a message when we receive a stream</span></p>
<p>A <code>TcpListener</code> allows us to listen for TCP connections. We've chosen to listen
to the address <code>127.0.0.1:8080</code>. The part before the colon is an IP address
representing our own computer, and <code>8080</code> is the port. We've chosen this port
because HTTP is normally accepted on port 80, but connecting to port 80 requires
administrator privileges. Regular users can listen on ports higher than 1024;
8080 is easy to remember since it's the HTTP port 80 repeated.</p>
<p>The <code>bind</code> function is sort of like <code>new</code> in that it returns a new
<code>TcpListener</code> instance, but <code>bind</code> is a more descriptive name that fits with
the domain terminology. In networking, people will often talk about &quot;binding to
a port&quot;, so the function that the standard library defined to create a new
<code>TcpListener</code> is called <code>bind</code>.</p>
<p>The <code>bind</code> function returns a <code>Result&lt;T, E&gt;</code>. Binding may fail, for example, if
we had tried to connect to port 80 without being an administrator. Another
example of a case when binding would fail is if we tried to have two programs
listening to the same port, which would happen if we ran two instances of our
program. Since we're writing a basic server here, we're not going to worry
about handling these kinds of errors, and <code>unwrap</code> lets us just stop the
program if they happen.</p>
<p>The <code>incoming</code> method on <code>TcpListener</code> returns an iterator that gives us a
sequence of streams (more specifically, streams of type <code>TcpStream</code>). A
<em>stream</em> represents an open connection between the client and the server. A
<em>connection</em> is the name for the full request/response process when a client
connects to the server, the server generates a response, and the server closes
the connection. As such, the <code>TcpStream</code> will let us read from itself to see
what the client sent, and we can write our response to it. So this <code>for</code> loop
will process each connection in turn and produce a series of streams for us to
handle.</p>
<p>For now, handling a stream means calling <code>unwrap</code> to terminate our program if
the stream has any errors, then printing a message. Errors can happen because
we're not actually iterating over connections, we're iterating over <em>connection
attempts</em>. The connection might not work for a number of reasons, many of them
operating-system specific. For example, many operating systems have a limit to
the number of simultaneous open connections; new connection attempts will then
produce an error until some of the open connections are closed.</p>
<p>Let's try this code out! First invoke <code>cargo run</code> in the terminal, then load up
<code>127.0.0.1:8080</code> in a web browser. The browser will show an error message that
will say something similar to &quot;Connection reset&quot;, since we're not currently
sending any data back. If we look at our terminal, though, we'll see a bunch of
messages that were printed when the browser connected to the server!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>We got multiple messages printed out for one browser request; these connections
might be the browser making a request for the page and a request for a
<code>favicon.ico</code> icon that appears in the browser tab, or the browser might be
retrying the connection. Our browser is expecting to speak HTTP, but we aren't
replying with anything, just closing the connection by moving on to the next
loop iteration. When <code>stream</code> goes out of scope and dropped at the end of the
loop, its connection gets closed as part of the <code>drop</code> implementation for
<code>TcpStream</code>. Browsers sometimes deal with closed connections by retrying, since
the problem might be temporary. The important thing is that we've successfully
gotten a handle on a TCP connection!</p>
<p>Remember to stop the program with <code>CTRL-C</code> when you're done running a
particular version of the code, and restart <code>cargo run</code> after you've made each
set of code changes in order to be running the newest code.</p>
<a class="header" href="print.html#reading-the-request" id="reading-the-request"><h3>Reading the Request</h3></a>
<p>Let's read in the request from our browser! Since we're adding more
functionality that has the purpose of handling the connection, let's start a
new function to have a nice separation of the concerns around setting up the
server and connections versus processing each connection. In this new
<code>handle_connection</code> function, we'll read data from the <code>stream</code> and print it
out in order to see the data that the browser is sending us. Change the code to
look like Listing 20-2:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:8080&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&amp;mut buffer).unwrap();

    println!(&quot;Request: {}&quot;, String::from_utf8_lossy(&amp;buffer[..]));
}
</code></pre></pre>
<p><span class="caption">Listing 20-2: Reading from the <code>TcpStream</code> and printing
out the data</span></p>
<p>We added <code>std::io::prelude</code> to the beginning in order to bring traits into
scope that let us read from and write to the stream. Instead of printing a
message that we got a connection in the <code>for</code> loop in <code>main</code>, we're calling the
new <code>handle_connection</code> function and passing the <code>stream</code> to it.</p>
<p>In <code>handle_connection</code>, we made the <code>stream</code> parameter mutable with the <code>mut</code>
keyword. We're going to be reading data from the stream, so it's going to get
modified.</p>
<p>Next, we need to actually read from the stream. We do this in two steps: first,
we declare a <code>buffer</code> on the stack to hold the data that we read in. We've made
the buffer 512 bytes in size, which is big enough to hold the data of a basic
request. That's sufficient for our purposes in this chapter. If we wanted to
handle requests of an arbitrary size, managing the buffer would need to be more
complicated, but we're keeping it simple for now. We then pass the buffer to
<code>stream.read</code>, which will read bytes from the <code>TcpStream</code> and put them in the
buffer.</p>
<p>Then we convert the bytes in the buffer to a string and print out that string.
The <code>String::from_utf8_lossy</code> function takes a <code>&amp;[u8]</code> and produces a <code>String</code>.
The 'lossy' part of the name comes from the behavior when this function sees
invalid UTF-8 sequences: it replaces the invalid sequences with �, <code>U+FFFD REPLACEMENT CHARACTER</code>. You might see the replacement characters for remaining
characters in the buffer that aren't filled by request data.</p>
<p>Let's give this a try! Start up the program and make a request in a web browser
again. Note that we'll still get an error page in the browser, but the output
of our program in the terminal will now look similar to this:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42 secs
     Running `target/debug/hello`
Request: GET / HTTP/1.1
Host: 127.0.0.1:8080
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
������������������������������������
</code></pre>
<p>You'll probably get slightly different output depending on your browser. You
also might see this request repeated again. Now that we're printing out the
request data, we can see why we're getting multiple connections from one
browser request by looking at the path after <code>Request: GET</code>. If the repeated
connections are all requesting <code>/</code>, we know the browser is trying to fetch <code>/</code>
repeatedly since it's not getting a response from us.</p>
<p>Let's break down this request data to understand what the browser is asking of
us. HTTP is a text-based protocol, and a request takes this format:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is called the <em>request line</em>, and it holds information about
what the client is requesting. The first part of the request line is a
<em>method</em>, like <code>GET</code> or <code>POST</code>, that describes how the client is making this
request.</p>
<p>Then comes the request's <em>URI</em>, which stands for <em>Uniform Resource Identifier</em>.
URIs are almost, but not quite the same as URLs (<em>Uniform Resource Locators</em>),
which is what we typically call the addresses that we enter into a web browser.
The HTTP spec uses the term URI, and the difference between URIs and URLs isn't
important for our purposes of this chapter, so we can just mentally substitute
URL for URI here.</p>
<p>Next, we have the HTTP version that the client used, and then the request line
ends in a CRLF sequence. The CRLF sequence can also be written as <code>\r\n</code>: <code>\r</code>
is a <em>carriage return</em> and <code>\n</code> is a <em>line feed</em>. These terms come from the
typewriter days! The CRLF sequence separates the request line from the rest of
the request data.</p>
<p>Taking a look at the request line data we saw printed out by our code:</p>
<pre><code class="language-text">GET / HTTP/1.1
</code></pre>
<p><code>GET</code> is the method, <code>/</code> is the Request URI, and <code>HTTP/1.1</code> is the version.</p>
<p>The remaining lines starting from <code>Host:</code> onward are headers; <code>GET</code> requests
have no body.</p>
<p>Try making a request from a different browser, or asking for a different
address like <code>127.0.0.1:8080/test</code> to see how the request data changes, if
you'd like.</p>
<p>Now that we know what the browser is asking for, let's send some data back!</p>
<a class="header" href="print.html#writing-a-response" id="writing-a-response"><h3>Writing a Response</h3></a>
<p>Let's send data back to our browser in response to its request. Responses have
this format:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is called a <em>status line</em> and contains the HTTP version used in
the response, a numeric status code that summarizes the result of the request,
and a reason phrase that provides a text description of the status code. After
the CRLF sequence comes any headers, another CRLF sequence, and the body of the
response.</p>
<p>Here's an example response that uses version 1.1 of HTTP, has a status code of
<code>200</code>, a reason phrase of <code>OK</code>, no headers, and no body:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>This text is a tiny successful HTTP response. Let's write this to the stream!
Remove the <code>println!</code> that was printing the request data, and add the code in
Listing 20-3 in its place:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&amp;mut buffer).unwrap();

    let response = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-3: Writing a tiny successful HTTP response to
the stream</span></p>
<p>The first new line defines the <code>response</code> variable that holds the data of the
tiny success response we're sending back. Then, we call <code>as_bytes</code> on our
<code>response</code> because the <code>write</code> method on <code>stream</code> takes a <code>&amp;[u8]</code> and sends
those bytes directly down the connection.</p>
<p>The <code>write</code> operation could fail, so <code>write</code> returns a <code>Result&lt;T, E&gt;</code>; we're
continuing to use <code>unwrap</code> to make progress on the core ideas in this chapter
rather than error handling. Finally, <code>flush</code> will wait until all of the bytes
are written to the connection; <code>TcpStream</code> contains an internal buffer to
minimize calls into the underlying operating system.</p>
<p>With these changes, let's run our code and make a request! We're no longer
printing any data to the terminal, so we won't see any output there other than
the output from Cargo. When we load <code>127.0.0.1:8080</code> in a web browser, though,
we get a blank page instead of an error. How exciting! You've just hand-coded
an HTTP request and response.</p>
<a class="header" href="print.html#returning-real-html" id="returning-real-html"><h3>Returning Real HTML</h3></a>
<p>Let's return more than a blank page. Create a new file, <em>hello.html</em>, in the
root of your project directory, that is, not in the <code>src</code> directory. You can
put any HTML you want in it; Listing 20-4 shows what the authors used for
theirs:</p>
<p><span class="filename">Filename: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listing 20-4: A sample HTML file to return in a
response</span></p>
<p>This is a minimal HTML 5 document with a heading and a little paragraph. Let's
modify <code>handle_connection</code> as shown in Listing 20-5 to read the HTML file, add
it to the response as a body, and send it:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
use std::fs::File;

// ...snip...

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let mut file = File::open(&quot;hello.html&quot;).unwrap();

    let mut contents = String::new();
    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-5: Sending the contents of <em>hello.html</em> as the
body of the response</span></p>
<p>We've added a line at the top to bring the standard library's <code>File</code> into
scope, and the file opening and reading code should look familiar since we had
similar code in Chapter 12 when we read the contents of a file for our I/O
project in Listing 12-4.</p>
<p>Next, we're using <code>format!</code> to add the file's contents as the body of the
success response that we write to the stream.</p>
<p>Run it with <code>cargo run</code>, load up <code>127.0.0.1:8080</code> in your browser, and you
should see your HTML rendered!</p>
<p>Note that we're currently ignoring the request data in <code>buffer</code> and sending
back the contents of the HTML file unconditionally. Try requesting
<code>127.0.0.1:8080/something-else</code> in your browser and you'll get back your HTML
for that request too. Sending back the same response for all requests is pretty
limited and not what most web servers do; let's examine the request and only
send back the HTML file for a well-formed request to <code>/</code>.</p>
<a class="header" href="print.html#validating-the-request-and-selectively-responding" id="validating-the-request-and-selectively-responding"><h3>Validating the Request and Selectively Responding</h3></a>
<p>Right now, our web server will return the HTML in the file no matter what the
client requested. Let's check that the browser is requesting <code>/</code>, and instead
return an error if the browser requests anything else. Let's modify
<code>handle_connection</code> as shown in Listing 20-6, which adds part of the code we'll
need. This part checks the content of the request we received against what we
know a request for <code>/</code> looks like and adds <code>if</code> and <code>else</code> blocks where we'll
add code to treat requests differently:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
// ...snip...

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;

    if buffer.starts_with(get) {
        let mut file = File::open(&quot;hello.html&quot;).unwrap();

        let mut contents = String::new();
        file.read_to_string(&amp;mut contents).unwrap();

        let response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, contents);

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    } else {
        // some other request
    };
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-6: Matching the request against the content we
expect for a request to <code>/</code> and setting up conditionally handling requests to
<code>/</code> differently than other requests</span></p>
<p>Here, we hardcoded the data corresponding to the request that we're looking for
in the variable <code>get</code>. Because we're reading raw bytes into the buffer, we use
a byte string, created with <code>b&quot;&quot;</code>, to make <code>get</code> a byte string too. Then, we
check to see if <code>buffer</code> starts with the bytes in <code>get</code>. If it does, we've
gotten a well-formed request to <code>/</code>, which is the success case that we want to
handle in the <code>if</code> block. The <code>if</code> block contains the code we added in Listing
20-5 that returns the contents of our HTML file.</p>
<p>If <code>buffer</code> does not start with the bytes in <code>get</code>, we've gotten some other
request. We'll respond to all other requests using the code we're about to add
in the <code>else</code> block.</p>
<p>If you run this code and request <code>127.0.0.1:8080</code>, you'll get the HTML that's
in <em>hello.html</em>. If you make any other request, such as
<code>127.0.0.1:8080/something-else</code>, you'll get a connection error like we saw when
running the code in Listing 20-1 and Listing 20-2.</p>
<p>Let's add code to the <code>else</code> block as shown in Listing 20-7 to return a
response with the status code <code>404</code>, which signals that the content for the
request was not found. We'll also return HTML for a page to render in the
browser indicating as such to the end user:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
# fn handle_connection(mut stream: TcpStream) {
# if true {
// ...snip...

} else {
    let header = &quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;;
    let mut file = File::open(&quot;404.html&quot;).unwrap();
    let mut contents = String::new();

    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;{}{}&quot;, header, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
# }
#}</code></pre></pre>
<p><span class="caption">Listing 20-7: Responding with status code <code>404</code> and an
error page if anything other than <code>/</code> was requested</span></p>
<p>Here, our response has a header with status code <code>404</code> and the reason phrase
<code>NOT FOUND</code>. We still aren't returning any headers, and the body of the
response will be the HTML in the file <em>404.html</em>. Also create a <em>404.html</em> file
next to <em>hello.html</em> for the error page; again feel free to use any HTML you'd
like or use the example HTML in Listing 20-8:</p>
<p><span class="filename">Filename: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listing 20-8: Sample content for the page to send back
with any <code>404</code> response</span></p>
<p>With these changes, try running your server again. Requesting <code>127.0.0.1:8080</code>
should return the contents of <em>hello.html</em>, and any other request, like
<code>127.0.0.1:8080/foo</code>, should return the error HTML from <em>404.html</em>!</p>
<p>There's a lot of repetition between the code in the <code>if</code> and the <code>else</code> blocks:
they're both reading files and writing the contents of the files to the stream.
The only differences between the two cases are the status line and the
filename. Let's pull those differences out into an <code>if</code> and <code>else</code> of one line
each that will assign the values of the status line and the filename to
variables; we can then use those variables unconditionally in the code to read
the file and write the response. The resulting code after this refactoring is
shown in Listing 20-9:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
// ...snip...

fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 512];
#     stream.read(&amp;mut buffer).unwrap();
#
#     let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    // ...snip...

   let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    let mut file = File::open(filename).unwrap();
    let mut contents = String::new();

    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-9: Refactoring so that the <code>if</code> and <code>else</code>
blocks only contain the code that differs between the two cases</span></p>
<p>Here, the only thing the <code>if</code> and <code>else</code> blocks do is return the appropriate
values for the status line and filename in a tuple; we then use destructuring
to assign these two bits to <code>filename</code> and <code>header</code> using a pattern in the
<code>let</code> statement like we discussed in Chapter 18.</p>
<p>The duplicated code to read the file and write the response is now outside the
<code>if</code> and <code>else</code> blocks, and uses the <code>status_line</code> and <code>filename</code> variables.
This makes it easier to see exactly what's different between the two cases, and
makes it so that we only have one place to update the code if we want to change
how the file reading and response writing works. The behavior of the code in
Listing 20-9 will be exactly the same as that in Listing 20-8.</p>
<p>Awesome! We have a simple little web server in about 40 lines of Rust code that
responds to one request with a page of content and responds to all other
requests with a <code>404</code> response.</p>
<p>Since this server runs in a single thread, though, it can only serve one
request at a time. Let's see how that can be a problem by simulating some
slow requests.</p>
<a class="header" href="print.html#how-slow-requests-affect-throughput" id="how-slow-requests-affect-throughput"><h2>How Slow Requests Affect Throughput</h2></a>
<p>Right now, the server will process each request in turn. That works for
services like ours that aren't expected to get very many requests, but as
applications get more complex, this sort of serial execution isn't optimal.</p>
<p>Because our current program processes connections sequentially, it won't
process a second connection until it's completed processing the first. If we
get one request that takes a long time to process, requests coming in during
that time will have to wait until the long request is finished, even if the new
requests can be processed quickly. Let's see this in action.</p>
<a class="header" href="print.html#simulating-a-slow-request-in-the-current-server-implementation" id="simulating-a-slow-request-in-the-current-server-implementation"><h3>Simulating a Slow Request in the Current Server Implementation</h3></a>
<p>Let's see the effect of a request that takes a long time to process on requests
made to our current server implementation. Listing 20-10 shows the code to
respond to another request, <code>/sleep</code>, that will cause the server to sleep for
five seconds before responding. This will simulate a slow request so that we
can see that our server processes requests serially.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::time::Duration;
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
// ...snip...

fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 512];
#     stream.read(&amp;mut buffer).unwrap();
    // ...snip...

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    // ...snip...
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-10: Simulating a slow request by recognizing
<code>/sleep</code> and sleeping for 5 seconds</span></p>
<p>This code is a bit messy, but it's good enough for our simulation purposes! We
created a second request <code>sleep</code>, whose data we'll recognize. We added an <code>else if</code> after the <code>if</code> block to check for the request to <code>/sleep</code>, and when we see
that request, we'll sleep for five seconds before rendering the hello page.</p>
<p>You can really see how primitive our server is here; real libraries would
handle the recognition of multiple requests in a less verbose way!</p>
<p>Start the server with <code>cargo run</code>, and then open up two browser windows: one
for <code>http://localhost:8080/</code> and one for <code>http://localhost:8080/sleep</code>. If
you hit <code>/</code> a few times, as before, you'll see it respond quickly. But if you
hit <code>/sleep</code>, and then load up <code>/</code>, you'll see that <code>/</code> waits until <code>sleep</code>
has slept for its full five seconds before going on.</p>
<p>There are multiple ways we could change how our web server works in order to
avoid having all requests back up behind a slow request; the one we're going to
implement is a thread pool.</p>
<a class="header" href="print.html#improving-throughput-with-a-thread-pool" id="improving-throughput-with-a-thread-pool"><h3>Improving Throughput with a Thread Pool</h3></a>
<p>A <em>thread pool</em> is a group of spawned threads that are ready to handle some
task. When the program receives a new task, one of the threads in the pool will
be assigned the task and will go off and process it. The remaining threads in
the pool are available to handle any other tasks that come in while the first
thread is processing. When the first thread is done processing its task, it
gets returned to the pool of idle threads ready to handle a new task.</p>
<p>A thread pool will allow us to process connections concurrently: we can start
processing a new connection before an older connection is finished. This
increases the throughput of our server.</p>
<p>Here's what we're going to implement: instead of waiting for each request to
process before starting on the next one, we'll send the processing of each
connection to a different thread. The threads will come from a pool of four
threads that we'll spawn when we start our program. The reason we're limiting
the number of threads to a small number is that if we created a new thread for
each request as the requests come in, someone making ten million requests to
our server could create havoc by using up all of our server's resources and
grinding the processing of all requests to a halt.</p>
<p>Rather than spawning unlimited threads, we'll have a fixed number of threads
waiting in the pool. As requests come in, we'll send the requests to the pool
for processing. The pool will maintain a queue of incoming requests. Each of
the threads in the pool will pop a request off of this queue, handle the
request, and then ask the queue for another request. With this design, we can
process <code>N</code> requests concurrently, where <code>N</code> is the number of threads. This
still means that <code>N</code> long-running requests can cause requests to back up in the
queue, but we've increased the number of long-running requests we can handle
before that point from one to <code>N</code>.</p>
<p>This design is one of many ways to improve the throughput of our web server.
This isn't a book about web servers, though, so it's the one we're going to
cover. Other options are the fork/join model and the single threaded async I/O
model. If you're interested in this topic, you may want to read more about
other solutions and try to implement them in Rust; with a low-level language
like Rust, all of these options are possible.</p>
<a class="header" href="print.html#designing-the-thread-pool-interface" id="designing-the-thread-pool-interface"><h2>Designing the Thread Pool Interface</h2></a>
<p>Let's talk about what using the pool should look like. The authors often find
that when trying to design some code, writing the client interface first can
really help guide your design. Write the API of the code to be structured in
the way you'd want to call it, then implement the functionality within that
structure rather than implementing the functionality then designing the public
API.</p>
<p>Similar to how we used Test Driven Development in the project in Chapter 12,
we're going to use Compiler Driven Development here. We're going to write the
code that calls the functions we wish we had, then we'll lean on the compiler
to tell us what we should change next. The compiler error messages will guide
our implementation.</p>
<a class="header" href="print.html#code-structure-if-we-could-use-threadspawn" id="code-structure-if-we-could-use-threadspawn"><h3>Code Structure if We Could Use <code>thread::spawn</code></h3></a>
<p>First, let's explore what the code to create a new thread for every connection
could look like. This isn't our final plan due to the problems with potentially
spawning an unlimited number of threads that we talked about earlier, but it's
a start. Listing 20-11 shows the changes to <code>main</code> to spawn a new thread to
handle each stream within the <code>for</code> loop:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run"># use std::thread;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
#
fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:8080&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
# fn handle_connection(mut stream: TcpStream) {}
</code></pre></pre>
<p><span class="caption">Listing 20-11: Spawning a new thread for each
stream</span></p>
<p>As we learned in Chapter 16, <code>thread::spawn</code> will create a new thread and then
run the code in the closure in it. If you run this code and load <code>/sleep</code> and
then <code>/</code> in two browser tabs, you'll indeed see the request to <code>/</code> doesn't have
to wait for <code>/sleep</code> to finish. But as we mentioned, this will eventually
overwhelm the system since we're making new threads without any limit.</p>
<a class="header" href="print.html#creating-a-similar-interface-for-threadpool" id="creating-a-similar-interface-for-threadpool"><h3>Creating a Similar Interface for <code>ThreadPool</code></h3></a>
<p>We want our thread pool to work in a similar, familiar way so that switching
from threads to a thread pool doesn't require large changes to the code we want
to run in the pool. Listing 20-12 shows the hypothetical interface for a
<code>ThreadPool</code> struct we'd like to use instead of <code>thread::spawn</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run"># use std::thread;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# struct ThreadPool;
# impl ThreadPool {
#    fn new(size: u32) -&gt; ThreadPool { ThreadPool }
#    fn execute&lt;F&gt;(&amp;self, f: F)
#        where F: FnOnce() + Send + 'static {}
# }
#
fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:8080&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
# fn handle_connection(mut stream: TcpStream) {}
</code></pre></pre>
<p><span class="caption">Listing 20-12: How we want to be able to use the
<code>ThreadPool</code> we're going to implement</span></p>
<p>We use <code>ThreadPool::new</code> to create a new thread pool with a configurable number
of threads, in this case four. Then, in the <code>for</code> loop, <code>pool.execute</code> will
work in a similar way to <code>thread::spawn</code>.</p>
<a class="header" href="print.html#compiler-driven-development-to-get-the-api-compiling" id="compiler-driven-development-to-get-the-api-compiling"><h3>Compiler Driven Development to Get the API Compiling</h3></a>
<p>Go ahead and make the changes in Listing 20-12 to <em>src/main.rs</em>, and let's use
the compiler errors to drive our development. Here's the first error we get:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve. Use of undeclared type or module `ThreadPool`
  --&gt; src\main.rs:10:16
   |
10 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^ Use of undeclared type or module
   `ThreadPool`

error: aborting due to previous error
</code></pre>
<p>Great, we need a <code>ThreadPool</code>. Let's switch the <code>hello</code> crate from a binary
crate to a library crate to hold our <code>ThreadPool</code> implementation, since the
thread pool implementation will be independent of the particular kind of work
that we're doing in our web server. Once we've got the thread pool library
written, we could use that functionality to do whatever work we want to do, not
just serve web requests.</p>
<p>So create <em>src/lib.rs</em> that contains the simplest definition of a <code>ThreadPool</code>
struct that we can have for now:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct ThreadPool;
#}</code></pre></pre>
<p>Then create a new directory, <em>src/bin</em>, and move the binary crate rooted in
<em>src/main.rs</em> into <em>src/bin/main.rs</em>. This will make the library crate be the
primary crate in the <em>hello</em> directory; we can still run the binary in
<em>src/bin/main.rs</em> using <code>cargo run</code> though. After moving the <em>main.rs</em> file,
edit it to bring the library crate in and bring <code>ThreadPool</code> into scope by
adding this at the top of <em>src/bin/main.rs</em>:</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello;
use hello::ThreadPool;
</code></pre>
<p>And try again in order to get the next error that we need to address:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error: no associated item named `new` found for type `hello::ThreadPool` in the
current scope
  --&gt; src\main.rs:13:16
   |
13 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^
   |
</code></pre>
<p>Cool, the next thing is to create an associated function named <code>new</code> for
<code>ThreadPool</code>. We also know that <code>new</code> needs to have one parameter that can
accept <code>4</code> as an argument, and <code>new</code> should return a <code>ThreadPool</code> instance.
Let's implement the simplest <code>new</code> function that will have those
characteristics:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: u32) -&gt; ThreadPool {
        ThreadPool
    }
}
#}</code></pre></pre>
<p>We picked <code>u32</code> as the type of the <code>size</code> parameter, since we know that a
negative number of threads makes no sense. <code>u32</code> is a solid default. Once we
actually implement <code>new</code> for real, we'll reconsider whether this is the right
choice for what the implementation needs, but for now, we're just working
through compiler errors.</p>
<p>Let's check the code again:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: `size`, #[warn(unused_variables)] on by default
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: u32) -&gt; ThreadPool {
  |                ^^^^

error: no method named `execute` found for type `hello::ThreadPool` in the
current scope
  --&gt; src/main.rs:18:14
   |
18 |         pool.execute(|| {
   |              ^^^^^^^
</code></pre>
<p>Okay, a warning and an error. Ignoring the warning for a moment, the error is
because we don't have an <code>execute</code> method on <code>ThreadPool</code>. Let's define one,
and we need it to take a closure. If you remember from Chapter 13, we can take
closures as arguments with three different traits: <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code>.
What kind of closure should we use? Well, we know we're going to end up doing
something similar to <code>thread::spawn</code>; what bounds does the signature of
<code>thread::spawn</code> have on its argument? Let's look at the documentation, which
says:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<p><code>F</code> is the parameter we care about here; <code>T</code> is related to the return value and
we're not concerned with that. Given that <code>spawn</code> uses <code>FnOnce</code> as the trait
bound on <code>F</code>, it's probably what we want as well, since we'll eventually be
passing the argument we get in <code>execute</code> to <code>spawn</code>. We can be further
confident that <code>FnOnce</code> is the trait that we want to use since the thread for
running a request is only going to execute that request's closure one time.</p>
<p><code>F</code> also has the trait bound <code>Send</code> and the lifetime bound <code>'static</code>, which
also make sense for our situation: we need <code>Send</code> to transfer the closure from
one thread to another, and <code>'static</code> because we don't know how long the thread
will execute. Let's create an <code>execute</code> method on <code>ThreadPool</code> that will take a
generic parameter <code>F</code> with these bounds:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct ThreadPool;
impl ThreadPool {
    // ...snip...

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {

    }
}
#}</code></pre></pre>
<p>The <code>FnOnce</code> trait still needs the <code>()</code> after it since this <code>FnOnce</code> is
representing a closure that takes no parameters and doesn't return a value.
Just like function definitions, the return type can be omitted from the
signature, but even if we have no parameters, we still need the parentheses.</p>
<p>Again, since we're working on getting the interface compiling, we're adding the
simplest implementation of the <code>execute</code> method, which does nothing. Let's
check again:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: `size`, #[warn(unused_variables)] on by default
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: u32) -&gt; ThreadPool {
  |                ^^^^

warning: unused variable: `f`, #[warn(unused_variables)] on by default
 --&gt; src/lib.rs:8:30
  |
8 |     pub fn execute&lt;F&gt;(&amp;self, f: F)
  |                              ^
</code></pre>
<p>Only warnings now! It compiles! Note that if you try <code>cargo run</code> and making a
request in the browser, though, you'll see the errors in the browser again that
we saw in the beginning of the chapter. Our library isn't actually calling the
closure passed to <code>execute</code> yet!</p>
<blockquote>
<p>A saying you might hear about languages with strict compilers like Haskell
and Rust is &quot;if the code compiles, it works.&quot; This is a good time to remember
that this is just a phrase and a feeling people sometimes have, it's not
actually universally true. Our project compiles, but it does absolutely
nothing! If we were building a real, complete project, this would be a great
time to start writing unit tests to check that the code compiles <em>and</em> has
the behavior we want.</p>
</blockquote>
<a class="header" href="print.html#creating-the-thread-pool-and-storing-threads" id="creating-the-thread-pool-and-storing-threads"><h2>Creating the Thread Pool and Storing Threads</h2></a>
<p>The warnings are because we aren't doing anything with the parameters to <code>new</code>
and <code>execute</code>. Let's implement the bodies of both of these with the actual
behavior we want.</p>
<a class="header" href="print.html#validating-the-number-of-threads-in-the-pool" id="validating-the-number-of-threads-in-the-pool"><h3>Validating the Number of Threads in the Pool</h3></a>
<p>To start, let's think about <code>new</code>. We mentioned before that we picked an
unsigned type for the <code>size</code> parameter since a pool with a negative number of
threads makes no sense. However, a pool with zero threads also makes no sense,
yet zero is a perfectly valid <code>u32</code>. Let's check that <code>size</code> is greater than
zero before we return a <code>ThreadPool</code> instance and panic if we get zero by using
the <code>assert!</code> macro as shown in Listing 20-13:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct ThreadPool;
impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: u32) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // ...snip...
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-13: Implementing <code>ThreadPool::new</code> to panic if
<code>size</code> is zero</span></p>
<p>We've taken this opportunity to add some documentation for our <code>ThreadPool</code>
with doc comments. Note that we followed good documentation practices and added
a section that calls out the situations in which our function can panic as we
discussed in Chapter 14. Try running <code>cargo doc --open</code> and clicking on the
<code>ThreadPool</code> struct to see what the generate docs for <code>new</code> look like!</p>
<p>Instead of adding the use of the <code>assert!</code> macro as we've done here, we could
make <code>new</code> return a <code>Result</code> instead like we did with <code>Config::new</code> in the I/O
project in Listing 12-9, but we've decided in this case that trying to create a
thread pool without any threads should be an unrecoverable error. If you're
feeling ambitious, try to write a version of <code>new</code> with this signature to see
how you feel about both versions:</p>
<pre><code class="language-rust ignore">fn new(size: u32) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {
</code></pre>
<a class="header" href="print.html#storing-threads-in-the-pool" id="storing-threads-in-the-pool"><h3>Storing Threads in the Pool</h3></a>
<p>Now that we know we have a valid number of threads to store in the pool, we can
actually create that many threads and store them in the <code>ThreadPool</code> struct
before returning it.</p>
<p>This raises a question: how do we &quot;store&quot; a thread? Let's take another look at
the signature of <code>thread::spawn</code>:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<p><code>spawn</code> returns a <code>JoinHandle&lt;T&gt;</code>, where <code>T</code> is the type that's returned from
the closure. Let's try using <code>JoinHandle</code> too and see what happens. In our
case, the closures we're passing to the thread pool will handle the connection
and not return anything, so <code>T</code> will be the unit type <code>()</code>.</p>
<p>This won't compile yet, but let's consider the code shown in Listing 20-14.
We've changed the definition of <code>ThreadPool</code> to hold a vector of
<code>thread::JoinHandle&lt;()&gt;</code> instances, initialized the vector with a capacity of
<code>size</code>, set up a <code>for</code> loop that will run some code to create the threads, and
returned a <code>ThreadPool</code> instance containing them:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // ...snip...
    pub fn new(size: u32) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool {
            threads
        }
    }

    // ...snip...
}
</code></pre>
<p><span class="caption">Listing 20-14: Creating a vector for <code>ThreadPool</code> to hold
the threads</span></p>
<p>We've brought <code>std::thread</code> into scope in the library crate, since we're using
<code>thread::JoinHandle</code> as the type of the items in the vector in <code>ThreadPool</code>.</p>
<p>After we have a valid size, we're creating a new vector that can hold <code>size</code>
items. We haven't used <code>with_capacity</code> in this book yet; it does the same thing
as <code>Vec::new</code>, but with an important difference: it pre-allocates space in the
vector. Since we know that we need to store <code>size</code> elements in the vector,
doing this allocation up-front is slightly more efficient than only writing
<code>Vec::new</code>, since <code>Vec::new</code> resizes itself as elements get inserted. Since
we've created a vector the exact size that we need up front, no resizing of the
underlying vector will happen while we populate the items.</p>
<p>That is, if this code works, which it doesn't quite yet! If we check this code,
we get an error:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0308]: mismatched types
  --&gt; src\main.rs:70:46
   |
70 |         let mut threads = Vec::with_capacity(size);
   |                                              ^^^^ expected usize, found u32

error: aborting due to previous error
</code></pre>
<p><code>size</code> is a <code>u32</code>, but <code>Vec::with_capacity</code> needs a <code>usize</code>. We have two
options here: we can change our function's signature, or we can cast the <code>u32</code>
as a <code>usize</code>. If you remember when we defined <code>new</code>, we didn't think too hard
about what number type made sense, we just chose one. Let's give it some more
thought now. Given that <code>size</code> is the length of a vector, <code>usize</code> makes a lot
of sense. They even almost share a name! Let's change the signature of <code>new</code>,
which will get the code in Listing 20-14 to compile:</p>
<pre><code class="language-rust ignore">fn new(size: usize) -&gt; ThreadPool {
</code></pre>
<p>If run <code>cargo check</code> again, you'll get a few more warnings, but it should
succeed.</p>
<p>We left a comment in the <code>for</code> loop in Listing 20-14 regarding the creation of
threads. How do we actually create threads? This is a tough question. What
should go in these threads? We don't know what work they need to do at this
point, since the <code>execute</code> method takes the closure and gives it to the pool.</p>
<p>Let's refactor slightly: instead of storing a vector of <code>JoinHandle&lt;()&gt;</code>
instances, let's create a new struct to represent the concept of a <em>worker</em>. A
worker will be what receives a closure in the <code>execute</code> method, and it will
take care of actually calling the closure. In addition to letting us store a
fixed <code>size</code> number of <code>Worker</code> instances that don't yet know about the
closures they're going to be executing, we can also give each worker an <code>id</code> so
we can tell the different workers in the pool apart when logging or debugging.</p>
<p>Let's make these changes:</p>
<ol>
<li>Define a <code>Worker</code> struct that holds an <code>id</code> and a <code>JoinHandle&lt;()&gt;</code></li>
<li>Change <code>ThreadPool</code> to hold a vector of <code>Worker</code> instances</li>
<li>Define a <code>Worker::new</code> function that takes an <code>id</code> number and returns a
<code>Worker</code> instance with that <code>id</code> and a thread spawned with an empty closure,
which we'll fix soon</li>
<li>In <code>ThreadPool::new</code>, use the <code>for</code> loop counter to generate an <code>id</code>, create
a new <code>Worker</code> with that <code>id</code>, and store the worker in the vector</li>
</ol>
<p>If you're up for a challenge, try implementing these changes on your own before
taking a look at the code in Listing 20-15.</p>
<p>Ready? Here's Listing 20-15 with one way to make these modifications:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // ...snip...
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers
        }
    }
    // ...snip...
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker {
            id,
            thread,
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-15: Modifying <code>ThreadPool</code> to hold <code>Worker</code>
instances instead of threads directly</span></p>
<p>We've chosen to change the name of the field on <code>ThreadPool</code> from <code>threads</code> to
<code>workers</code> since we've changed what we're holding, which is now <code>Worker</code>
instances instead of <code>JoinHandle&lt;()&gt;</code> instances. We use the counter in the
<code>for</code> loop as an argument to <code>Worker::new</code>, and we store each new <code>Worker</code> in
the vector named <code>workers</code>.</p>
<p>The <code>Worker</code> struct and its <code>new</code> function are private since external code
(like our server in <em>src/bin/main.rs</em>) doesn't need to know the implementation
detail that we're using a <code>Worker</code> struct within <code>ThreadPool</code>. The
<code>Worker::new</code> function uses the given <code>id</code> and stores a <code>JoinHandle&lt;()&gt;</code>
created by spawning a new thread using an empty closure.</p>
<p>This code compiles and is storing the number of <code>Worker</code> instances that we
specified as an argument to <code>ThreadPool::new</code>, but we're <em>still</em> not processing
the closure that we get in <code>execute</code>. Let's talk about how to do that next.</p>
<a class="header" href="print.html#sending-requests-to-threads-via-channels" id="sending-requests-to-threads-via-channels"><h2>Sending Requests to Threads Via Channels</h2></a>
<p>The next problem to tackle is that our closures do absolutely nothing. We've
been working around the problem that we get the actual closure we want to
execute in the <code>execute</code> method, but it feels like we need to know the actual
closures when we create the <code>ThreadPool</code>.</p>
<p>Let's think about what we really want to do though: we want the <code>Worker</code>
structs that we just created to fetch jobs from a queue that the <code>ThreadPool</code>
holds, and run those jobs in a thread.</p>
<p>In Chapter 16, we learned about channels. Channels are a great way to
communicate between two threads, and they're perfect for this use-case. The
channel will function as the queue of jobs, and <code>execute</code> will send a job from
the <code>ThreadPool</code> to the <code>Worker</code> instances that are checking for jobs in the
thread they've spawned. Here's the plan:</p>
<ol>
<li><code>ThreadPool</code> will create a channel and hold on to the sending side.</li>
<li>Each <code>Worker</code> will hold on to the receiving side of the channel.</li>
<li>A new <code>Job</code> struct will hold the closures we want to send down the channel.</li>
<li>The <code>execute</code> method of <code>ThreadPool</code> will send the job it wants
to execute down the sending side of the channel.</li>
<li>In a thread, the <code>Worker</code> will loop over its receiving side of the channel
and execute the closures of any jobs it receives.</li>
</ol>
<p>Let's start by creating a channel in <code>ThreadPool::new</code> and holding the sending
side in the <code>ThreadPool</code> instance, as shown in Listing 20-16. <code>Job</code> is the type
of item we're going to be sending down the channel; it's a struct that doesn't
hold anything for now:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
// ...snip...
use std::sync::mpsc;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // ...snip...
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers,
            sender,
        }
    }
    // ...snip...
}
#
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle&lt;()&gt;,
# }
#
# impl Worker {
#     fn new(id: usize) -&gt; Worker {
#         let thread = thread::spawn(|| {});
#
#         Worker {
#             id,
#             thread,
#         }
#     }
# }
#}</code></pre></pre>
<p><span class="caption">Listing 20-16: Modifying <code>ThreadPool</code> to store the
sending end of a channel that sends <code>Job</code> instances</span></p>
<p>In <code>ThreadPool::new</code>, we create our new channel, and then have the pool hang on
to the sending end. This will successfully compile, still with warnings.</p>
<p>Let's try passing a receiving end of the channel into each worker when the
thread pool creates them. We know we want to use the receiving end of the
channel in the thread that the workers spawn, so we're going to reference the
<code>receiver</code> parameter in the closure. The code shown here in Listing 20-17
won't quite compile yet:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl ThreadPool {
    // ...snip...
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool {
            workers,
            sender,
        }
    }
    // ...snip...
}

// ...snip...

impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-17: Passing the receiving end of the channel
to the workers</span></p>
<p>These are small and straightforward changes: we pass in the receiving end of
the channel into <code>Worker::new</code>, and then we use it inside of the closure.</p>
<p>If we try to check this, we get this error:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:27:42
   |
27 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here in
   previous iteration of loop
   |
   = note: move occurs because `receiver` has type
   `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
</code></pre>
<p>The code as written won't quite work since it's trying to pass <code>receiver</code> to
multiple <code>Worker</code> instances. Recall from Chapter 16 that the channel
implementation provided by Rust is multiple <em>producer</em>, single <em>consumer</em>, so
we can't just clone the consuming end of the channel to fix this. We also don't
want to clone the consuming end even if we wanted to; sharing the single
<code>receiver</code> between all of the workers is the mechanism by which we'd like to
distribute the jobs across the threads.</p>
<p>Additionally, taking a job off the channel queue involves mutating <code>receiver</code>,
so the threads need a safe way to share <code>receiver</code> and be allowed to modify it.
If the modifications weren't threadsafe, we might get race conditions such as
two threads executing the same job if they both take the same job off the queue
at the same time.</p>
<p>So remembering the threadsafe smart pointers that we discussed in Chapter 16,
in order to share ownership across multiple threads and allow the threads to
mutate the value, we need to use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. <code>Arc</code> will let multiple
workers own the receiver, and <code>Mutex</code> will make sure that only one worker is
getting a job from the receiver at a time. Listing 20-18 shows the changes we
need to make:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;

// ...snip...

# pub struct ThreadPool {
#     workers: Vec&lt;Worker&gt;,
#     sender: mpsc::Sender&lt;Job&gt;,
# }
# struct Job;
#
impl ThreadPool {
    // ...snip...
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver.clone()));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    // ...snip...
}
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle&lt;()&gt;,
# }
#
impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // ...snip...
#         let thread = thread::spawn(|| {
#            receiver;
#         });
#
#         Worker {
#             id,
#             thread,
#         }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 20-18: Sharing the receiving end of the channel
between the workers by using <code>Arc</code> and <code>Mutex</code></span></p>
<p>In <code>ThreadPool::new</code>, we put the receiving end of the channel in an <code>Arc</code> and a
<code>Mutex</code>. For each new worker, we clone the <code>Arc</code> to bump the reference count so
the workers can share ownership of the receiving end.</p>
<p>With these changes, the code compiles! We're getting there!</p>
<p>Let's finally implement the <code>execute</code> method on <code>ThreadPool</code>. We're also going
to change the <code>Job</code> struct: instead of being a struct, <code>Job</code> is going to be a
type alias for a trait object that holds the type of closure that <code>execute</code>
receives. We discussed how type aliases can help make long types shorter, and
this is such a case! Take a look at Listing 20-19:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// ...snip...
# pub struct ThreadPool {
#     workers: Vec&lt;Worker&gt;,
#     sender: mpsc::Sender&lt;Job&gt;,
# }
# use std::sync::mpsc;
# struct Worker {}

type Job = Box&lt;FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // ...snip...

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// ...snip...
#}</code></pre></pre>
<p><span class="caption">Listing 20-19: Creating a <code>Job</code> type alias for a <code>Box</code>
that holds each closure, then sending the job down the channel</span></p>
<p>After creating a new <code>Job</code> instance using the closure we get in
<code>execute</code>, we send that job down the sending end of the channel. We're calling
<code>unwrap</code> on <code>send</code> since sending may fail if the receiving end has stopped
receiving new messages, which would happen if we stop all of our threads from
executing. This isn't possible right now, though, since our threads continue
executing as long as the pool exists. We use <code>unwrap</code> since we know the failure
case won't happen even though the compiler can't tell that, which is an
appropriate use of <code>unwrap</code> as we discussed in Chapter 9.</p>
<p>Are we done yet? Not quite! In the worker, we've still got a closure being
passed to <code>thread::spawn</code> that only <em>references</em> the receiving end of the
channel. Instead, we need the closure to loop forever, asking the receiving end
of the channel for a job, and running the job when it gets one. Let's make the
change shown in Listing 20-20 to <code>Worker::new</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">// ...snip...

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!(&quot;Worker {} got a job; executing.&quot;, id);

                (*job)();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-20: Receiving and executing the jobs in the
worker's thread</span></p>
<p>Here, we first call <code>lock</code> on the <code>receiver</code> to acquire the mutex, then
<code>unwrap</code> to panic on any errors. Acquiring a lock might fail if the mutex is in
a state called <em>poisoned</em>, which can happen if some other thread panicked while
holding the lock rather than releasing it. If this thread can't get the lock
for that reason, calling <code>unwrap</code> to have this thread panic is the correct
action to take as well. Feel free to change this <code>unwrap</code> to an <code>expect</code> with
an error message that is meaningful to you if you'd like.</p>
<p>If we get the lock on the mutex, then we call <code>recv</code> to receive a <code>Job</code> from
the channel. A final <code>unwrap</code> moves past those errors as well. <code>recv</code> will
return <code>Err</code> if the thread holding the sending side of the channel has shut
down, similar to how the <code>send</code> method returns <code>Err</code> if the receiving side
shuts down.</p>
<p>The call to <code>recv</code> blocks; that is, if there's no job yet, this thread will sit
here until a job becomes available. The <code>Mutex&lt;T&gt;</code> makes sure that only one
<code>Worker</code> thread at a time is trying to request a job.</p>
<p>Theoretically, this code should compile. Unfortunately, the Rust compiler isn't
perfect yet, and we get this error:</p>
<pre><code class="language-text">error[E0161]: cannot move a value of type std::ops::FnOnce() +
std::marker::Send: the size of std::ops::FnOnce() + std::marker::Send cannot be
statically determined
  --&gt; src/lib.rs:63:17
   |
63 |                 (*job)();
   |                 ^^^^^^
</code></pre>
<p>This error is fairly cryptic, and that's because the problem is fairly cryptic.
In order to call a <code>FnOnce</code> closure that is stored in a <code>Box&lt;T&gt;</code> (which is what
our <code>Job</code> type alias is), the closure needs to be able to move itself out of
the <code>Box&lt;T&gt;</code> since when we call the closure, it takes ownership of <code>self</code>. In
general, moving a value out of a <code>Box&lt;T&gt;</code> isn't allowed since Rust doesn't know
how big the value inside the <code>Box&lt;T&gt;</code> is going to be; recall in Chapter 15 that
we used <code>Box&lt;T&gt;</code> precisely because we had something of an unknown size that we
wanted to store in a <code>Box&lt;T&gt;</code> to get a value of a known size.</p>
<p>We saw in Chapter 17, Listing 17-15 that we can write methods that use the
syntax <code>self: Box&lt;Self&gt;</code> so that the method takes ownership of a <code>Self</code> value
that is stored in a <code>Box&lt;T&gt;</code>. That's what we want to do here, but unfortunately
the part of Rust that implements what happens when we call a closure isn't
implemented using <code>self: Box&lt;Self&gt;</code>. So Rust doesn't yet understand that it
could use <code>self: Box&lt;Self&gt;</code> in this situation in order to take ownership of the
closure and move the closure out of the <code>Box&lt;T&gt;</code>.</p>
<p>In the future, the code in Listing 20-20 should work just fine. Rust is still a
work in progress with places that the compiler could be improved. There are
people just like you working to fix this and other issues! Once you've finished
the book, we would love for you to join in.</p>
<p>But for now, let's work around this problem. Luckily, there's a trick that
involves telling Rust explicitly that we're in a case where we can take
ownership of the value inside the <code>Box&lt;T&gt;</code> using <code>self: Box&lt;Self&gt;</code>, and once we
have ownership of the closure, we can call it. This involves defining a new
trait that has a method <code>call_box</code> that uses <code>self: Box&lt;Self&gt;</code> in its
signature, defining that trait for any type that implements <code>FnOnce()</code>,
changing our type alias to use the new trait, and changing <code>Worker</code> to use the
<code>call_box</code> method. These changes are shown in Listing 20-21:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;FnBox + Send + 'static&gt;;

// ...snip...

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!(&quot;Worker {} got a job; executing.&quot;, id);

                job.call_box();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-21: Adding a new trait <code>FnBox</code> to work around
the current limitations of <code>Box&lt;FnOnce()&gt;</code></span></p>
<p>First, we create a new trait named <code>FnBox</code>. This trait has one method,
<code>call_box</code>, similar to the <code>call</code> methods on the other <code>Fn*</code> traits, except
this method takes <code>self: Box&lt;Self&gt;</code> in order to take ownership of <code>self</code> and
move the value out of the <code>Box&lt;T&gt;</code>.</p>
<p>Next, we implement the <code>FnBox</code> trait for any type <code>F</code> that implements the
<code>FnOnce()</code> trait. Effectively, this means that any <code>FnOnce()</code> closures can use
our <code>call_box</code> method. The implementation of <code>call_box</code> uses <code>(*self)()</code> to
move the closure out of the <code>Box&lt;T&gt;</code> and call the closure.</p>
<p>Instead of <code>FnOnce()</code>, we now want our <code>Job</code> type alias to be a <code>Box</code> of
anything that implements our new trait <code>FnBox</code>. This will allow us to use
<code>call_box</code> in <code>Worker</code> when we get a <code>Job</code> value. Because we implemented the
<code>FnBox</code> trait for any <code>FnOnce()</code> closure, we don't have to change anything
about the actual values we're sending down the channel.</p>
<p>Finally, in the closure run in the thread in <code>Worker::new</code>, we use <code>call_box</code>
instead of invoking the closure directly. Now Rust is able to understand that
what we want to do is fine.</p>
<p>This is a very sneaky, complicated trick. Don't worry too much if it doesn't
make perfect sense; someday, it will be completely unnecessary.</p>
<p>With this trick, our thread pool is in a working state! Give it a <code>cargo run</code>,
and make some requests:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never used: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: field is never used: `id`
  --&gt; src/lib.rs:61:5
   |
61 |     id: usize,
   |     ^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

warning: field is never used: `thread`
  --&gt; src/lib.rs:62:5
   |
62 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.99 secs
     Running `target/debug/hello`
     Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>Success! We now have a thread pool executing connections asynchronously. We
never create more than four threads, so our system won't get overloaded if the
server gets a lot of requests. If we make a request to <code>/sleep</code>, the server
will be able to serve other requests by having another thread run them.</p>
<p>What about those warnings, though? Don't we use the <code>workers</code>, <code>id</code>, and
<code>thread</code> fields? Well, right now, we're using all three of these fields to hold
onto some data, but we don't actually <em>do</em> anything with the data once we've
set up the thread pool and started running the code that sends jobs down the
channel to the threads. If we didn't hold onto these values, though, they'd go
out of scope: for example, if we didn't return the <code>Vec&lt;Worker&gt;</code> value as part
of the <code>ThreadPool</code>, the vector would get cleaned up at the end of
<code>ThreadPool::new</code>.</p>
<p>So are these warnings wrong? In one sense yes, the warnings are wrong, since we
are using the fields to store data we need to keep around. In another sense,
no, the warnings aren't wrong, and they're telling us that we've forgotten to
do something: we never do anything to clean up our thread pool once it's done
being used, we just use <code>CTRL-C</code> to stop the program and let the operating
system clean up after us. Let's implement a graceful shutdown that cleans up
everything we've created instead.</p>
<a class="header" href="print.html#graceful-shutdown-and-cleanup" id="graceful-shutdown-and-cleanup"><h2>Graceful Shutdown and Cleanup</h2></a>
<p>The code in Listing 20-21 is responding to requests asynchronously through the
use of a thread pool, as we intended. We get some warnings about fields that
we're not using in a direct way, which are a reminder that we're not cleaning
anything up. When we use <code>CTRL-C</code> to halt the main thread, all the other
threads are stopped immediately as well, even if they're in the middle of
serving a request.</p>
<p>We're now going to implement the <code>Drop</code> trait for <code>ThreadPool</code> to call <code>join</code>
on each of the threads in the pool so that the threads will finish the requests
they're working on. Then we'll implement a way for the <code>ThreadPool</code> to tell the
threads they should stop accepting new requests and shut down. To see this code
in action, we'll modify our server to only accept two requests before
gracefully shutting down its thread pool.</p>
<p>Let's start with implementing <code>Drop</code> for our thread pool. When the pool is
dropped, we should join on all of our threads to make sure they finish their
work. Listing 20-22 shows a first attempt at a <code>Drop</code> implementation; this code
won't quite work yet:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-22: Joining each thread when the thread pool
goes out of scope</span></p>
<p>We loop through each of the thread pool <code>workers</code>, using <code>&amp;mut</code> because <code>self</code>
is itself a mutable reference and we also need to be able to mutate <code>worker</code>.
We print out a message saying that this particular worker is shutting down, and
then we call <code>join</code> on that worker's thread. If the call to <code>join</code> fails, we
<code>unwrap</code> the error to panic and go into an ungraceful shutdown.</p>
<p>Here's the error we get if we compile this code:</p>
<pre><code class="language-text">error[E0507]: cannot move out of borrowed content
  --&gt; src/lib.rs:65:13
   |
65 |             worker.thread.join().unwrap();
   |             ^^^^^^ cannot move out of borrowed content
</code></pre>
<p>Because we only have a mutable borrow of each <code>worker</code>, we can't call <code>join</code>:
<code>join</code> takes ownership of its argument. In order to solve this, we need a way
to move the <code>thread</code> out of the <code>Worker</code> instance that owns <code>thread</code> so that
<code>join</code> can consume the thread. We saw a way to do this in Listing 17-15: if the
<code>Worker</code> holds an <code>Option&lt;thread::JoinHandle&lt;()&gt;</code> instead, we can call the
<code>take</code> method on the <code>Option</code> to move the value out of the <code>Some</code> variant and
leave a <code>None</code> variant in its place. In other words, a <code>Worker</code> that is running
will have a <code>Some</code> variant in <code>thread</code>, and when we want to clean up a worker,
we'll replace <code>Some</code> with <code>None</code> so the worker doesn't have a thread to run.</p>
<p>So we know we want to update the definition of <code>Worker</code> like this:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
#}</code></pre></pre>
<p>Now let's lean on the compiler to find the other places that need to change. We
get two errors:</p>
<pre><code class="language-text">error: no method named `join` found for type
`std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;` in the current scope
  --&gt; src/lib.rs:65:27
   |
65 |             worker.thread.join().unwrap();
   |                           ^^^^

error[E0308]: mismatched types
  --&gt; src/lib.rs:89:21
   |
89 |             thread,
   |             ^^^^^^ expected enum `std::option::Option`, found
   struct `std::thread::JoinHandle`
   |
   = note: expected type `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`
              found type `std::thread::JoinHandle&lt;_&gt;`
</code></pre>
<p>The second error is pointing to the code at the end of <code>Worker::new</code>; we need
to wrap the <code>thread</code> value in <code>Some</code> when we create a new <code>Worker</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // ...snip...

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p>The first error is in our <code>Drop</code> implementation, and we mentioned that we'll be
calling <code>take</code> on the <code>Option</code> value to move <code>thread</code> out of <code>worker</code>. Here's
what that looks like:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<p>As we saw in Chapter 17, the <code>take</code> method on <code>Option</code> takes the <code>Some</code> variant
out and leaves <code>None</code> in its place. We're using <code>if let</code> to destructure the
<code>Some</code> and get the thread, then call <code>join</code> on the thread. If a worker's thread
is already <code>None</code>, then we know this worker has already had its thread cleaned
up so we don't do anything in that case.</p>
<p>With this, our code compiles without any warnings. Bad news though, this code
doesn't function the way we want it to yet. The key is the logic in the
closures that the spawned threads of the <code>Worker</code> instances run: calling <code>join</code>
won't shut down the threads since they <code>loop</code> forever looking for jobs. If we
try to drop our <code>ThreadPool</code> with this implementation, the main thread will
block forever waiting for the first thread to finish.</p>
<p>To fix this, we're going to modify the threads to listen for either a <code>Job</code> to
run or a signal that they should stop listening and exit the infinite loop. So
instead of <code>Job</code> instances, our channel will send one of these two enum
variants:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Job;
enum Message {
    NewJob(Job),
    Terminate,
}
#}</code></pre></pre>
<p>This <code>Message</code> enum will either be a <code>NewJob</code> variant that holds the <code>Job</code> the
thread should run, or it will be a <code>Terminate</code> variant that will cause the
thread to exit its loop and stop.</p>
<p>We need to adjust the channel to use values of type <code>Message</code> rather than type
<code>Job</code>, as shown in Listing 20-23:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

// ...snip...

impl ThreadPool {
    // ...snip...
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        // ...snip...
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

// ...snip...

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-23: Sending and receiving <code>Message</code> values and
exiting the loop if a <code>Worker</code> receives <code>Message::Terminate</code></span></p>
<p>We need to change <code>Job</code> to <code>Message</code> in the definition of <code>ThreadPool</code>, in
<code>ThreadPool::new</code> where we create the channel, and in the signature of
<code>Worker::new</code>. The <code>execute</code> method of <code>ThreadPool</code> needs to send jobs wrapped
in the <code>Message::NewJob</code> variant. Then, in <code>Worker::new</code> where we receive a
<code>Message</code> from the channel, we'll process the job if we get the <code>NewJob</code>
variant and break out of the loop if we get the <code>Terminate</code> variant.</p>
<p>With these changes, the code will compile again and continue to function in the
same way as it has been. We'll get a warning, though, because we aren't using
the <code>Terminate</code> variant in any messages. Let's change our <code>Drop</code> implementation
to look like Listing 20-24:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-24: Sending <code>Message::Terminate</code> to the
workers before calling <code>join</code> on each worker thread</span></p>
<p>We're now iterating over the workers twice, once to send one <code>Terminate</code>
message for each worker, and once to call <code>join</code> on each worker's thread. If we
tried to send a message and join immediately in the same loop, it's not
guaranteed that the worker in the current iteration will be the one that gets
the message from the channel.</p>
<p>To understand better why we need two separate loops, imagine a scenario with
two workers. If we iterated through each worker in one loop, on the first
iteration where <code>worker</code> is the first worker, we'd send a terminate message
down the channel and call <code>join</code> on the first worker's thread. If the first
worker was busy processing a request at that moment, the second worker would
pick up the terminate message from the channel and shut down. We're waiting on
the first worker to shut down, but it never will since the second thread picked
up the terminate message. We're now blocking forever waiting for the first
worker to shut down, and we'll never send the second message to terminate.
Deadlock!</p>
<p>To prevent this, we first put all of our <code>Terminate</code> messages on the channel,
and then we join on all the threads. Because each worker will stop receiving
requests on the channel once it gets a terminate message, we can be sure that
if we send the same number of terminate messages as there are workers, each
worker will receive a terminate message before we call <code>join</code> on its thread.</p>
<p>In order to see this code in action, let's modify <code>main</code> to only accept two
requests before gracefully shutting the server down as shown in Listing 20-25:</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:8080&quot;).unwrap();
    let pool = ThreadPool::new(4);

    let mut counter = 0;

    for stream in listener.incoming() {
        if counter == 2 {
            println!(&quot;Shutting down.&quot;);
            break;
        }

        counter += 1;

        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
</code></pre>
<p><span class="caption">Listing 20-25: Shut down the server after serving two
requests by exiting the loop</span></p>
<p>Only serving two requests isn't behavior you'd like a production web server to
have, but this will let us see the graceful shutdown and cleanup working since
we won't be stopping the server with <code>CTRL-C</code>.</p>
<p>We've added a <code>counter</code> variable that we'll increment every time we receive an
incoming TCP stream. If that counter reaches 2, we'll stop serving requests and
instead break out of the <code>for</code> loop. The <code>ThreadPool</code> will go out of scope at
the end of <code>main</code>, and we'll see the <code>drop</code> implementation run.</p>
<p>Start the server with <code>cargo run</code>, and make three requests. The third request
should error, and in your terminal you should see output that looks like:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0 secs
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 3 got a job; executing.
Shutting down.
Sending terminate message to all workers.
Shutting down all workers.
Shutting down worker 0
Worker 1 was told to terminate.
Worker 2 was told to terminate.
Worker 0 was told to terminate.
Worker 3 was told to terminate.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>You may get a different ordering, of course. We can see how this works from the
messages: workers zero and three got the first two requests, and then on the
third request, we stop accepting connections. When the <code>ThreadPool</code> goes out of
scope at the end of <code>main</code>, its <code>Drop</code> implementation kicks in, and the pool
tells all workers to terminate. The workers each print a message when they see
the terminate message, and then the thread pool calls <code>join</code> to shut down each
worker thread.</p>
<p>One interesting aspect of this particular execution: notice that we sent the
terminate messages down the channel, and before any worker received the
messages, we tried to join worker zero. Worker zero had not yet gotten the
terminate message, so the main thread blocked waiting for worker zero to
finish. In the meantime, each of the workers received the termination messages.
Once worker zero finished, the main thread waited for the rest of the workers
to finish, and they had all received the termination message and were able to
shut down at that point.</p>
<p>Congrats! We now have completed our project, and we have a basic web server
that uses a thread pool to respond asynchronously. We're able to perform a
graceful shutdown of the server, which cleans up all the threads in the pool.
Here's the full code for reference:</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello;
use hello::ThreadPool;

use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::fs::File;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:8080&quot;).unwrap();
    let pool = ThreadPool::new(4);

    let mut counter = 0;

    for stream in listener.incoming() {
        if counter == 2 {
            println!(&quot;Shutting down.&quot;);
            break;
        }

        counter += 1;

        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

     let mut file = File::open(filename).unwrap();
     let mut contents = String::new();

     file.read_to_string(&amp;mut contents).unwrap();

     let response = format!(&quot;{}{}&quot;, status_line, contents);

     stream.write(response.as_bytes()).unwrap();
     stream.flush().unwrap();
}
</code></pre>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;

enum Message {
    NewJob(Job),
    Terminate,
}

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;FnBox + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver.clone()));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
#}</code></pre></pre>
<p>There's more we could do here! If you'd like to continue enhancing this
project, here are some ideas:</p>
<ul>
<li>Add more documentation to <code>ThreadPool</code> and its public methods</li>
<li>Add tests of the library's functionality</li>
<li>Change calls to <code>unwrap</code> to more robust error handling</li>
<li>Use <code>ThreadPool</code> to perform some other task rather than serving web requests</li>
<li>Find a thread pool crate on crates.io and implement a similar web server
using the crate instead and compare its API and robustness to the thread pool
we implemented</li>
</ul>
<a class="header" href="print.html#summary-12" id="summary-12"><h2>Summary</h2></a>
<p>Well done! You've made it to the end of the book! We'd like to thank you for
joining us on this tour of Rust. You're now ready to go out and implement your
own Rust projects or help with other people's. Remember there's a community of
other Rustaceans who would love to help you with any challenges you encounter
on your Rust journey.</p>
<a class="header" href="print.html#appendix" id="appendix"><h1>Appendix</h1></a>
<p>The following sections contain reference material you may find useful in your
Rust journey.</p>
<a class="header" href="print.html#appendix-a-keywords" id="appendix-a-keywords"><h2>Appendix A: Keywords</h2></a>
<p>The following keywords are reserved by the Rust language and may not be used as
identifiers such as names of functions, variables, parameters, struct fields,
modules, crates, constants, macros, static values, attributes, types, traits,
or lifetimes.</p>
<a class="header" href="print.html#keywords-currently-in-use" id="keywords-currently-in-use"><h3>Keywords Currently in Use</h3></a>
<ul>
<li><code>as</code> - primitive casting, disambiguating the specific trait containing an
item, or renaming items in <code>use</code> and <code>extern crate</code> statements</li>
<li><code>break</code> - exit a loop immediately</li>
<li><code>const</code> - constant items and constant raw pointers</li>
<li><code>continue</code> - continue to the next loop iteration</li>
<li><code>crate</code> - external crate linkage or a macro variable representing the crate
in which the macro is defined</li>
<li><code>else</code> - fallback for <code>if</code> and <code>if let</code> control flow constructs</li>
<li><code>enum</code> - defining an enumeration</li>
<li><code>extern</code> - external crate, function, and variable linkage</li>
<li><code>false</code> - boolean false literal</li>
<li><code>fn</code> - function definition and function pointer type</li>
<li><code>for</code> - iterator loop, part of trait impl syntax, and higher-ranked lifetime
syntax</li>
<li><code>if</code> - conditional branching</li>
<li><code>impl</code> - inherent and trait implementation block</li>
<li><code>in</code> - part of <code>for</code> loop syntax</li>
<li><code>let</code> - variable binding</li>
<li><code>loop</code> - unconditional, infinite loop</li>
<li><code>match</code> - pattern matching</li>
<li><code>mod</code> - module declaration</li>
<li><code>move</code> - makes a closure take ownership of all its captures</li>
<li><code>mut</code> - denotes mutability in references, raw pointers, and pattern bindings</li>
<li><code>pub</code> - denotes public visibility in struct fields, <code>impl</code> blocks, and modules</li>
<li><code>ref</code> - by-reference binding</li>
<li><code>return</code> - return from function</li>
<li><code>Self</code> - type alias for the type implementing a trait</li>
<li><code>self</code> - method subject or current module</li>
<li><code>static</code> - global variable or lifetime lasting the entire program execution</li>
<li><code>struct</code> - structure definition</li>
<li><code>super</code> - parent module of the current module</li>
<li><code>trait</code> - trait definition</li>
<li><code>true</code> - boolean true literal</li>
<li><code>type</code> - type alias and associated type definition</li>
<li><code>unsafe</code> - denotes unsafe code, functions, traits, and implementations</li>
<li><code>use</code> - import symbols into scope</li>
<li><code>where</code> - type constraint clauses</li>
<li><code>while</code> - conditional loop</li>
</ul>
<a class="header" href="print.html#keywords-reserved-for-future-use" id="keywords-reserved-for-future-use"><h3>Keywords Reserved for Future Use</h3></a>
<p>These keywords do not have any functionality, but are reserved by Rust for
potential future use.</p>
<ul>
<li><code>abstract</code></li>
<li><code>alignof</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>offsetof</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>proc</code></li>
<li><code>pure</code></li>
<li><code>sizeof</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<a class="header" href="print.html#appendix-b-operators" id="appendix-b-operators"><h2>Appendix B: Operators</h2></a>
<a class="header" href="print.html#unary-operator-expressions" id="unary-operator-expressions"><h3>Unary operator expressions</h3></a>
<p>Rust defines the following unary operators. They are all written as prefix
operators, before the expression they apply to.</p>
<ul>
<li><code>-</code>
: Negation. Signed integer types and floating-point types support negation. It
is an error to apply negation to unsigned types; for example, the compiler
rejects <code>-1u32</code>.</li>
<li><code>*</code>
: Dereference. When applied to a pointer, it denotes the pointed-to location.
For pointers to mutable locations, the resulting value can be assigned to.
On non-pointer types, it calls the <code>deref</code> method of the <code>std::ops::Deref</code>
trait, or the <code>deref_mut</code> method of the <code>std::ops::DerefMut</code> trait (if
implemented by the type and required for an outer expression that will or
could mutate the dereference), and produces the result of dereferencing the
<code>&amp;</code> or <code>&amp;mut</code> borrowed pointer returned from the overload method.</li>
<li><code>!</code>
: Logical negation. On the boolean type, this flips between <code>true</code> and
<code>false</code>. On integer types, this inverts the individual bits in the
two's complement representation of the value.</li>
<li><code>&amp;</code> and <code>&amp;mut</code>
: Borrowing. When applied to a value, these operators produce a
reference (pointer) to that value. The value is also placed into
a borrowed state for the duration of the reference. For a shared
borrow (<code>&amp;</code>), this implies that the value may not be mutated, but
it may be read or shared again. For a mutable borrow (<code>&amp;mut</code>), the
value may not be accessed in any way until the borrow expires.</li>
</ul>
<a class="header" href="print.html#binary-operator-expressions" id="binary-operator-expressions"><h3>Binary operator expressions</h3></a>
<p>Binary operators expressions are given in order of operator precedence.</p>
<a class="header" href="print.html#arithmetic-operators" id="arithmetic-operators"><h4>Arithmetic operators</h4></a>
<p>Binary arithmetic expressions are syntactic sugar for calls to built-in traits,
defined in the <code>std::ops</code> module of the <code>std</code> library. This means arithmetic
operators can be overridden for user-defined types. The default meaning of the
operators on standard types is given here.</p>
<ul>
<li><code>+</code>
: Addition and array/string concatenation.
Calls the <code>add</code> method on the <code>std::ops::Add</code> trait.</li>
<li><code>-</code>
: Subtraction.
Calls the <code>sub</code> method on the <code>std::ops::Sub</code> trait.</li>
<li><code>*</code>
: Multiplication.
Calls the <code>mul</code> method on the <code>std::ops::Mul</code> trait.</li>
<li><code>/</code>
: Quotient.
Calls the <code>div</code> method on the <code>std::ops::Div</code> trait.</li>
<li><code>%</code>
: Remainder.
Calls the <code>rem</code> method on the <code>std::ops::Rem</code> trait.</li>
</ul>
<p>Note that Rust does not have a built-in operator for exponential (power)
calculation; see the <code>pow</code> method on the numeric types.</p>
<a class="header" href="print.html#bitwise-operators" id="bitwise-operators"><h4>Bitwise operators</h4></a>
<p>Like the arithmetic operators, bitwise operators are syntactic sugar for calls
to methods of built-in traits. This means bitwise operators can be overridden
for user-defined types. The default meaning of the operators on standard types
is given here. Bitwise <code>&amp;</code>, <code>|</code> and <code>^</code> applied to boolean arguments are
equivalent to logical <code>&amp;&amp;</code>, <code>||</code> and <code>!=</code> evaluated in non-lazy fashion.</p>
<ul>
<li><code>&amp;</code>
: Bitwise AND.
Calls the <code>bitand</code> method of the <code>std::ops::BitAnd</code> trait.</li>
<li><code>|</code>
: Bitwise inclusive OR.
Calls the <code>bitor</code> method of the <code>std::ops::BitOr</code> trait.</li>
<li><code>^</code>
: Bitwise exclusive OR.
Calls the <code>bitxor</code> method of the <code>std::ops::BitXor</code> trait.</li>
<li><code>&lt;&lt;</code>
: Left shift.
Calls the <code>shl</code> method of the <code>std::ops::Shl</code> trait.</li>
<li><code>&gt;&gt;</code>
: Right shift (arithmetic).
Calls the <code>shr</code> method of the <code>std::ops::Shr</code> trait.</li>
</ul>
<a class="header" href="print.html#lazy-boolean-operators" id="lazy-boolean-operators"><h4>Lazy boolean operators</h4></a>
<p>The operators <code>||</code> and <code>&amp;&amp;</code> may be applied to operands of boolean type. The
<code>||</code> operator denotes logical 'or', and the <code>&amp;&amp;</code> operator denotes logical
'and'. They differ from <code>|</code> and <code>&amp;</code> in that the right-hand operand is only
evaluated when the left-hand operand does not already determine the result of
the expression. That is, <code>||</code> only evaluates its right-hand operand when the
left-hand operand evaluates to <code>false</code>, and <code>&amp;&amp;</code> only when it evaluates to
<code>true</code>.</p>
<a class="header" href="print.html#comparison-operators" id="comparison-operators"><h4>Comparison operators</h4></a>
<p>Comparison operators are, like the arithmetic operators and bitwise operators,
syntactic sugar for calls to built-in traits. This means that comparison
operators can be overridden for user-defined types. The default meaning of the
operators on standard types is given here.</p>
<ul>
<li><code>==</code>
: Equal to.
Calls the <code>eq</code> method on the <code>std::cmp::PartialEq</code> trait.</li>
<li><code>!=</code>
: Unequal to.
Calls the <code>ne</code> method on the <code>std::cmp::PartialEq</code> trait.</li>
<li><code>&lt;</code>
: Less than.
Calls the <code>lt</code> method on the <code>std::cmp::PartialOrd</code> trait.</li>
<li><code>&gt;</code>
: Greater than.
Calls the <code>gt</code> method on the <code>std::cmp::PartialOrd</code> trait.</li>
<li><code>&lt;=</code>
: Less than or equal.
Calls the <code>le</code> method on the <code>std::cmp::PartialOrd</code> trait.</li>
<li><code>&gt;=</code>
: Greater than or equal.
Calls the <code>ge</code> method on the <code>std::cmp::PartialOrd</code> trait.</li>
</ul>
<a class="header" href="print.html#type-cast-expressions" id="type-cast-expressions"><h4>Type cast expressions</h4></a>
<p>A type cast expression is denoted with the binary operator <code>as</code>.</p>
<p>Executing an <code>as</code> expression casts the value on the left-hand side to the type
on the right-hand side.</p>
<p>An example of an <code>as</code> expression:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn sum(values: &amp;[f64]) -&gt; f64 { 0.0 }
# fn len(values: &amp;[f64]) -&gt; i32 { 0 }

fn average(values: &amp;[f64]) -&gt; f64 {
    let sum: f64 = sum(values);
    let size: f64 = len(values) as f64;
    sum / size
}
#}</code></pre></pre>
<p>Some of the conversions which can be done through the <code>as</code> operator
can also be done implicitly at various points in the program, such as
argument passing and assignment to a <code>let</code> binding with an explicit
type. Implicit conversions are limited to &quot;harmless&quot; conversions that
do not lose information and which have minimal or no risk of
surprising side-effects on the dynamic execution semantics.</p>
<a class="header" href="print.html#assignment-expressions" id="assignment-expressions"><h4>Assignment expressions</h4></a>
<p>An <em>assignment expression</em> consists of a pattern followed by an equals
sign (<code>=</code>) and an expression.</p>
<p>Evaluating an assignment expression either copies or
moves its right-hand operand to its left-hand
operand.</p>
<pre><code># let mut x = 0;
# let y = 0;
x = y;
</code></pre>
<a class="header" href="print.html#compound-assignment-expressions" id="compound-assignment-expressions"><h4>Compound assignment expressions</h4></a>
<p>The <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, and <code>&gt;&gt;</code> operators may be
composed with the <code>=</code> operator. The expression <code>lval OP= val</code> is equivalent to
<code>lval = lval OP val</code>. For example, <code>x = x + 1</code> may be written as <code>x += 1</code>.</p>
<p>Any such expression always has the <code>unit</code> type.</p>
<a class="header" href="print.html#operator-precedence" id="operator-precedence"><h4>Operator precedence</h4></a>
<p>The precedence of Rust binary operators is ordered as follows, going from
strong to weak:</p>
<pre><code class="language-text">as :
* / %
+ -
&lt;&lt; &gt;&gt;
&amp;
^
|
== != &lt; &gt; &lt;= &gt;=
&amp;&amp;
||
.. ...
&lt;-
=
</code></pre>
<p>Operators at the same precedence level are evaluated left-to-right. Unary
operators have the same precedence level and are stronger than any of the
binary operators.</p>
<a class="header" href="print.html#appendix-g---newest-features" id="appendix-g---newest-features"><h1>Appendix G - Newest Features</h1></a>
<p>This appendix documents features that have been added to stable Rust since the
main part of the book was completed.</p>
<a class="header" href="print.html#field-init-shorthand" id="field-init-shorthand"><h2>Field init shorthand</h2></a>
<p>We can initialize a data structure (struct, enum, union) with named
fields, by writing <code>fieldname</code> as a shorthand for <code>fieldname: fieldname</code>.
This allows a compact syntax for initialization, with less duplication:</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

fn main() {
    let name = String::from(&quot;Peter&quot;);
    let age = 27;

    // Using full syntax:
    let peter = Person { name: name, age: age };

    let name = String::from(&quot;Portia&quot;);
    let age = 27;

    // Using field init shorthand:
    let portia = Person { name, age };

    println!(&quot;{:?}&quot;, portia);
}
</code></pre></pre>
<a class="header" href="print.html#returning-from-loops" id="returning-from-loops"><h2>Returning from loops</h2></a>
<p>One of the uses of a <code>loop</code> is to retry an operation you know can fail, such as
checking if a thread completed its job. However, you might need to pass the
result of that operation to the rest of your code. If you add it to the <code>break</code>
expression you use to stop the loop, it will be returned by the broken loop:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);
}
</code></pre></pre>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="store.js"></script>
        <script src="book.js"></script>
    </body>
</html>
