<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>테스트 조직화 - 테스트 조직화 - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <style>
            .page-wrapper.has-warning > .nav-chapters {
              /* add height for warning content & margin */
              top: 120px;
            }

            p.warning {
                background-color: rgb(242, 222, 222);
                border-bottom-color: rgb(238, 211, 215);
                border-bottom-left-radius: 4px;
                border-bottom-right-radius: 4px;
                border-bottom-style: solid;
                border-bottom-width: 0.666667px;
                border-image-outset: 0 0 0 0;
                border-image-repeat: stretch stretch;
                border-image-slice: 100% 100% 100% 100%;
                border-image-source: none;
                border-image-width: 1 1 1 1;
                border-left-color: rgb(238, 211, 215);
                border-left-style: solid;
                border-left-width: 0.666667px;
                border-right-color: rgb(238, 211, 215);
                border-right-style: solid;
                border-right-width: 0.666667px;
                border-top-color: rgb(238, 211, 215);
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                border-top-style: solid;
                border-top-width: 0.666667px;
                color: rgb(185, 74, 72);
                margin-bottom: 0px;
                margin-left: 0px;
                margin-right: 0px;
                margin-top: 30px;
                padding-bottom: 8px;
                padding-left: 14px;
                padding-right: 35px;
                padding-top: 8px;
            }
            p.warning strong {
                color: rgb(185, 74, 72)
            }
            p.warning a {
                color: rgb(0, 136, 204)
            }
        </style>

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="ch01-00-introduction.html"><strong>1.</strong> Introduction</a></li><li><ul class="section"><li><a href="ch01-01-installation.html"><strong>1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong>1.2.</strong> Hello, World!</a></li></ul></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong>2.</strong> 추리 게임 튜토리얼</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong>3.</strong> 보편적인 프로그래밍 개념</a></li><li><ul class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong>3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong>3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong>3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong>3.5.</strong> Control Flow</a></li></ul></li><li><a href="ch04-00-understanding-ownership.html"><strong>4.</strong> 소유권 이해하기</a></li><li><ul class="section"><li><a href="ch04-01-what-is-ownership.html"><strong>4.1.</strong> 소유권이 뭔가요?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong>4.2.</strong> 참조자와 빌림</a></li><li><a href="ch04-03-slices.html"><strong>4.3.</strong> 슬라이스</a></li></ul></li><li><a href="ch05-00-structs.html"><strong>5.</strong> 연관된 데이터들을 구조체로 다루기</a></li><li><ul class="section"><li><a href="ch05-01-defining-structs.html"><strong>5.1.</strong> 구조체를 정의하고 생성하기</a></li><li><a href="ch05-02-example-structs.html"><strong>5.2.</strong> 구조체를 이용한 예제 프로그램</a></li><li><a href="ch05-03-method-syntax.html"><strong>5.3.</strong> 메소드 문법</a></li></ul></li><li><a href="ch06-00-enums.html"><strong>6.</strong> 열거형과 패턴 매칭</a></li><li><ul class="section"><li><a href="ch06-01-defining-an-enum.html"><strong>6.1.</strong> 열거형 정의하기</a></li><li><a href="ch06-02-match.html"><strong>6.2.</strong> <code>match</code> 흐름 제어 연산자</a></li><li><a href="ch06-03-if-let.html"><strong>6.3.</strong> <code>if let</code>을 사용한 간결한 흐름 제어</a></li></ul></li><li><a href="ch07-00-modules.html"><strong>7.</strong> 모듈</a></li><li><ul class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong>7.1.</strong> <code>mod</code>와 파일 시스템</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong>7.2.</strong> <code>pub</code>으로 가시성 제어하기</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong>7.3.</strong> <code>use</code>로 이름 가져오기</a></li></ul></li><li><a href="ch08-00-common-collections.html"><strong>8.</strong> 일반적인 컬렉션</a></li><li><ul class="section"><li><a href="ch08-01-vectors.html"><strong>8.1.</strong> 벡터</a></li><li><a href="ch08-02-strings.html"><strong>8.2.</strong> 스트링</a></li><li><a href="ch08-03-hash-maps.html"><strong>8.3.</strong> 해쉬맵</a></li></ul></li><li><a href="ch09-00-error-handling.html"><strong>9.</strong> 에러 처리</a></li><li><ul class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong>9.1.</strong> <code>panic!</code>과 함께하는 복구 불가능한 에러</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong>9.2.</strong> <code>Result</code>와 함께하는 복구 가능한 에러</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong>9.3.</strong> <code>panic!</code>이냐, <code>panic!</code>이 아니냐, 그것이 문제로다</a></li></ul></li><li><a href="ch10-00-generics.html"><strong>10.</strong> 제네릭 타입, 트레잇, 그리고 라이프타임</a></li><li><ul class="section"><li><a href="ch10-01-syntax.html"><strong>10.1.</strong> 제네릭 데이터 타입</a></li><li><a href="ch10-02-traits.html"><strong>10.2.</strong> 트레잇: 공유 동작을 정의하기</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong>10.3.</strong> 라이프타임을 이용한 참조자 유효화</a></li></ul></li><li><a href="ch11-00-testing.html"><strong>11.</strong> 테스팅</a></li><li><ul class="section"><li><a href="ch11-01-writing-tests.html"><strong>11.1.</strong> 테스트 작성하기</a></li><li><a href="ch11-02-running-tests.html"><strong>11.2.</strong> 테스트 실행하기</a></li><li><a href="ch11-03-test-organization.html" class="active"><strong>11.3.</strong> 테스트 조직화</a></li></ul></li><li><a href="ch12-00-an-io-project.html"><strong>12.</strong> An I/O Project</a></li><li><ul class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong>12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong>12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong>12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong>12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong>12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong>12.6.</strong> Writing to <code>stderr</code> instead of <code>stdout</code></a></li></ul></li><li><a href="ch13-00-functional-features.html"><strong>13.</strong> Functional Language Features in Rust</a></li><li><ul class="section"><li><a href="ch13-01-closures.html"><strong>13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong>13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong>13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong>13.4.</strong> Performance</a></li></ul></li><li><a href="ch14-00-more-about-cargo.html"><strong>14.</strong> More about Cargo and Crates.io</a></li><li><ul class="section"><li><a href="ch14-01-release-profiles.html"><strong>14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong>14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong>14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong>14.4.</strong> Installing Binaries from Crates.io with <code>cargo install</code></a></li><li><a href="ch14-05-extending-cargo.html"><strong>14.5.</strong> Extending Cargo with Custom Commands</a></li></ul></li><li><a href="ch15-00-smart-pointers.html"><strong>15.</strong> Smart Pointers</a></li><li><ul class="section"><li><a href="ch15-01-box.html"><strong>15.1.</strong> <code>Box&lt;T&gt;</code> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong>15.2.</strong> The <code>Deref</code> Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong>15.3.</strong> The <code>Drop</code> Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong>15.4.</strong> <code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong>15.5.</strong> <code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong>15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ul></li><li><a href="ch16-00-concurrency.html"><strong>16.</strong> Fearless Concurrency</a></li><li><ul class="section"><li><a href="ch16-01-threads.html"><strong>16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong>16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong>16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong>16.4.</strong> Extensible Concurrency: <code>Sync</code> and <code>Send</code></a></li></ul></li><li><a href="ch17-00-oop.html"><strong>17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ul class="section"><li><a href="ch17-01-what-is-oo.html"><strong>17.1.</strong> What Does Object-Oriented Mean?</a></li><li><a href="ch17-02-trait-objects.html"><strong>17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong>17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ul></li><li><a href="ch18-00-patterns.html"><strong>18.</strong> Patterns Match the Structure of Values</a></li><li><ul class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong>18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="ch18-02-refutability.html"><strong>18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong>18.3.</strong> All the Pattern Syntax</a></li></ul></li><li><a href="ch19-00-advanced-features.html"><strong>19.</strong> Advanced Features</a></li><li><ul class="section"><li><a href="ch19-01-unsafe-rust.html"><strong>19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong>19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong>19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html"><strong>19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong>19.5.</strong> Advanced Functions &amp; Closures</a></li></ul></li><li><a href="ch20-00-final-project-a-web-server.html"><strong>20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ul class="section"><li><a href="ch20-01-single-threaded.html"><strong>20.1.</strong> A Single Threaded Web Server</a></li><li><a href="ch20-02-slow-requests.html"><strong>20.2.</strong> How Slow Requests Affect Throughput</a></li><li><a href="ch20-03-designing-the-interface.html"><strong>20.3.</strong> Designing the Thread Pool Interface</a></li><li><a href="ch20-04-storing-threads.html"><strong>20.4.</strong> Creating the Thread Pool and Storing Threads</a></li><li><a href="ch20-05-sending-requests-via-channels.html"><strong>20.5.</strong> Sending Requests to Threads Via Channels</a></li><li><a href="ch20-06-graceful-shutdown-and-cleanup.html"><strong>20.6.</strong> Graceful Shutdown and Cleanup</a></li></ul></li><li><a href="appendix-00.html"><strong>21.</strong> Appendix</a></li><li><ul class="section"><li><a href="appendix-01-keywords.html"><strong>21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong>21.2.</strong> B - Operators</a></li><li><strong>21.3.</strong> C - Derivable Traits</li><li><strong>21.4.</strong> D - Nightly Rust</li><li><strong>21.5.</strong> E - Macros</li><li><strong>21.6.</strong> F - Translations</li><li><a href="appendix-07-newest-features.html"><strong>21.7.</strong> G - Newest Features</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper has-warning">

            <div class="page">
                <header><p class="warning">You are reading a <strong>draft</strong> of the next edition of TRPL. For more, go <a href="../index.html">here</a>.</p></header>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">테스트 조직화 - The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>


                <div id="content" class="content">
                    <a class="header" href="ch11-03-test-organization.html#test-organization-테스트-조직화" id="test-organization-테스트-조직화"><h2>Test Organization 테스트 조직화</h2></a>
<p>이 장의 시작부분에서 언급했듯이, 테스팅은 넓은 분야이고, 여러 사람들이 서로 다른 용어와 조직화 방식을
이용합니다. 러스트 커뮤니티에서는 테스트에 대해서 두 개의 주요한 카테고리로 나눠 생각하는 경향이 있습니다:
<em>단위 테스트(unit test)</em> 그리고 *통합 테스트(integration test)*입니다. 단위 테스트는 좀 더
작고 더 집중적이며, 한 번에 하나의 모듈만 분리하여 테스트하고, 비공개 인터페이스 (private
interface)를 테스트 합니다. 통합 테스트는 완전히 여러분의 라이브러리 외부에 있으며, 공개 인터페이스
(public interface)를 이용하고 테스트마다 여러 개의 모듈을 실험함으로써, 다른 외부의 코드가 하는
방식과 동일한 형태로 여러분의 코드를 이용합니다.</p>
<p>두 종류의 테스트 모두 여러분의 라이브러리 코드 조각들이 따로따로 혹은 함께 사용되었을 때 여러분이
기대하는 바대로 작동하는 지를 확신시키는데 중요합니다.</p>
<a class="header" href="ch11-03-test-organization.html#단위-테스트" id="단위-테스트"><h3>단위 테스트</h3></a>
<p>단위 테스트의 목적은 각 코드의 단위를 나머지 부분과 분리하여 테스트하는 것인데, 이는 코드가 어디 있고
어느 부분이 기대한대로 동작하지 않는지를 빠르게 정확히 찾아낼 수 있도록 하기 위함입니다. 단위 테스트는
<em>src</em> 디렉토리 내에 넣는데, 각 파일마다 테스트하는 코드를 담고 있습니다. 관례는 각 파일마다 테스트
함수를 담고 있는 <code>tests</code>라는 이름의 모듈을 만들고, 이 모듈에 <code>cfg(test)</code>라고 어노테이션하는
것입니다.</p>
<a class="header" href="ch11-03-test-organization.html#테스트-모듈과-cfgtest" id="테스트-모듈과-cfgtest"><h4>테스트 모듈과 <code>#[cfg(test)]</code></h4></a>
<p>테스트 모듈 상의 <code>#[cfg(test)]</code> 어노테이션은 러스트에게 우리가 <code>cargo build</code>를 실행시킬 때가
아니라 <code>cargo test</code>를 실행시킬 때에만 컴파일하고 실행시키라고 말해줍니다. 이는 우리가 오직 라이브러리만
빌드하고 싶을 때 컴파일 시간을 절약시켜주고, 테스트가 포함되어 있지 않으므로 컴파일 결과물의 크기를
줄여줍니다. 통합 테스트는 다른 디렉토리에 위치하기 때문에, 여기에는 <code>#[cfg(test)]</code> 어노테이션이
필요치 않음을 앞으로 보게될 것입니다. 하지만, 단위 테스트가 해당 코드와 동일한 파일에 위치하기 때문에,
<code>#[cfg(test)]</code>를 사용하여 컴파일 결과물에 이들이 포함되지 않아야 함을 특정합니다.</p>
<p>이 장의 첫번째 절에서 새로운 <code>adder</code> 프로젝트를 생성했을 때, 카고가 우리를 위하여 아래와 같은 코드를
생성했던 것을 기억해 보세요:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
    }
}
#}</code></pre></pre>
<p>이는 자동으로 생성되는 테스트 모듈입니다. <code>cfg</code> 속성은 <em>환경 설정(configuration)</em> 을 의미하며,
러스트에게 뒤따르는 아이템이 특정한 환경값에 대해서만 포함되어야 함을 말해줍니다. 위의 경우, 환경값이
<code>test</code>인데, 테스트를 컴파일하고 실행하기 위해 러스트로부터 제공되는 것입니다. 이 속성을 이용함으로써,
카고는 우리가 능동적으로 <code>cargo test</code>를 이용해서 테스트를 실행시킬 경우에만 우리의 테스트 코드를
컴파일합니다. 이는 이 모듈 내에 있을지도 모를 어떠한 헬퍼 함수들, 추가적으로 <code>#[test]</code>라고
어노테이션된 함수들을 포함합니다.</p>
<a class="header" href="ch11-03-test-organization.html#비공개-함수-테스트하기" id="비공개-함수-테스트하기"><h4>비공개 함수 테스트하기</h4></a>
<p>테스팅 커뮤니티 내에서 비공개 함수가 직접적으로 테스트 되어야 하는지 혹은 그렇지 않은지에 대한 논쟁이
있었고, 다른 언어들은 비공개 함수를 테스트하는 것이 어렵거나 불가능하게 만들어두었습니다. 여러분이
어떤 테스트 이데올로기를 고수하는지와는 상관없이, 러스트의 비공개 규칙은 여러분이 비공개 함수를
테스트하도록 허용해줍니다. 비공개 함수 <code>internal_adder</code>가 있는 Listing 11-12 내의 코드를
고려해 보시죠:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-12: 비공개 함수 테스트하기</span></p>
<!-- I'm not clear on why we would assume this might not be fine, why are we
highlighting this specifically? -->
<!-- We're addressing experience that the reader might bring with them from
other languages where this is not allowed; I added a sentence mentioning "other
languages" at the beginning of this section. Also testing private functions
from integration tests is not allowed, so if you did want to do this, you'd
have to do it in unit tests. /Carol -->
<p><code>internal_adder</code> 함수는 <code>pub</code>으로 표시되어 있지 않지만, 테스트가 그저 러스트 코드일 뿐이고
<code>tests</code> 모듈도 그냥 또다른 모듈이기 때문에, <code>internal_adder</code>를 불러들여 호출하는 것이 그냥 되는
것을 주목하세요. 만약 여러분이 비공개 함수를 테스트해야 한다고 생각하지 않는다면, 러스트에서는 여러분이
그렇게 하도록 강제할 일은 없습니다.</p>
<a class="header" href="ch11-03-test-organization.html#통합-테스트" id="통합-테스트"><h3>통합 테스트</h3></a>
<p>러스트에서 통합 테스트들은 완전히 여러분의 라이브러리 외부에 있습니다. 이들은 여러분의 라이브러리를
다른 코드들과 동일한 방식으로 이용하는데, 이는 이 외부 테스트들이 오직 여러분의 라이브러리의 공개
API 부분에 속하는 함수들만 호출할 수 있다는 의미입니다. 이들의 목적은 여러분의 라이브러리의 수많은
파트들이 함께 올바르게 동작하는지를 시험하는 것입니다. 그자체로서는 올바르게 동작하는 코드의 단위들도
통합되었을 때는 문제를 일으킬 수 있으므로, 통합된 코드의 테스트 커버율 또한 중요합니다. 통합 테스트를
만들기 위해서는 <em>tests</em> 디렉토리를 먼저 만들 필요가 있습니다.</p>
<a class="header" href="ch11-03-test-organization.html#tests-디렉토리" id="tests-디렉토리"><h4><em>tests</em> 디렉토리</h4></a>
<p>우리의 코드를 위한 통합 테스트를 작성하기 위해서, 우리 프로젝트 디렉토리의 최상위, 그러니까 <em>src</em> 옆에
<em>tests</em> 디렉토리를 만들어줄 필요가 있습니다. 카고는 이 디렉토리 내의 통합 테스트 파일들을 찾을줄
압니다. 그리고난 후에는 이 디렉토리에 원하는 만큼 많은 테스트 파일을 만들 수 있으며, 카고는 각각의
파일들을 개별적인 크레이트처럼 컴파일할 것입니다.</p>
<p>한번 시도해 봅시다! Listing 11-12의 <em>src/lib.rs</em> 코드를 그대로 유지하세요. <em>tests</em> 디렉토리를
만들고, <em>tests/integration_test.rs</em>라는 이름의 새 파일을 만든 다음, Listing 11-13의 코드를
집어넣으세요.</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">extern crate adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p><span class="caption">Listing 11-13: <code>adder</code> 크레이트 내의 함수에 대한 통합 테스트
</span></p>
<p>상단에 <code>extern crate adder</code>를 추가했는데, 이는 단위 테스트에서는 필요없었지요. 이는 <code>tests</code>
디렉토리 내의 각 테스트가 모두 개별적인 크레이트이라서, 우리의 라이브러리를 각각에 가져올 필요가 있기
때문입니다. 통합 테스트는 이 크레이트를 가져오고 오직 공개 API만 사용함으로써, 이 라이브러리를 다른
어떤 사용자들과 마찬가지로 이용합니다.</p>
<p><em>tests/integration_test.rs</em>에는 <code>#[cfg(test)]</code>를 이용한 어노테이션을 해줄 필요가
없습니다. 카고는 <code>test</code> 디렉토리를 특별취급하여 <code>cargo test</code>를 실행시켰을 때에만 이 디렉토리
내의 파일들을 컴파일합니다. 이제 <code>cargo test</code> 실행을 시도해봅시다:</p>
<pre><code class="language-text">cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running target/debug/deps/adder-abcabcabc

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/debug/deps/integration_test-ce99bcc2479f4607

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<!-- what are the doc tests? How do we tell the difference between unit and
integration tests here? -->
<!-- We mentioned documentation tests in the beginning of this chapter /Carol
-->
<p>이제 출력에 세 개의 섹션이 생겼습니다: 단위 테스트, 통합 테스트, 그리고 문서 테스트입니다. 단위 테스트를
위한 첫번째 섹션은 우리가 봐오던 것과 동일합니다: 각각의 단위 테스트마다 한 라인 (Listing 11-12에서
우리가 추가한 <code>intenal</code>이라는 이름의 것이 있었죠), 그 다음 단위 테스트들의 정리 라인이 있습니다.</p>
<p>통합 테스트 섹션은 <code>Running target/debug/deps/integration-test-ce99bcc2479f4607</code>
이라고 말하는 라인과 함께 시작합니다 (여러분의 출력값 끝의 해쉬값은 다를 것입니다). 그다음 이 통합
테스트 안의 각 테스트 함수를 위한 라인이 있고, <code>Doc-tests adder</code> 섹션이 시작되기 직전에
통합 테스트의 결과를 위한 정리 라인이 있습니다.</p>
<p>어떠한 <em>src</em> 파일에 단위 테스트 함수를 더 추가하는 것이 단위 테스트 섹션의 테스트 결과 라인을 더 늘릴
것아는 점을 주목하세요. 통합 테스트 파일에 테스트 함수를 더 추가하는 것은 통합 테스트 섹션의 라인을
더 늘릴 것입니다. 각 통합 테스트 파일은 고유의 섹션을 가지고 있으므로, 만일 우리가 <em>tests</em> 디렉토리에
파일을 더 추가하면, 통합 테스트 생선이 더 생길 것입니다.</p>
<p><code>cargo test</code>의 인자로서 테스트 함수의 이름을 명시하는 식으로 특정 통합 테스트 함수를 실행시키는 것도
여전히 가능합니다. 특정한 통합 테스트 파일 내의 모든 테스트를 실행시키기 위해서는, <code>cargo test</code>에
파일 이름을 뒤에 붙인 <code>--test</code> 인자를 사용하세요:</p>
<pre><code class="language-text">$ cargo test --test integration_test
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/integration_test-952a27e0126bb565

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>이는 <em>tests</em> 디렉토리로부터 우리가 명시한 파일만 테스트합니다.</p>
<a class="header" href="ch11-03-test-organization.html#통합-테스트-내의-서브모듈" id="통합-테스트-내의-서브모듈"><h4>통합 테스트 내의 서브모듈</h4></a>
<p>더 많은 통합 테스트를 추가하게 되면, 이들을 조직화하기 쉽도록 <em>tests</em> 디렉토리 내에 하나 이상의
파일을 만들고 싶어할지도 모릅니다; 예를 들면, 이들이 테스트하는 기능별로 테스트 함수들을 묶는다던가
하는 식으로요. 언급했듯이, <em>tests</em> 디렉토리 내의 각 파일은 고유의 개별적인 크레이트인 것처럼
컴파일됩니다.</p>
<p>각 통합 테스트 파일을 고유한 크레이트인것 처럼 다루는 것은 여러분의 크레이트를 이용하게 될
사용자들의 방식과 더 유사하게 분리된 스코프를 만들어 내기에 유용합니다. 하지만, 이는 우리가 7장에서
코드를 모듈과 파일로 나누는 법에 대해 배웠던 바대로 <em>src</em> 내의 파일들이 동일한 동작을 공유하는 것을
<em>tests</em> 디렉토리 내의 파일들에서는 할수 없음을 의미합니다.</p>
<p>The different behavior of files in the <em>tests</em> directory is usually most
noticeable if you have a set of helper functions that would be useful in
multiple integration test files, and you try to follow the steps from Chapter 7
to extract them into a common module. For example, if we create
<em>tests/common.rs</em> and place this function named <code>setup</code> in it, where we could
put some code that we want to be able to call from multiple test functions in
multiple test files:
만일 여러분이 여러 개의 통합 테스트 파일들 내에서 유용하게 사용될 헬퍼 함수들 묶음을 가지고 있으며,
이들을 공통 모듈로 추출하기 위해 7장으로부터의 단계를 따르는 시도를 한다면, 이러한 <em>tests</em> 디렉토리
내의 파일에 대한 이색적인 동작 방식은 가장 주목할만 점입니다. 이를테면, 만일 우리가 <em>tests/common.rs</em>
이라는 파일을 만들어서 그 안에 아래와 같이 <code>setup</code>이라는 이름의 함수를 위치시키고, 여기에 여러
테스트 파일들 내의 여러 테스트 함수로부터 호출될 수 있기를 원하는 어떤 코드를 집어넣는다면:</p>
<p><span class="filename">Filename: tests/common.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn setup() {
    // 여러분의 라이브러리 테스트에 특화된 셋업 코드가 여기 올 것입니다
}
#}</code></pre></pre>
<p>만약 테스트를 다시 실행시키면, 비록 이 코드가 어떠한 테스트 함수도 담고 있지 않고, <code>setup</code> 함수를
다른 어딘가에서 호출하고 있지 않을지라도, <em>common.rs</em> 파일을 위한 테스트 출력 내의 새로운 섹션을
보게 될 것입니다:</p>
<pre><code class="language-text">running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/debug/deps/common-b8b07b6f1be2db70

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured

     Running target/debug/deps/integration_test-d993c68b431d39df

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<!-- The new section is lines 6-10, will ghost everything else in libreoffice
/Carol -->
<p><code>running 0 tests</code>이 표시되는 테스트 출력이 보여지는 <code>common</code>을 만드는 건 우리가 원하던 것이
아닙니다; 우리는 그저 다른 통합 테스트 파일들에서 어떤 코드를 공유할 수 있기를 원했지요.</p>
<p><code>common</code>이 테스트 출력에 나타나지 않도록 하기 위해서는, 우리가 7장에서 배웠던 코드를 파일로 추출하는
다른 방법을 이용할 필요가 있습니다: <em>tests/common.rs</em>을 만드는 대신, <em>tests/common/mod.rs</em>를
만듭니다. <code>setup</code> 함수 코드를 <em>tests/common/mod.rs</em>로 옮기고 <em>tests/common.rs</em> 파일을
제거하면, 테스트 출력에서 해당 섹션이 더이상 나타나지 않을 것입니다. <em>tests</em> 디렉토리의 서브디렉토리 내의
파일들은 개별적인 크레이트처럼 컴파일되지도, 테스트 출력의 섹션을 갖지도 않습니다.</p>
<p>일단 <em>tests/common/mod.rs</em>를 갖게 되면, 어떤 통합 테스트 파일에서라도 모듈처럼 쓸 수 있습니다.
아래에 <em>tests/integration_test.rs</em> 내에 <code>it_adds_two</code> 테스트로부터 <code>setup</code> 함수를 호출하는
예제가 있습니다:</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">extern crate adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p><code>mod common;</code> 선언은 7장에서 했던 모듈 선언과 동일한 점을 주목하세요. 그런 다음 테스트 함수 내에서
<code>common::setup()</code> 함수를 호출 할 수 있습니다.</p>
<a class="header" href="ch11-03-test-organization.html#바이너리-크레이트를-위한-통합-테스트" id="바이너리-크레이트를-위한-통합-테스트"><h4>바이너리 크레이트를 위한 통합 테스트</h4></a>
<p>만약 우리의 프로젝트가 <em>src/lib.rs</em>가 없고 <em>src/main.rs</em>만 갖고 있는 바이너리 프로젝트라면,
<em>tests</em> 디렉토리 내에 통합 테스트를 만들어서 <em>src/main.rs</em>에 정의된 함수를 가져오기 위하여
<code>extern crate</code>를 이용할 수 없습니다. 오직 라이브러리 크레이트만 다른 크레이트에가 호출하고 사용할
수 있는 함수들을 노출시킵니다; 바이너리 크레이트는 그 스스로 실행될 것으로 여겨집니다.</p>
<p>이는 바이너리를 제공하는 러스트 프로젝트들이 <em>src/lib.rs</em>에 위치한 로직을 호출하는 간단한 형태의
<em>src/main.rs</em>를 가지고 있는 이유 중 하나입니다. 이러한 구조와 함께라면, <code>extern crate</code>를
이용하여 중요한 기능들을 커버하도록 하기 위해 통합 테스트가 라이브러리 크레이트를 <em>테스트할 수 있습니다</em>.
만일 중요 기능이 작동한다면, <em>src/main.rs</em> 내의 소량의 코드 또한 동작할 것이고, 이 소량의 코드는
테스트할 필요가 없습니다.</p>
<a class="header" href="ch11-03-test-organization.html#정리" id="정리"><h2>정리</h2></a>
<p>러스트의 테스트 기능은 코드를 변경하더라도 계속하여 우리가 기대한대로 동작할 것이라는 확신을 주기 위하여
코드가 어떻게 기능하는지 명시하는 방법을 제공합니다. 단위 테스트는 라이브러리의 서로 다른 부분을 개별적으로
시험하며 비공개된 구현 세부사항을 테스트할 수 있습니다. 통합 테스트는 라이브러리의 많은 부분이 함께 작동하는
사용 상황을 다루며, 외부 코드가 사용하게 될 똑같은 방식대로 테스트하기 위해 그 라이브러리의 공개 API를
이용합니다. 비록 러스트의 타입 시스템과 소유권 규칙이 몇가지 종류의 버그를 방지하는데 도움을 줄지라도,
테스트는 여러분의 코드가 어떻게 동작하기를 기대하는지와 함께 해야 하는 논리 버그를 잡는 일을 도와주는데에
있어 여전히 중요합니다.</p>
<p>이 장과 이전 장들의 지식을 합쳐서 다음 장의 프로젝트 작업을 해봅시다!</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ch11-02-running-tests.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch12-00-an-io-project.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ch11-02-running-tests.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="ch12-00-an-io-project.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="store.js"></script>
        <script src="book.js"></script>
    </body>
</html>
