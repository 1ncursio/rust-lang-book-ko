## 모든 패턴 문법

여러분은 이 책을 읽는 내내 수많은 종류의 패턴 예시를 보셨을 겁니다.
이번 절에선 유효한 패턴 구문을 모두 살펴보고,
그것들을 각각 왜 사용해야 하는지 알아보도록 하겠습니다.

### 리터럴 매칭

6장에서 보신 것 처럼 여러분은 패턴과 리터럴을 직접 매칭할 수 있습니다.
다음 코드가 예시입니다.

```rust
let x = 1;

match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

`x` 의 값이 1 이기 때문에 이 코드는 `one` 을 출력합니다.
이 문법은 특정한 구체적인 값을 가질때 행동하도록
여러분의 코드를 작성하는데 도움이 됩니다.

### 명명 변수 매칭

명명 변수는 어떠한 값에도 매칭되는 반증 불가능한 패턴이며,
우린 이걸 이 책에서 여러번 써왔습니다. 어찌됐건, 여러분이 `match`
표현에서 명명 변수를 사용할때 문제가 있습니다.
바로 `match` 는 새로운 스코프를 만들기 때문에 `match` 표현 내에서
패턴의 일부로서 선언된 변수는 `match` 구조 외부의 동일한 이름을 가진
변수를 가려버린다는 겁니다.
Listing 18-11 에서 `Some(5)` 값으로 `x` 변수를 선언하고, `10` 값으로
`y` 를 선언했습니다. 한번 코드를 실행하거나 계속해서 읽지 않고 매칭
갈래 내의 패턴과 마지막의 `println!` 을 보고 이 코드가 뭘 출력할지
맞춰보세요:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(y) => println!("Matched, y = {:?}", y),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {:?}", x, y);
}
```

<span class="caption">Listing 18-11: 갈래에서 `y` 변수를 새로 만들어
기존의 것이 가려지도록 한 `match` 표현</span>

`match` 표현이 실행되었을때 어떤 일이 일어나는지 살펴봅시다.
일단 첫번째 갈래는 정의된 변수 `x` 와 매칭되지 않으니,
해당 코드는 실행되지 않고 넘어갑니다.

두번째 갈래 패턴에서는 `Some` 값 안에 있는 값에 대응될 새 변수 `y` 가
등장합니다. 현재 우린 `match` 표현 내의 새로운 스코프에 위치해 있기
때문에, 이 `y` 는 처음에 10 의 값을 갖도록 선언한 것이 아니라 새로운
변수입니다. 이 새로운 `y` 는 우리가 `x` 로 가지고 있는 `Some` 내부의
어떠한 값으로 바인딩될 것입니다. 따라서, 이 새 `y` 는 `x` 의 `Some` 내부
값인 `5` 로 바인딩 되고, 해당 갈래의 표현이 실행되어 `Matched, y = 5` 가
출력됩니다.

만약 `x` 가 `Some(5)` 이 아니라 `None` 값을 갖고 있었다면 첫번째와 두번째
갈래는 매치되지 않고 언더스코어와 매칭되었을 겁니다.
언더스코어 갈래에선 `x` 변수를 새로 만들지 않았기에 `x` 는
가려지지 않은 상태로 여전히 바깥의 `x` 변수를 나타내고,
만약 코드를 실행한다면 `match` 는
`Default case, x = None` 을 출력 할 겁니다.

`match` 표현이 끝나면 안쪽의 `y` 를 갖던 스코프도 끝납니다. 그리고
마지막 `println!` 은 `at the end: x = Some(5), y = 10` 를 출력합니다.

기존 변수를 가리는 변수를 만들지 않고 외부의 `x` 와 `y` 의 값을 비교하는
`match` 표현을 만들기 위해선 조건부(conditional) 매치 가드(match gaurd) 를
사용해야 하는데, 매치 가드에 대해선 이후 (검수 필요) “Extra
Conditionals with Match Guards” 절에서 다루도록 하겠습니다.

### 여러개의(Multiple) 패턴

여러분은 `match` 표현 내에서 *or* 을 뜻하는 `|` 문법을 이용해 여러개의 패턴과
매치시킬 수 있습니다. 예를 들어, 다음 코드는 `x` 값을 매치 갈래와 매치시키는데,
첫번째 갈래에서 *or* 옵션을 사용하고 있습니다. 이럴 경우 해당 갈래 내의 값 중
일치하는 값이 있으면, 즉 `x` 가 `1` 이나 `2` 일 경우 해당 갈래의 코드가
실행됩니다:

```rust
let x = 1;

match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

따라서 코드는 `one or two` 를 출력합니다.
