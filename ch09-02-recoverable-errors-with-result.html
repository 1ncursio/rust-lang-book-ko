<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>`Result`와 함께하는 복구 가능한 에러 - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <style>
            .page-wrapper.has-warning > .nav-chapters {
              /* add height for warning content & margin */
              top: 120px;
            }

            p.warning {
                background-color: rgb(242, 222, 222);
                border-bottom-color: rgb(238, 211, 215);
                border-bottom-left-radius: 4px;
                border-bottom-right-radius: 4px;
                border-bottom-style: solid;
                border-bottom-width: 0.666667px;
                border-image-outset: 0 0 0 0;
                border-image-repeat: stretch stretch;
                border-image-slice: 100% 100% 100% 100%;
                border-image-source: none;
                border-image-width: 1 1 1 1;
                border-left-color: rgb(238, 211, 215);
                border-left-style: solid;
                border-left-width: 0.666667px;
                border-right-color: rgb(238, 211, 215);
                border-right-style: solid;
                border-right-width: 0.666667px;
                border-top-color: rgb(238, 211, 215);
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                border-top-style: solid;
                border-top-width: 0.666667px;
                color: rgb(185, 74, 72);
                margin-bottom: 0px;
                margin-left: 0px;
                margin-right: 0px;
                margin-top: 30px;
                padding-bottom: 8px;
                padding-left: 14px;
                padding-right: 35px;
                padding-top: 8px;
            }
            p.warning strong {
                color: rgb(185, 74, 72)
            }
            p.warning a {
                color: rgb(0, 136, 204)
            }
        </style>

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="ch01-00-introduction.html"><strong>1.</strong> Introduction</a></li><li><ul class="section"><li><a href="ch01-01-installation.html"><strong>1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong>1.2.</strong> Hello, World!</a></li></ul></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong>2.</strong> 추리 게임 튜토리얼</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong>3.</strong> 보편적인 프로그래밍 개념</a></li><li><ul class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong>3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong>3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong>3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong>3.5.</strong> Control Flow</a></li></ul></li><li><a href="ch04-00-understanding-ownership.html"><strong>4.</strong> 소유권 이해하기</a></li><li><ul class="section"><li><a href="ch04-01-what-is-ownership.html"><strong>4.1.</strong> 소유권이 뭔가요?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong>4.2.</strong> 참조자와 빌림</a></li><li><a href="ch04-03-slices.html"><strong>4.3.</strong> 슬라이스</a></li></ul></li><li><a href="ch05-00-structs.html"><strong>5.</strong> 연관된 데이터들을 구조체로 다루기</a></li><li><ul class="section"><li><a href="ch05-01-defining-structs.html"><strong>5.1.</strong> 구조체를 정의하고 생성하기</a></li><li><a href="ch05-02-example-structs.html"><strong>5.2.</strong> An Example Program Using Structs</a></li><li><a href="ch05-03-method-syntax.html"><strong>5.3.</strong> Method Syntax</a></li></ul></li><li><a href="ch06-00-enums.html"><strong>6.</strong> 열거형과 패턴 매칭</a></li><li><ul class="section"><li><a href="ch06-01-defining-an-enum.html"><strong>6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong>6.2.</strong> The <code>match</code> Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong>6.3.</strong> Concise Control Flow with <code>if let</code></a></li></ul></li><li><a href="ch07-00-modules.html"><strong>7.</strong> 모듈</a></li><li><ul class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong>7.1.</strong> <code>mod</code>와 파일 시스템</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong>7.2.</strong> <code>pub</code>으로 가시성 제어하기</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong>7.3.</strong> <code>use</code>로 이름 가져오기</a></li></ul></li><li><a href="ch08-00-common-collections.html"><strong>8.</strong> 일반적인 컬렉션</a></li><li><ul class="section"><li><a href="ch08-01-vectors.html"><strong>8.1.</strong> 벡터</a></li><li><a href="ch08-02-strings.html"><strong>8.2.</strong> 스트링</a></li><li><a href="ch08-03-hash-maps.html"><strong>8.3.</strong> 해쉬맵</a></li></ul></li><li><a href="ch09-00-error-handling.html"><strong>9.</strong> 에러 처리</a></li><li><ul class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong>9.1.</strong> <code>panic!</code>과 함께하는 복구 불가능한 에러</a></li><li><a href="ch09-02-recoverable-errors-with-result.html" class="active"><strong>9.2.</strong> <code>Result</code>와 함께하는 복구 가능한 에러</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong>9.3.</strong> <code>panic!</code>이냐, <code>panic!</code>이 아니냐, 그것이 문제로다</a></li></ul></li><li><a href="ch10-00-generics.html"><strong>10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ul class="section"><li><a href="ch10-01-syntax.html"><strong>10.1.</strong> Generic Data Types</a></li><li><a href="ch10-02-traits.html"><strong>10.2.</strong> Traits: Defining Shared Behavior</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong>10.3.</strong> Validating References with Lifetimes</a></li></ul></li><li><a href="ch11-00-testing.html"><strong>11.</strong> Testing</a></li><li><ul class="section"><li><a href="ch11-01-writing-tests.html"><strong>11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong>11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong>11.3.</strong> Test Organization</a></li></ul></li><li><a href="ch12-00-an-io-project.html"><strong>12.</strong> An I/O Project</a></li><li><ul class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong>12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong>12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong>12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong>12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong>12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong>12.6.</strong> Writing to <code>stderr</code> instead of <code>stdout</code></a></li></ul></li><li><a href="ch13-00-functional-features.html"><strong>13.</strong> Functional Language Features in Rust</a></li><li><ul class="section"><li><a href="ch13-01-closures.html"><strong>13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong>13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong>13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong>13.4.</strong> Performance</a></li></ul></li><li><a href="ch14-00-more-about-cargo.html"><strong>14.</strong> More about Cargo and Crates.io</a></li><li><ul class="section"><li><a href="ch14-01-release-profiles.html"><strong>14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong>14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong>14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong>14.4.</strong> Installing Binaries from Crates.io with <code>cargo install</code></a></li><li><a href="ch14-05-extending-cargo.html"><strong>14.5.</strong> Extending Cargo with Custom Commands</a></li></ul></li><li><a href="ch15-00-smart-pointers.html"><strong>15.</strong> Smart Pointers</a></li><li><ul class="section"><li><a href="ch15-01-box.html"><strong>15.1.</strong> <code>Box&lt;T&gt;</code> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong>15.2.</strong> The <code>Deref</code> Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong>15.3.</strong> The <code>Drop</code> Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong>15.4.</strong> <code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong>15.5.</strong> <code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong>15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ul></li><li><a href="ch16-00-concurrency.html"><strong>16.</strong> Fearless Concurrency</a></li><li><ul class="section"><li><a href="ch16-01-threads.html"><strong>16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong>16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong>16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong>16.4.</strong> Extensible Concurrency: <code>Sync</code> and <code>Send</code></a></li></ul></li><li><a href="ch17-00-oop.html"><strong>17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ul class="section"><li><a href="ch17-01-what-is-oo.html"><strong>17.1.</strong> What Does Object-Oriented Mean?</a></li><li><a href="ch17-02-trait-objects.html"><strong>17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong>17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ul></li><li><a href="ch18-00-patterns.html"><strong>18.</strong> Patterns Match the Structure of Values</a></li><li><ul class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong>18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="ch18-02-refutability.html"><strong>18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong>18.3.</strong> All the Pattern Syntax</a></li></ul></li><li><a href="ch19-00-advanced-features.html"><strong>19.</strong> Advanced Features</a></li><li><ul class="section"><li><a href="ch19-01-unsafe-rust.html"><strong>19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong>19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong>19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html"><strong>19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong>19.5.</strong> Advanced Functions &amp; Closures</a></li></ul></li><li><a href="ch20-00-final-project-a-web-server.html"><strong>20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ul class="section"><li><a href="ch20-01-single-threaded.html"><strong>20.1.</strong> A Single Threaded Web Server</a></li><li><a href="ch20-02-slow-requests.html"><strong>20.2.</strong> How Slow Requests Affect Throughput</a></li><li><a href="ch20-03-designing-the-interface.html"><strong>20.3.</strong> Designing the Thread Pool Interface</a></li><li><a href="ch20-04-storing-threads.html"><strong>20.4.</strong> Creating the Thread Pool and Storing Threads</a></li><li><a href="ch20-05-sending-requests-via-channels.html"><strong>20.5.</strong> Sending Requests to Threads Via Channels</a></li><li><a href="ch20-06-graceful-shutdown-and-cleanup.html"><strong>20.6.</strong> Graceful Shutdown and Cleanup</a></li></ul></li><li><a href="appendix-00.html"><strong>21.</strong> Appendix</a></li><li><ul class="section"><li><a href="appendix-01-keywords.html"><strong>21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong>21.2.</strong> B - Operators</a></li><li><strong>21.3.</strong> C - Derivable Traits</li><li><strong>21.4.</strong> D - Nightly Rust</li><li><strong>21.5.</strong> E - Macros</li><li><strong>21.6.</strong> F - Translations</li><li><a href="appendix-07-newest-features.html"><strong>21.7.</strong> G - Newest Features</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper has-warning">

            <div class="page">
                <header><p class="warning">You are reading a <strong>draft</strong> of the next edition of TRPL. For more, go <a href="../index.html">here</a>.</p></header>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>


                <div id="content" class="content">
                    <a class="header" href="ch09-02-recoverable-errors-with-result.html#result와-함께하는-복구-가능한-에러" id="result와-함께하는-복구-가능한-에러"><h2><code>Result</code>와 함께하는 복구 가능한 에러</h2></a>
<p>대부분의 에러는 프로그램을 전부 멈추도록 요구될 정도로 심각하지는 않습니다. 종종 어떤 함수가 실패할
때는, 우리가 쉽게 해석하고 대응할 수 있는 이유에 대한 것입니다. 예를 들어, 만일 우리가 어떤 파일을
여는데 해당 파일이 존재하지 않아서 연산에 실패했다면, 프로세스를 멈추는 대신 파일을 새로 만드는
것을 원할지도 모릅니다.</p>
<p>2장의 “<a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type"><code>Result</code> 타입으로 잠재된 실패 다루기</a><!-- ignore -->”에서
<code>Result</code> 열거형은 다음과 같이 <code>Ok</code>와 <code>Err</code>라는 두 개의 variant를 갖도록 정의되어 있음을
상기하세요:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}

#}</code></pre></pre>
<p><code>T</code>와 <code>E</code>는 제네릭 타입 파라미터입니다; 10장에서 제네릭에 대해 더 자세히 다룰 것입니다. 지금으로서
여러분이 알아둘 필요가 있는 것은, <code>T</code>는 성공한 경우에 <code>Ok</code> variant 내에 반환될 값의 타입을 나타내고
<code>E</code>는 실패한 경우에 <code>Err</code> variant 내에 반환될 에러의 타입을 나타내는 것이라는 점입니다. <code>Result</code>가
이러한 제네릭 타입 파라미터를 갖기 때문에, 우리가 반환하고자 하는 성공적인 값과 에러 값이 다를 수 있는
다양한 상황 내에서 표준 라이브러리에 정의된 <code>Result</code> 타입과 함수들을 사용할 수 있습니다.</p>
<p>Listing 9-2에서 보시는 것 처럼 파일을 열 때 함수가 실패할 수도 있어 <code>Result</code> 값을 반환하는 함수를
호출해 봅시다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 9-2: 파일 열기</span></p>
<p><code>File::open</code>이 <code>Result</code>를 반환하는지 어떻게 알까요? 표준 라이브러리 API 문서를 찾아보거나,
컴파일러에게 물어볼 수 있습니다! 만일 <code>f</code>에게 우리가 알고 있고 그 함수의 반환 타입은 <em>아닐</em> 어떤 타입에
대한 타입 명시를 주고, 그리고 그 코드의 컴파일을 시도한다면, 컴파일러는 우리에게 타입이 맞지 않는다고
알려줄 것입니다. 그후 에러 메세지는 <code>f</code>의 타입이 <em>무엇인지</em> 알려줄 것입니다! 한번 해봅시다:
우리는 <code>File::open</code>의 반환 타입이 <code>u32</code>는 아니라는 것을 알고 있으니, <code>let f</code> 구문을 이렇게
바꿔봅시다:</p>
<pre><code class="language-rust ignore">let f: u32 = File::open(&quot;hello.txt&quot;);
</code></pre>
<p>이제 컴파일을 시도하면 다음 메세지가 나타납니다:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
  = note:    found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`
</code></pre>
<p>이 메세지는 <code>File::open</code> 함수의 반환 타입이 <code>Result&lt;T, E&gt;</code>라는 것을 알려줍니다. 여기서 제네릭
파라미터 <code>T</code>는 성공값의 타입인 <code>std::fs::File</code>로 체워져 있는데, 이것은 파일 핸들입니다. 에러에
사용되는 <code>E</code>의 타입은 <code>std::io::Error</code>입니다.</p>
<p>이 반환 타입은 <code>File::open</code>을 호출하는 것이 성공하여 우리가 읽거나 쓸 수 있는 파일 핸들을 반환해
줄 수도 있다는 뜻입니다. 함수 호출은 또한 실패할 수도 있습니다: 예를 들면 파일이 존재하지 않을지도
모르고, 혹은 파일에 접근할 권한이 없을지도 모릅니다. <code>File::open</code> 함수는 우리에게 성공했는지 혹은
실패했는지를 알려주고, 동시에 파일 핸들이나 에러 정보 둘 중 하나를 우리에게 제공할 방법을 가질 필요가
있습니다. 바로 이러한 정보가 <code>Result</code> 열거형이 전달하는 것과 정확히 일치합니다.</p>
<p><code>File::open</code>이 성공한 경우, 변수 <code>f</code>가 가지게 될 값은 파일 핸들을 담고 있는 <code>Ok</code> 인스턴스가
될 것입니다. 실패한 경우, <code>f</code>의 값은 발생한 에러의 종류에 대한 더 많은 정보를 가지고 있는 <code>Err</code>의
인스턴스가 될 것입니다.</p>
<p>우리는 Listing 9-2의 코드에 <code>File::open</code>이 반환하는 값에 따라 다른 행동을 취하는 코드를 추가할
필요가 있습니다. Listing 9-3은 우리가 6장에서 배웠던 기초 도구 <code>match</code> 표현식을 이용하여
<code>Result</code>를 처리하는 한 가지 방법을 보여줍니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            panic!(&quot;There was a problem opening the file: {:?}&quot;, error)
        },
    };
}
</code></pre></pre>
<p><span class="caption">Listing 9-3: <code>match</code> 표현식을 사용하여 발생 가능한 <code>Result</code>
variant들을 처리하기</span></p>
<p><code>Option</code> 열거형과 같이 <code>Result</code> 열거형과 variant들은 프렐루드(prelude)로부터 가져와진다는 점을
기억하세요. 따라서 <code>match</code>의 각 경우에 대해서 <code>Ok</code>와 <code>Err</code> 앞에 <code>Result::</code>를 특정하지 않아도
됩니다.</p>
<p>여기서 우리는 러스트에게 결과가 <code>Ok</code>일 때에는 <code>Ok</code> variant로부터 내부의 <code>file</code> 값을 반환하고,
이 파일 핸들 값을 변수 <code>f</code>에 대입한다고 말해주고 있습니다. <code>match</code> 이후에는 읽거나 쓰기 위해
이 파일 핸들을 사용할 수 있습니다.</p>
<p><code>match</code>의 다른 경우는 <code>File::open</code>으로부터 <code>Err</code>를 얻은 경우를 처리합니다. 이 예제에서는
<code>panic!</code> 매크로를 호출하는 방법을 택했습니다. 우리의 현재 디렉토리 내에 <em>hello.txt</em>라는 이름의
파일이 없는데 이 코드를 실행하게 되면, <code>panic!</code> 매크로로부터 다음과 같은 출력을 보게 될 것입니다:</p>
<pre><code class="language-text">thread 'main' panicked at 'There was a problem opening the file: Error { repr:
Os { code: 2, message: &quot;No such file or directory&quot; } }', src/main.rs:8
</code></pre>
<a class="header" href="ch09-02-recoverable-errors-with-result.html#서로-다른-에러에-대해-매칭하기" id="서로-다른-에러에-대해-매칭하기"><h3>서로 다른 에러에 대해 매칭하기</h3></a>
<p>Listing 9-3의 코드는 <code>File::open</code>이 실패한 이유가 무엇이든 간에 <code>panic!</code>을 일으킬 것입니다.
대신 우리가 진짜 하고 싶은 것은 실패 이유에 따라 다른 행동을 취하는 것입니다: 파일이 없어서
<code>File::open</code>이 실패한 것이라면, 새로운 파일을 만들어서 핸들을 반환하고 싶습니다. 만일 그밖의
이유로 <code>File::open</code>이 실패한 거라면, 예를 들어 파일을 열 권한이 없어서라면, Listing 9-3에서
했던 것과 마찬가지로 <code>panic!</code>을 일으키고 싶습니다. <code>match</code>에 새로운 경우를 추가한 Listing 9-4를
봅시다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(ref error) if error.kind() == ErrorKind::NotFound =&gt; {
            match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; {
                    panic!(
                        &quot;Tried to create file but there was a problem: {:?}&quot;,
                        e
                    )
                },
            }
        },
        Err(error) =&gt; {
            panic!(
                &quot;There was a problem opening the file: {:?}&quot;,
                error
            )
        },
    };
}
</code></pre>
<p><span class="caption">Listing 9-4: 다른 종류의 에러를 다른 방식으로 처리하기</span></p>
<p><code>Err</code> variant 내에 있는 <code>File::open</code>이 반환하는 값의 타입은 <code>io::Error</code>인데, 이는
표준 라이브러리에서 제공하는 구조체입니다. 이 구조체는 <code>kind</code> 메소드를 제공하는데 이를 호출하여
<code>io::ErrorKind</code>값을 얻을 수 있습니다. <code>io::ErrorKind</code>는 <code>io</code> 연산으로부터 발생할 수 있는
여러 종류의 에러를 표현하는 variant를 가진, 표준 라이브러리에서 제공하는 열거형입니다. 우리가
관심을 갖고 있는 variant는 <code>ErrorKind::NotFound</code>인데, 이는 열고자 하는 파일이 아직 존재하지
않음을 나타냅니다.</p>
<p>조건문 <code>if error.kind() == ErrorKind::NotFound</code>는 <em>매치 가드(match guard)</em> 라고
부릅니다: 이는 <code>match</code> 줄기 상에서 줄기의 패턴을 좀더 정제해주는 추가 조건문입니다. 그 줄기의 코드가
실행되기 위해서는 이 조건문이 참이어야 합니다; 그렇지 않다면, 패턴 매칭은 <code>match</code>의 다음 줄기에
맞춰보기 위해 이동할 것입니다. 패턴에는 <code>ref</code>가 필요하며 그럼으로써 <code>error</code>가 가드 조건문으로
소유권 이동이 되지 않고 그저 참조만 됩니다. 패턴 내에서 참조자를 얻기 위해 <code>&amp;</code>대신 <code>ref</code>이 사용되는
이유는 18장에서 자세히 다룰 것입니다. 짧게 설명하면, <code>&amp;</code>는 참조자를 매치하고 그 값을 제공하지만,
<code>ref</code>는 값을 매치하여 그 참조자를 제공합니다.</p>
<p>매치 가드 내에서 확인하고자 하는 조건문은 <code>error.kind()</code>에 의해 반환된 값이 <code>ErrorKind</code> 열거형의
<code>NotFound</code> variant인가 하는 것입니다. 만일 그렇다면, <code>File::create</code>로 파일 생성을 시도합니다.
그러나, <code>File::create</code> 또한 실패할 수 있기 때문에, 안쪽에 <code>match</code> 구문을 바깥쪽과 마찬가지로 추가할
필요가 있습니다! 파일이 열수 없을 때, 다른 에러 메세지가 출력될 것입니다. 바깥쪽 <code>match</code>의 마지막 갈래는
똑같이 남아서, 파일을 못 찾는 에러 외에 다른 어떤 에러에 대해서도 패닉을 일으킵니다.</p>
<a class="header" href="ch09-02-recoverable-errors-with-result.html#에러가-났을-때-패닉을-위한-숏컷-unwrap과-expect" id="에러가-났을-때-패닉을-위한-숏컷-unwrap과-expect"><h3>에러가 났을 때 패닉을 위한 숏컷: <code>unwrap</code>과 <code>expect</code></h3></a>
<p><code>match</code>의 사용은 충분히 잘 동작하지만, 살짝 장황하기도 하고 의도를 항상 잘 전달하는 것도 아닙니다.
<code>Result&lt;T, E&gt;</code> 타입은 다양한 것을 하기 위해 정의된 수많은 헬퍼 메소드를 가지고 있습니다. 그 중 하나인
<code>unwrap</code> 이라 부르는 메소드는 Listing 9-3에서 작성한 <code>match</code> 구문과 비슷한구현을 한 숏컷
메소드입니다. 만일 <code>Result</code> 값이 <code>Ok</code> variant라면, <code>unwrap</code>은 <code>Ok</code> 내의 값을 반환할 것입니다.
만일 <code>Result</code>가 <code>Err</code> variant라면, <code>unwrap</code>은 우리를 위해 <code>panic!</code> 매크로를 호출할 것입니다.</p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<p><em>hello.txt</em> 파일이 없는 상태에서 이 코드를 실행시키면, <code>unwrap</code> 메소드에 의한 <code>panic!</code>
호출로부터의 에러 메세지를 보게 될 것입니다:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
/stable-dist-rustc/build/src/libcore/result.rs:868
</code></pre>
<p>또한 <code>unwrap</code>과 유사하면서 우리가 <code>panic!</code> 에러 메세지를 선택할 수 있게 해주는 또다른 메소드인
<code>expect</code>도 있습니다. <code>unwrap</code>대신 <code>expect</code>를 이용하고 좋은 에러 메세지를 제공하는 것은 여러분의
의도를 전달해주고 패닉의 근원을 추적하는 걸 쉽게 해 줄수 있습니다. <code>expect</code>의 문법은 아래와 같이
생겼습니다:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
}
</code></pre></pre>
<p><code>expect</code>는 <code>unwrap</code>과 같은 식으로 사용됩니다: 파일 핸들을 리턴하거나 <code>panic!</code> 매크로를 호출하는
것이죠. <code>expect</code>가 <code>panic!</code> 호출에 사용하는 에러 메세지는 <code>unwrap</code>이 사용하는 기본 <code>panic!</code>
메세지 대신 <code>expect</code>에 넘기는 파라미터로 설정될 것입니다. 아래에 어떻게 생겼는지에 대한 예가 있습니다:</p>
<pre><code class="language-text">thread 'main' panicked at 'Failed to open hello.txt: Error { repr: Os { code:
2, message: &quot;No such file or directory&quot; } }',
/stable-dist-rustc/build/src/libcore/result.rs:868
</code></pre>
<a class="header" href="ch09-02-recoverable-errors-with-result.html#에러-전파하기" id="에러-전파하기"><h3>에러 전파하기</h3></a>
<p>실패할지도 모르는 무언가를 호출하는 구현을 가진 함수를 작성할때, 이 함수 내에서 에러를 처리하는 대신,
호출자가 에러를 알게 하여 그쪽에서 어떻게 할지 결정하도록 할 수 있습니다. 이는 에러 <em>전파하기</em>로 알려져
있으며, 에러가 어떻게 처리해야 좋을지 좌우해야 할 상황에서, 여러분의 코드 내용 내에서 이용 가능한 것들보다
더 많은 정보와 로직을 가지고 있을 수도 있는 호출하는 코드쪽에 더 많은 제어권을 줍니다.</p>
<p>예를 들면, Listing 9-5는 파일로부터 사용자 이름을 읽는 함수를 작성한 것입니다. 만일 파일이 존재하지
않거나 읽을 수 없다면, 이 함수는 호출하는 코드쪽으로 해당 에러를 반환할 것입니다:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}

#}</code></pre></pre>
<p><span class="caption">Listing 9-5: <code>match</code>를 이용하여 호출 코드 쪽으로 에러를 반환하는 함수
</span></p>
<p>함수의 반환 타입부터 먼저 살펴봅시다: <code>Result&lt;String, io::Error&gt;</code>. 이는 함수가 <code>Result&lt;T, E&gt;</code>
타입의 값을 반환하는데 제네릭 파라미터 <code>T</code>는 구체적 타입(concrete type)인 <code>String</code>로 채워져 있고,
제네릭 타입 <code>E</code>는 구체적 타입인 <code>io::Error</code>로 채워져 있습니다. 만일 이 함수가 어떤 문제 없이 성공하면,
함수의 호출자는 <code>String</code>을 담은 값을 받을 것입니다 - 이 함수가 파일로부터 읽어들인 사용자 이름이겠지요.
만일 어떤 문제가 발생한다면, 함수의 호출자는 문제가 무엇이었는지에 대한 더 많은 정보를 담고 있는
<code>io::Error</code>의 인스턴스를 담은 <code>Err</code> 값을 받을 것입니다. 이 함수의 반환 타입으로서 <code>io::Error</code>를
선택했는데, 그 이유는 우리가 이 함수 내부에서 호출하고 있는 실패 가능한 연산 두 가지가 모두 이 타입의
에러 값을 반환하기 때문입니다: <code>File::open</code> 함수와 <code>read_to_string</code> 메소드 말이죠.</p>
<p>함수의 본체는 <code>File::open</code> 함수를 호출하면서 시작합니다. 그 다음에는 Listing 9-3에서 본 <code>match</code>와
유사한 식으로 <code>match</code>을 이용해서 <code>Result</code> 값을 처리하는데, <code>Err</code> 경우에 <code>panic!</code>을 호출하는 대신
이 함수를 일찍 끝내고 <code>File::open</code>으로부터의 에러 값을 마치 이 함수의 에러 값인것처럼 호출자에게
전달합니다. 만일 <code>File::open</code>이 성공하면, 파일 핸들을 <code>f</code>에 저장하고 계속합니다.</p>
<p>그 뒤 변수 <code>s</code>에 새로운 <code>String</code>을 생성하고 파일의 콘텐츠를 읽어 <code>s</code>에 넣기 위해 <code>f</code>에 있는
파일 핸들의 <code>read_to_string</code> 메소드를 호출합니다. <code>File::open</code>가 성공하더라도 <code>read_to_string</code>
메소드가 실패할 수 있기 때문에 이 함수 또한 <code>Result</code>를 반환합니다. 따라서 이 <code>Result</code>를 처리하기
위해서 또다른 <code>match</code>가 필요합니다: 만일 <code>read_to_string</code>이 성공하면, 우리의 함수가 성공한
것이고, 이제 <code>s</code> 안에 있는 파일로부터 읽어들인 사용자 이름을 <code>Ok</code>에 싸서 반환합니다. 만일
<code>read_to_string</code>이 실패하면, <code>File::open</code>의 반환값을 처리했던 <code>match</code>에서 에러값을
반환하는 것과 같은 방식으로 에러 값을 반환합니다. 하지만 여기서는 명시적으로 <code>return</code>이라 말할 필요는
없는데, 그 이유는 이 함수의 마지막 표현식이기 때문입니다.</p>
<p>그러면 이 코드를 호출하는 코드는 사용자 이름을 담은 <code>Ok</code> 값 혹은 <code>io::Error</code>를 담은 <code>Err</code> 값을
얻는 처리를 하게 될 것입니다. 호출자가 이 값을을 가지고 어떤 일을 할 것인지 우리는 알지 못합니다.
만일 그들이 <code>Err</code> 값을 얻었다면, 예를 들면 <code>panic!</code>을 호출하여 프로그램을 종료시키는 선택을 할
수도 있고, 기본 사용자 이름을 사용할 수도 있으며, 혹은 파일이 아닌 다른 어딘가에서 사용자 이름을
찾을 수도 있습니다. 호출자가 정확히 어떤 것을 시도하려 하는지에 대한 충분한 정보가 없기 때문에,
우리는 모든 성공 혹은 에러 정보를 위로 전파하여 호출자가 그들에 맞는 처리를 하도록 합니다.</p>
<p>러스트에서 에러를 전파하는 패턴은 너무 흔하여 이를 더 쉽게 해주는 전용 문법이 있습니다: 바로 <code>?</code> 입니다.</p>
<a class="header" href="ch09-02-recoverable-errors-with-result.html#에러를-전파하기-위한-숏컷-" id="에러를-전파하기-위한-숏컷-"><h3>에러를 전파하기 위한 숏컷: <code>?</code></h3></a>
<p>Listing 9-6은 Listing 9-5과 같은 기능을 가진 <code>read_username_from_file</code>의 구현을 보여주는데,
다만 이 구현은 물음표 연산자를 이용하고 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}

#}</code></pre></pre>
<p><span class="caption">Listing 9-6: <code>?</code>를 이용하여 에러를 호출 코드쪽으로 반환하는 함수</span></p>
<p><code>Result</code> 값 뒤의 <code>?</code>는 Listing 9-5에서 <code>Result</code> 값을 다루기 위해 정의했던 <code>match</code> 표현식과
정확히 같은 방식으로 동작하게끔 정의되어 있습니다. 만일 <code>Result</code>의 값이 <code>Ok</code>라면, <code>Ok</code> 내의 값이
이 표현식으로부터 얻어지고 프로그램이 계속됩니다. 만일 값이 <code>Err</code>라면, 우리가 <code>return</code> 키워드를
사용하여 에러 값을 호출자에게 전파하는 것과 같이 전체 함수로부터 <code>Err</code> 내의 값이 반환될 것입니다.</p>
<p>Listing 9-6의 내용에서, <code>File::open</code> 호출 부분의 끝에 있는 <code>?</code>는 <code>Ok</code>내의 값을 변수 <code>f</code>에게
반환해줄 것입니다. 만일 에러가 발생하면 <code>?</code>는 전체 함수로부터 일찍 빠져나와 호출자에게 어떤 <code>Err</code> 값을
줄 것입니다. <code>read_to_string</code> 호출의 끝부분에 있는 <code>?</code>도 같은 것이 적용되어 있습니다.</p>
<p><code>?</code>는 많은 수의 보일러플레이트(boilerplate)를 제거해주고 이 함수의 구현을 더 단순하게 만들어 줍니다.
심지어는 <code>?</code> 뒤에 바로 메소드 호출을 연결하는 식으로 이 코드를 더 줄일 수도 있습니다:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}

#}</code></pre></pre>
<p>새로운 <code>String</code>을 만들어 <code>s</code>에 넣는 부분을 함수의 시작 부분으로 옮겼습니다; 이 부분은 달라진 것이
없습니다. <code>f</code> 변수를 만드는 대신, <code>File::open(&quot;hello.txt&quot;)?</code>의 결과 바로 뒤에
<code>read_to_string</code>의 호출을 연결시켰습니다. <code>read_to_string</code> 호출의 끝에는 여전히 <code>?</code>가
남아있고, <code>File::open</code>과 <code>read_to_string</code>이 모두 에러를 반환하지 않고 성공할 때
<code>s</code> 안의 사용자 이름을 담은 <code>Ok</code>를 여전히 반환합니다. 함수의 기능 또한 Lsting 9-5와
Listing 9-6의 것과 동일하고, 다만 작성하기에 더 인체공학적인 방법이라는 차이만 있을 뿐입니다.</p>
<a class="header" href="ch09-02-recoverable-errors-with-result.html#는-result를-반환하는-함수에서만-사용될-수-있습니다" id="는-result를-반환하는-함수에서만-사용될-수-있습니다"><h3><code>?</code>는 <code>Result</code>를 반환하는 함수에서만 사용될 수 있습니다</h3></a>
<p><code>?</code>는 <code>Result</code> 타입을 반환하는 함수에서만 사용이 가능한데, 이것이 Listing 9-5에 정의된 <code>match</code>
표현식과 정확히 동일한 방식으로 동작하도록 정의되어 있기 때문입니다. <code>Result</code> 반환 타입을 요구하는
<code>match</code> 부분은 <code>return Err(e)</code>이며, 따라서 함수의 반환 타입은 반드시 이 <code>return</code>과 호환 가능한
<code>Result</code>가 되어야 합니다.</p>
<p><code>main</code>의 반환 타입이 <code>()</code>라는 것을 상기하면서, 만약 <code>main</code> 함수 내에서 <code>?</code>를 사용하면 어떤일이 생길지
살펴봅시다:</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<!-- NOTE: as of 2016-12-21, the error message when calling `?` in a function
that doesn't return a result is STILL confusing. Since we want to only explain
`?` now, I've changed the example, but if you try running this code you WON'T
get the error message below.
I'm bugging people to try and get
https://github.com/rust-lang/rust/issues/35946 fixed soon, hopefully before this
chapter gets through copy editing-- at that point I'll make sure to update this
error message. /Carol -->
<p>이걸 컴파일하면, 아래와 같은 에러 메세지가 뜹니다:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt;
  |
3 |     let f = File::open(&quot;hello.txt&quot;)?;
  |             ^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found enum
`std::result::Result`
  |
  = note: expected type `()`
  = note:    found type `std::result::Result&lt;_, _&gt;`
</code></pre>
<p>이 에러는 잘못 매칭된 타입이 있음을 지적합니다: <code>main</code> 함수의 반환 타입은 <code>()</code>인데, <code>?</code>는
<code>Result</code>를 반환할지도 모른다는 것이죠. <code>Result</code>를 반환하지 않는 함수 내에서 여러분이 <code>Result</code>를
반환하는 다른 함수를 호출한다면, 여러분은 이를 처리하는데 있어 <code>?</code>를 이용하여 호출자에게 가능한 에러를
전파하는 대신, <code>match</code> 혹은 <code>Result</code> 메소드 중 하나를 이용할 필요가 있을 것입니다.
(역주: 현재는 좀 더 친절하게 상황을 설명하는 에러 메세지가 나오지만, 맥락은 유사합니다.)</p>
<p><code>panic!</code>을 호출하거나 <code>Result</code>를 반환하는 것의 자세한 부분을 논의했으니, 어떤 경우에 어떤 방법을
사용하는 것이 적합할지를 어떻게 결정하는가에 대한 주제로 돌아갑시다.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ch09-01-unrecoverable-errors-with-panic.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch09-03-to-panic-or-not-to-panic.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ch09-01-unrecoverable-errors-with-panic.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="ch09-03-to-panic-or-not-to-panic.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="store.js"></script>
        <script src="book.js"></script>
    </body>
</html>
